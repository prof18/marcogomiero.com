<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to use an in-memory database for testing on Ktor | Marco Gomiero</title><meta name=keywords content><meta name=description content="SERIES: Building a backend with Ktor
 Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-90975904-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="How to use an in-memory database for testing on Ktor"><meta property="og:description" content="SERIES: Building a backend with Ktor
 Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/"><meta property="og:image" content="https://www.marcogomiero.com/img/profile.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-04T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-04T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/profile.webp"><meta name=twitter:title content="How to use an in-memory database for testing on Ktor"><meta name=twitter:description content="SERIES: Building a backend with Ktor
 Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"How to use an in-memory database for testing on Ktor","item":"https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to use an in-memory database for testing on Ktor","name":"How to use an in-memory database for testing on Ktor","description":"SERIES: Building a backend with Ktor\n Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine.","keywords":[],"articleBody":"       SERIES: Building a backend with Ktor\n Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine.\nHowever, for automated testing, none of these databases will be suitable to use. Since the purpose of testing is checking that every part of the software is working as expected, it will be necessary to test also situations where there isn’t any data saved in the database. To achieve that, the database must be cleared after every test (or group of tests) or pre-populated before.\nAn approach to achieve that is using an in-memory database. As the name suggests, all the data will be saved in memory and not on disk, so they can be easily deleted when closing the database connection. Another approach could be using Docker to spin up every time a dedicated container for the database, to have a database that is like the one used in production. In my case, I preferred to use an in-memory solution but if you are interested in the topic, I suggest looking at this article by Philip Hauer: Don’t use In-Memory Databases (H2, Fongo) for Tests\nIn this article, I will cover how to setup an in-memory database with H2 for testing on a Ktor project that uses a MySQL database in production.\nThis post is part of a series of posts dedicated to Ktor where I cover all the topics that made me struggle during development and that was not easy to achieve out of the box. You can check out the other instances of the series in the index above or follow me on Twitter to keep up to date.\nSetup The ORM that I’ve decided to use is Exposed from Jetbrains. It is very nice to deal with and it offers the possibility to use a typesafe DSL that wraps SQL and a lightweight data access object. Exposed supports different databases like MySQL, H2, PostgreSQL, SQLite. For a complete list, refer to the documentation.\nExposed comes with a different set of artifacts that you can decide to use. For this project I’ve added the following:\nimplementation(\"org.jetbrains.exposed:exposed-core:$exposed_version\") implementation(\"org.jetbrains.exposed:exposed-dao:$exposed_version\") implementation(\"org.jetbrains.exposed:exposed-jdbc:$exposed_version\") The connection to the MySQL database is performed with the JDBC driver and with a connection pool provided by Hikari.\nimplementation(\"com.zaxxer:HikariCP:$hikaricp_version\") implementation(\"mysql:mysql-connector-java:$mysql_connector_version\") The last required dependency is H2 that is needed only for tests.\ntestImplementation(\"com.h2database:h2:$h2_version\") Database Connection: The connection and the disposal of the database is performed through a method defined in the DatabaseFactory interface\ninterface DatabaseFactory { fun connect() fun close() } This interface will then have a different implementation, depending on if the server is running in production or for unit or integration testing.\nThe factory implementation used in production creates a private HikariDataSource that will be used by the connect method\nclass DatabaseFactoryImpl(appConfig: AppConfig) : DatabaseFactory { private val dbConfig = appConfig.databaseConfig override fun connect() { Database.connect(hikari()) } private fun hikari(): HikariDataSource { val config = HikariConfig() config.driverClassName = dbConfig.driverClass config.jdbcUrl = dbConfig.url config.username = dbConfig.user config.password = dbConfig.password config.maximumPoolSize = dbConfig.maxPoolSize config.isAutoCommit = false config.transactionIsolation = \"TRANSACTION_REPEATABLE_READ\" // More configuration suggestions from https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration  config.validate() return HikariDataSource(config) } override fun close() { // used only on Unit tests \t} } The connect method will be called inside the Ktor module function during the initialization and the setup of the server.\nfun Application.module(testing: Boolean = false, koinModules: List = listOf(appModule)) { ... val databaseFactory by inject() databaseFactory.connect() ... } As you may have noticed, the DatabaseFactoryImpl class uses some fields provided by AppConfig. These fields are the driver class used for the connection, the name, user, and password of the database, and other fields that are specific to the connection. These fields are placed inside the application.conf file to be able to change them on different instances of the server.\nktor { ... database { driverClass = \"com.mysql.cj.jdbc.Driver\" url = \"jdbc:mysql://localhost:3308/chucknorris?useUnicode=true\u0026characterEncoding=UTF-8\" user = \"root\" password = \"password\" maxPoolSize = 3 } } After adding the database block, it is necessary to update accordingly the AppConfig class.\ndata class DatabaseConfig( val driverClass: String, val url: String, val user: String, val password: String, val maxPoolSize: Int ) class AppConfig { lateinit var databaseConfig: DatabaseConfig lateinit var serverConfig: ServerConfig // Place here other configurations } fun Application.setupConfig() { ... // Database \tval databaseObject = environment.config.config(\"ktor.database\") val driverClass = databaseObject.property(\"driverClass\").getString() val url = databaseObject.property(\"url\").getString() val user = databaseObject.property(\"user\").getString() val password = databaseObject.property(\"password\").getString() val maxPoolSize = databaseObject.property(\"maxPoolSize\").getString().toInt() appConfig.databaseConfig = DatabaseConfig(driverClass, url, user, password, maxPoolSize) } For more informations about the configuration process, you can give a look at the first episode of the series: Structuring a Ktor project\nTesting For testing, it is necessary to cover two different situations: unit tests and integration tests (in this case I refer to integration tests that involve the server).\nSetup Integration testing that involves the server is performed with a TestEngine that does not create a web server but hooks directly into the internal mechanism. For more information about testing on Ktor, you can look at the first episode of the series: Structuring a Ktor project. When this type of test is run, the same Ktor module function that initializes the server on production is called. In this way, the connection of the database is automatically performed.\nWhen running unit tests instead, the server is not involved, so the connection to the database must be performed manually.\nThese two behaviors can be achieved with two implementations of the DatabaseFactory: DatabaseFactoryForServerTest and DatabaseFactoryForUnitTest.\nThe former receives the configuration data from the AppConfig class since the Ktor module function will be called.\nclass DatabaseFactoryForServerTest(appConfig: AppConfig): DatabaseFactory { ... private fun hikari(): HikariDataSource { val config = HikariConfig() config.driverClassName = dbConfig.driverClass config.jdbcUrl = dbConfig.url config.maximumPoolSize = dbConfig.maxPoolSize config.isAutoCommit = true config.validate() return HikariDataSource(config) } ... } The latter instead has the configuration data hardcoded since the connection to the database must be performed manually.\nclass DatabaseFactoryForUnitTest: DatabaseFactory { ... private fun hikari(): HikariDataSource { val config = HikariConfig() config.driverClassName = \"org.h2.Driver\" config.jdbcUrl = \"jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL\" config.maximumPoolSize = 2 config.isAutoCommit = true config.validate() source = HikariDataSource(config) return source } ... } Since the database used is H2, the driver and the URL change a bit. The driver class name is now: org.h2.Driver and the URL is: jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL. The URL specifies also some features:\n mem - it tells to use the in-memory version of H2 : - it does not specify a name for the database DATABASE_TO_UPPER=false - it disable the default feature of using uppercase for identifiers. For example, if it is not disabled, the table names are uppercase and queries will fail MODE=MYSQL - it uses the MySQL compatibility mode in order to have the same features of MySQL.  To learn more about H2 database settings and features, I suggest you to look at the documentation for settings and features.\nAfter the connection to the database, it is necessary to create its structure, since the database will be destroyed after each test (or after a set of tests).\nTo do that, it is possible to use the features of Exposed. After defining a table with the Exposed DSL (for more info about it, give a look at the Exposed documentation):\nobject JokeTable: IdTable(name = \"joke\") { val createdAt = datetime(\"created_at\") val updatedAt = datetime(\"updated_at\") val value = text(\"value\") override val id: Column = varchar(\"joke_id\", 255).entityId() override val primaryKey: PrimaryKey = PrimaryKey(id) } it is possible to create the table:\nSchemaUtils.create(JokeTable) Since this operation must be repeated for every table, it is better to create a function that can be called inside the DatabaseFactory.\nobject SchemaDefinition { fun createSchema() { transaction { SchemaUtils.create(JokeTable) } } } The connect function in both the database factories will look like that:\noverride fun connect() { Database.connect(hikari()) SchemaDefinition.createSchema() } However, during unit tests, it is necessary to manually close the connection to the database, to be sure that all the data are cleared between each test run. To be able to do that, it is necessary to store in the Factory an instance of HikariDataSource that can be closed with the close method.\nclass DatabaseFactoryForUnitTest: DatabaseFactory { lateinit var source: HikariDataSource ... private fun hikari(): HikariDataSource { val config = HikariConfig() ... source = HikariDataSource(config) return source } override fun close() { source.close() } } As reference, here are the entire DatabaseFactoryForServerTest and DatabaseFactoryForUnitTest class.\nclass DatabaseFactoryForServerTest(appConfig: AppConfig): DatabaseFactory { private val dbConfig = appConfig.databaseConfig override fun connect() { Database.connect(hikari()) SchemaDefinition.createSchema() } private fun hikari(): HikariDataSource { val config = HikariConfig() config.driverClassName = dbConfig.driverClass config.jdbcUrl = dbConfig.url config.maximumPoolSize = dbConfig.maxPoolSize config.isAutoCommit = true config.validate() return HikariDataSource(config) } override fun close() { // used only for Unit tests \t} } class DatabaseFactoryForUnitTest: DatabaseFactory { lateinit var source: HikariDataSource override fun connect() { Database.connect(hikari()) SchemaDefinition.createSchema() } private fun hikari(): HikariDataSource { val config = HikariConfig() config.driverClassName = \"org.h2.Driver\" config.jdbcUrl = \"jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL\" config.maximumPoolSize = 2 config.isAutoCommit = true config.validate() source = HikariDataSource(config) return source } override fun close() { source.close() } } Execution As mentioned early, during integration tests that involve the server, the database connection is performed automatically since the Ktor module function will be called. The only thing to do is to replace in the Koin test module the DatabaseFactory implementation from DatabaseFactoryImpl, which is used in production, to DatabaseFactoryForServerTest.\nval appTestModule = module { ... singleBy() ... } As you can see in the following example of test, it is not required any initialization or setup in the test class.\nclass JokeResourceTest : AutoCloseKoinTest() { @Test fun `random joke api works correctly`() = withTestServer() { // Setup \tval joke = transaction { Joke.new(\"joke_1\") { this.value = \"Chuck Norris tests are always green\" this.createdAt = LocalDateTime.now() this.updatedAt = LocalDateTime.now() } } val href = application.locations.href( JokeEndpoint.Random( parent = JokeEndpoint() ) ) handleRequest(HttpMethod.Get, href).apply { assertEquals(HttpStatusCode.OK, response.status()) val response = Json.decodeFromString(response.content!!) assertEquals(transaction { joke.id.value }, response.jokeId) assertEquals(transaction { joke.value }, response.jokeContent) } } } On unit tests instead, the connection and the disconnection from the database must be performed manually before and after the test, or whenever it is necessary.\nclass JokeRepositoryImplTest : KoinTest { private lateinit var databaseFactory: DatabaseFactoryForUnitTest private val jokeRepository: JokeRepository by inject() @Before fun setup() { databaseFactory = DatabaseFactoryForUnitTest() databaseFactory.connect() } @After fun tearDown() { databaseFactory.close() } @Test fun `getRandomJoke returns data correctly`() = runBlockingTest { ... } } Conclusions And that’s it for today. You can find the code mentioned in the article on GitHub.\nIn the next episode, I’ll cover database migrations. You can follow me on Twitter to know when I’ll publish the next episodes.\n","wordCount":"1816","inLanguage":"en","datePublished":"2021-10-04T00:00:00Z","dateModified":"2021-10-04T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How to use an in-memory database for testing on Ktor</h1><div class=post-meta style=margin-top:16px><span title="2021-10-04 00:00:00 +0000 UTC">4 October 2021</span>&nbsp;·&nbsp;9 min</div></header><div class=post-content><div id=banner style=overflow:hidden;justify-content:space-around><div style=display:inline-block;margin-right:10px><a href=https://androidweekly.net/issues/issue-487><img style=margin:0 src=https://androidweekly.net/issues/issue-487/badge></a></div><div style=display:inline-block><a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=2b57b99606"><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23271-%237874b4></a></div></div><blockquote><p><strong>SERIES: Building a backend with Ktor</strong></p><ul><li>Part 1: <a href=https://www.marcogomiero.com/posts/2021/ktor-project-structure/>Structuring a Ktor project</a></li><li>Part 2: <a href=https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/>How to persist Ktor logs</a></li><li>Part 3: How to use an in-memory database for testing on Ktor</li><li>Part 4: <a href=https://www.marcogomiero.com/posts/2022/ktor-migration-liquibase/>How to handle database migrations with Liquibase on Ktor</a></li><li>Part 5 <a href=https://www.marcogomiero.com/posts/2022/ktor-setup-documentation/>Generate API documentation from Swagger on Ktor</a></li><li>Part 6: <a href=https://www.marcogomiero.com/posts/2022/ktor-jobs-quartz/>How to schedule jobs with Quartz on Ktor</a></li></ul></blockquote><p>Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine.</p><p>However, for automated testing, none of these databases will be suitable to use. Since the purpose of testing is checking that every part of the software is working as expected, it will be necessary to test also situations where there isn’t any data saved in the database. To achieve that, the database must be cleared after every test (or group of tests) or pre-populated before.</p><p>An approach to achieve that is using an in-memory database. As the name suggests, all the data will be saved in memory and not on disk, so they can be easily deleted when closing the database connection. Another approach could be using Docker to spin up every time a dedicated container for the database, to have a database that is like the one used in production. In my case, I preferred to use an in-memory solution but if you are interested in the topic, I suggest looking at this article by Philip Hauer: <a href=https://phauer.com/2017/dont-use-in-memory-databases-tests-h2/>Don&rsquo;t use In-Memory Databases (H2, Fongo) for Tests</a></p><p>In this article, I will cover how to setup an in-memory database with <a href=https://www.h2database.com/html/main.html>H2</a> for testing on a Ktor project that uses a MySQL database in production.</p><p>This post is part of a series of posts dedicated to Ktor where I cover all the topics that made me struggle during development and that was not easy to achieve out of the box. You can check out the other instances of the series in the index above or <a href=https://twitter.com/marcoGomier>follow me on Twitter</a> to keep up to date.</p><h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2><p>The ORM that I’ve decided to use is <a href=https://github.com/JetBrains/Exposed>Exposed</a> from Jetbrains. It is very nice to deal with and it offers the possibility to use a typesafe DSL that wraps SQL and a lightweight data access object.
Exposed supports different databases like MySQL, H2, PostgreSQL, SQLite. For a complete list, refer <a href=https://github.com/JetBrains/Exposed#supported-databases>to the documentation</a>.</p><p>Exposed comes with a <a href=https://github.com/JetBrains/Exposed/wiki/Getting-Started>different set of artifacts</a> that you can decide to use. For this project I’ve added the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>implementation(<span style=color:#e6db74>&#34;org.jetbrains.exposed:exposed-core:</span><span style=color:#e6db74>$exposed_version</span><span style=color:#e6db74>&#34;</span>)
implementation(<span style=color:#e6db74>&#34;org.jetbrains.exposed:exposed-dao:</span><span style=color:#e6db74>$exposed_version</span><span style=color:#e6db74>&#34;</span>)
implementation(<span style=color:#e6db74>&#34;org.jetbrains.exposed:exposed-jdbc:</span><span style=color:#e6db74>$exposed_version</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>The connection to the MySQL database is performed with the JDBC driver and with a connection pool provided by <a href=https://github.com/brettwooldridge/HikariCP>Hikari</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>implementation(<span style=color:#e6db74>&#34;com.zaxxer:HikariCP:</span><span style=color:#e6db74>$hikaricp_version</span><span style=color:#e6db74>&#34;</span>)
implementation(<span style=color:#e6db74>&#34;mysql:mysql-connector-java:</span><span style=color:#e6db74>$mysql_connector_version</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>The last required dependency is <a href=https://github.com/h2database/h2database>H2</a> that is needed only for tests.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>testImplementation(<span style=color:#e6db74>&#34;com.h2database:h2:</span><span style=color:#e6db74>$h2_version</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><h2 id=database-connection>Database Connection:<a hidden class=anchor aria-hidden=true href=#database-connection>#</a></h2><p>The connection and the disposal of the database is performed through a method defined in the <code>DatabaseFactory</code> interface</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>DatabaseFactory</span> {
	<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>connect</span>()
	<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>close</span>()
}
</code></pre></div><p>This interface will then have a different implementation, depending on if the server is running in production or for unit or integration testing.</p><p>The factory implementation used in production creates a private <em>HikariDataSource</em> that will be used by the <code>connect</code> method</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseFactoryImpl</span>(appConfig: AppConfig) : DatabaseFactory {

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> dbConfig = appConfig.databaseConfig

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>connect</span>() {
		Database.connect(hikari())
	}

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>hikari</span>(): HikariDataSource {
        <span style=color:#66d9ef>val</span> config = HikariConfig()
        config.driverClassName = dbConfig.driverClass
        config.jdbcUrl = dbConfig.url
        config.username = dbConfig.user
        config.password = dbConfig.password
        config.maximumPoolSize = dbConfig.maxPoolSize
        config.isAutoCommit = <span style=color:#66d9ef>false</span>
        config.transactionIsolation = <span style=color:#e6db74>&#34;TRANSACTION_REPEATABLE_READ&#34;</span>

        <span style=color:#75715e>// More configuration suggestions from https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration
</span><span style=color:#75715e></span>
        config.validate()
        <span style=color:#66d9ef>return</span> HikariDataSource(config)
	}

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>close</span>() {
        <span style=color:#75715e>// used only on Unit tests
</span><span style=color:#75715e></span>	}
}
</code></pre></div><p>The <code>connect</code> method will be called inside the Ktor module function during the initialization and the setup of the server.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Application</span>.module(testing: Boolean = <span style=color:#66d9ef>false</span>, koinModules: List&lt;Module&gt; = listOf(appModule)) {
	<span style=color:#f92672>..</span>.
	<span style=color:#66d9ef>val</span> databaseFactory <span style=color:#66d9ef>by</span> inject&lt;DatabaseFactory&gt;() databaseFactory.connect()
	<span style=color:#f92672>..</span>.
}
</code></pre></div><p>As you may have noticed, the <code>DatabaseFactoryImpl</code> class uses some fields provided by <code>AppConfig</code>. These fields are the driver class used for the connection, the name, user, and password of the database, and other fields that are specific to the connection. These fields are placed inside the <code>application.conf</code> file to be able to change them on different instances of the server.</p><pre><code class=language-hocon data-lang=hocon>ktor {

  ...

  database {
    driverClass = &quot;com.mysql.cj.jdbc.Driver&quot;
    url = &quot;jdbc:mysql://localhost:3308/chucknorris?useUnicode=true&amp;characterEncoding=UTF-8&quot;
    user = &quot;root&quot;
    password = &quot;password&quot;
    maxPoolSize = 3
  }
}
</code></pre><p>After adding the <code>database</code> block, it is necessary to update accordingly the <code>AppConfig</code> class.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseConfig</span>(
	<span style=color:#66d9ef>val</span> driverClass: String,
	<span style=color:#66d9ef>val</span> url: String,
	<span style=color:#66d9ef>val</span> user: String,
	<span style=color:#66d9ef>val</span> password: String,
	<span style=color:#66d9ef>val</span> maxPoolSize: Int
)

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppConfig</span> {
	<span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> databaseConfig: DatabaseConfig
	<span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> serverConfig: ServerConfig
	<span style=color:#75715e>// Place here other configurations
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Application</span>.setupConfig() {

	<span style=color:#f92672>..</span>.

	<span style=color:#75715e>// Database
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>val</span> databaseObject = environment.config.config(<span style=color:#e6db74>&#34;ktor.database&#34;</span>)
	<span style=color:#66d9ef>val</span> driverClass = databaseObject.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;driverClass&#34;</span>).getString()
	<span style=color:#66d9ef>val</span> url = databaseObject.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;url&#34;</span>).getString()
	<span style=color:#66d9ef>val</span> user = databaseObject.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;user&#34;</span>).getString()
	<span style=color:#66d9ef>val</span> password = databaseObject.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;password&#34;</span>).getString()
	<span style=color:#66d9ef>val</span> maxPoolSize = databaseObject.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;maxPoolSize&#34;</span>).getString().toInt()
	appConfig.databaseConfig = DatabaseConfig(driverClass, url, user, password, maxPoolSize)
}
</code></pre></div><p>For more informations about the configuration process, you can give a look at the first episode of the series: <a href=https://www.marcogomiero.com/posts/2021/ktor-project-structure#configuration>Structuring a Ktor project</a></p><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>For testing, it is necessary to cover two different situations: unit tests and integration tests (in this case I refer to integration tests that involve the server).</p><h3 id=setup-1>Setup<a hidden class=anchor aria-hidden=true href=#setup-1>#</a></h3><p><strong>Integration testing</strong> that involves the server is performed with a <code>TestEngine</code> that does not create a web server but hooks directly into the internal mechanism. For more information about testing on Ktor, you can look at the first episode of the series: <a href=https://www.marcogomiero.com/posts/2021/ktor-project-structure#testing>Structuring a Ktor project</a>. When this type of test is run, the same Ktor module function that initializes the server on production is called. In this way, the connection of the database is automatically performed.</p><p>When running <strong>unit tests</strong> instead, the server is not involved, so the connection to the database must be performed manually.</p><p>These two behaviors can be achieved with two implementations of the <code>DatabaseFactory</code>: <code>DatabaseFactoryForServerTest</code> and <code>DatabaseFactoryForUnitTest</code>.</p><p>The former receives the configuration data from the <code>AppConfig</code> class since the Ktor module function will be called.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseFactoryForServerTest</span>(appConfig: AppConfig): DatabaseFactory {

	<span style=color:#f92672>..</span>.

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>hikari</span>(): HikariDataSource {
        <span style=color:#66d9ef>val</span> config = HikariConfig()
        config.driverClassName = dbConfig.driverClass
        config.jdbcUrl = dbConfig.url
        config.maximumPoolSize = dbConfig.maxPoolSize
        config.isAutoCommit = <span style=color:#66d9ef>true</span>
        config.validate()
        <span style=color:#66d9ef>return</span> HikariDataSource(config)
	}

	<span style=color:#f92672>..</span>.
}
</code></pre></div><p>The latter instead has the configuration data hardcoded since the connection to the database must be performed manually.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseFactoryForUnitTest</span>: DatabaseFactory {

	<span style=color:#f92672>..</span>.

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>hikari</span>(): HikariDataSource {
        <span style=color:#66d9ef>val</span> config = HikariConfig()
        config.driverClassName = <span style=color:#e6db74>&#34;org.h2.Driver&#34;</span>
        config.jdbcUrl = <span style=color:#e6db74>&#34;jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL&#34;</span>
        config.maximumPoolSize = <span style=color:#ae81ff>2</span>
        config.isAutoCommit = <span style=color:#66d9ef>true</span>
        config.validate()
        source = HikariDataSource(config)
        <span style=color:#66d9ef>return</span> source
	}

    <span style=color:#f92672>..</span>.
}
</code></pre></div><p>Since the database used is <strong>H2</strong>, the driver and the URL change a bit.
The driver class name is now: <code>org.h2.Driver</code> and the URL is: <code>jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL</code>. The URL specifies also some features:</p><ul><li><code>mem</code> -> it tells to use the in-memory version of H2</li><li><code>:</code> -> it does not specify a name for the database</li><li><code>DATABASE_TO_UPPER=false</code> -> it disable the default feature of using uppercase for identifiers. For example, if it is not disabled, the table names are uppercase and queries will fail</li><li><code>MODE=MYSQL</code> -> it uses the MySQL compatibility mode in order to have the same features of MySQL.</li></ul><p>To learn more about H2 database settings and features, I suggest you to look at the documentation for <a href=https://www.h2database.com/javadoc/org/h2/engine/DbSettings.html>settings</a> and <a href=http://www.h2database.com/html/features.html>features</a>.</p><p>After the connection to the database, it is necessary to create its structure, since the database will be destroyed after each test (or after a set of tests).</p><p>To do that, it is possible to use the features of Exposed.
After defining a table with the Exposed DSL (for more info about it, give a look at the <a href=https://github.com/JetBrains/Exposed/wiki/DSL>Exposed documentation</a>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>JokeTable</span>: IdTable&lt;String&gt;(name = <span style=color:#e6db74>&#34;joke&#34;</span>) {
	<span style=color:#66d9ef>val</span> createdAt = datetime(<span style=color:#e6db74>&#34;created_at&#34;</span>)
	<span style=color:#66d9ef>val</span> updatedAt = datetime(<span style=color:#e6db74>&#34;updated_at&#34;</span>)
	<span style=color:#66d9ef>val</span> value = text(<span style=color:#e6db74>&#34;value&#34;</span>)

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>val</span> id: Column&lt;EntityID&lt;String&gt;&gt; = varchar(<span style=color:#e6db74>&#34;joke_id&#34;</span>, <span style=color:#ae81ff>255</span>).entityId()
	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>val</span> primaryKey: PrimaryKey = PrimaryKey(id)
}
</code></pre></div><p>it is possible to create the table:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>SchemaUtils.create(JokeTable)
</code></pre></div><p>Since this operation must be repeated for every table, it is better to create a function that can be called inside the DatabaseFactory.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>SchemaDefinition</span> {
	<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>createSchema</span>() {
        transaction {
            SchemaUtils.create(JokeTable)
        }
	}
}
</code></pre></div><p>The <code>connect</code> function in both the database factories will look like that:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>connect</span>() {
	Database.connect(hikari())
	SchemaDefinition.createSchema()
}
</code></pre></div><p>However, during unit tests, it is necessary to manually close the connection to the database, to be sure that all the data are cleared between each test run. To be able to do that, it is necessary to store in the Factory an instance of <code>HikariDataSource</code> that can be closed with the <code>close</code> method.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseFactoryForUnitTest</span>: DatabaseFactory {

	<span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> source: HikariDataSource

	<span style=color:#f92672>..</span>.

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>hikari</span>(): HikariDataSource {
        <span style=color:#66d9ef>val</span> config = HikariConfig()
        <span style=color:#f92672>..</span>.
        source = HikariDataSource(config)
        <span style=color:#66d9ef>return</span> source
	}

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>close</span>() {
        source.close()
	}
}
</code></pre></div><p>As reference, here are the entire <code>DatabaseFactoryForServerTest</code> and <code>DatabaseFactoryForUnitTest</code> class.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseFactoryForServerTest</span>(appConfig: AppConfig): DatabaseFactory {

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> dbConfig = appConfig.databaseConfig

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>connect</span>() {
		Database.connect(hikari())
		SchemaDefinition.createSchema()
	}

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>hikari</span>(): HikariDataSource {
        <span style=color:#66d9ef>val</span> config = HikariConfig()
        config.driverClassName = dbConfig.driverClass
        config.jdbcUrl = dbConfig.url
        config.maximumPoolSize = dbConfig.maxPoolSize
        config.isAutoCommit = <span style=color:#66d9ef>true</span>
        config.validate()
        <span style=color:#66d9ef>return</span> HikariDataSource(config)
	}

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>close</span>() {
        <span style=color:#75715e>// used only for Unit tests
</span><span style=color:#75715e></span>	}
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseFactoryForUnitTest</span>: DatabaseFactory {

	<span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> source: HikariDataSource

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>connect</span>() {
        Database.connect(hikari())
        SchemaDefinition.createSchema()
	}

	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>hikari</span>(): HikariDataSource {
        <span style=color:#66d9ef>val</span> config = HikariConfig()
        config.driverClassName = <span style=color:#e6db74>&#34;org.h2.Driver&#34;</span>
        config.jdbcUrl = <span style=color:#e6db74>&#34;jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL&#34;</span>
        config.maximumPoolSize = <span style=color:#ae81ff>2</span>
        config.isAutoCommit = <span style=color:#66d9ef>true</span>
        config.validate()
        source = HikariDataSource(config)
        <span style=color:#66d9ef>return</span> source
	}

	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>close</span>() {
		source.close()
	}
}
</code></pre></div><h3 id=execution>Execution<a hidden class=anchor aria-hidden=true href=#execution>#</a></h3><p>As mentioned early, during <strong>integration tests</strong> that involve the server, the database connection is performed automatically since the Ktor module function will be called. The only thing to do is to replace in the Koin test module the <code>DatabaseFactory</code> implementation from <code>DatabaseFactoryImpl</code>, which is used in production, to <code>DatabaseFactoryForServerTest</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> appTestModule = module {
	<span style=color:#f92672>..</span>.
	singleBy&lt;DatabaseFactory, DatabaseFactoryForServerTest&gt;()
	<span style=color:#f92672>..</span>.
}
</code></pre></div><p>As you can see in the following example of test, it is not required any initialization or setup in the test class.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JokeResourceTest</span> : AutoCloseKoinTest() {

	<span style=color:#a6e22e>@Test</span>
	<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>`random joke api works correctly`</span>() = withTestServer() {

		<span style=color:#75715e>// Setup
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>val</span> joke = transaction {
			Joke.new(<span style=color:#e6db74>&#34;joke_1&#34;</span>) {
                <span style=color:#66d9ef>this</span>.value = <span style=color:#e6db74>&#34;Chuck Norris tests are always green&#34;</span>
                <span style=color:#66d9ef>this</span>.createdAt = LocalDateTime.now()
                <span style=color:#66d9ef>this</span>.updatedAt = LocalDateTime.now()
	        }
		}

		<span style=color:#66d9ef>val</span> href = application.locations.href(
            JokeEndpoint.Random(
                parent = JokeEndpoint()
            )
		)

		handleRequest(HttpMethod.Get, href).apply {
            assertEquals(HttpStatusCode.OK, response.status())

            <span style=color:#66d9ef>val</span> response = Json.decodeFromString&lt;JokeDTO&gt;(response.content<span style=color:#f92672>!!</span>)

            assertEquals(transaction { joke.id.value }, response.jokeId)
            assertEquals(transaction { joke.value }, response.jokeContent)
		}
	}
}
</code></pre></div><p>On <strong>unit tests</strong> instead, the connection and the disconnection from the database must be performed manually before and after the test, or whenever it is necessary.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JokeRepositoryImplTest</span> : KoinTest {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> databaseFactory: DatabaseFactoryForUnitTest

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> jokeRepository: JokeRepository <span style=color:#66d9ef>by</span> inject()

    <span style=color:#a6e22e>@Before</span>
    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>setup</span>() {
        databaseFactory = DatabaseFactoryForUnitTest()
        databaseFactory.connect()
    }

    <span style=color:#a6e22e>@After</span>
    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>tearDown</span>() {
        databaseFactory.close()
    }

    <span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>`getRandomJoke returns data correctly`</span>() = runBlockingTest {
        <span style=color:#f92672>..</span>.
    }
}
</code></pre></div><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>And that’s it for today. You can find the code mentioned in the article on <a href=https://github.com/prof18/ktor-chuck-norris-sample/tree/part3>GitHub</a>.</p><p>In the next episode, I’ll cover database migrations. You can follow me on <a href=https://twitter.com/marcoGomier>Twitter</a> to know when I’ll publish the next episodes.</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.marcogomiero.com/posts/2021/kmp-no-java-runtime-error-xcode/><span class=title>« Prev</span><br><span>How to fix the "Unable to locate a Java Runtime" error on Xcode with Kotlin Multiplatform</span></a>
<a class=next href=https://www.marcogomiero.com/posts/2021/kmp-xcframework-official-support/><span class=title>Next »</span><br><span>Building an XCFramework on Kotlin Multiplatform from Kotlin 1.5.30</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>