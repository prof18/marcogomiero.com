<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>How to use an in-memory database for testing on Ktor - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="SERIES: Building a backend with Ktor
Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor Part 7: Moving from mobile to backend development with Ktor Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine."><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:title" content="How to use an in-memory database for testing on Ktor"><meta property="og:description" content="SERIES: Building a backend with Ktor
Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor Part 7: Moving from mobile to backend development with Ktor Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-04T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-04T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to use an in-memory database for testing on Ktor"><meta name=twitter:description content="SERIES: Building a backend with Ktor
Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor Part 7: Moving from mobile to backend development with Ktor Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine."><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><script src=https://www.marcogomiero.com/js/feather.min.js></script>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.26c5bf79ef760a8f4feb8fc7be32ec86fc1f1da292b42c9fcc37879d4f774e3f.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write</span></a>
<a href=/talks/><span>Speak</span></a>
<a href=/projects/><span>Build</span></a>
<a href=/about-me/><span>About</span></a>
| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>How to use an in-memory database for testing on Ktor</h1><div class=post-meta><span title='2021-10-04 00:00:00 +0000 UTC'>4 October 2021</span></div></div><section class=body><span class=raw-html><div class=post-award-container><a href=https://androidweekly.net/issues/issue-487><img src=https://androidweekly.net/issues/issue-487/badge></a>
<a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=2b57b99606"><img src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23271-%237874b4></a></div></span><blockquote><p><strong>SERIES: Building a backend with Ktor</strong></p><ul><li>Part 1: <a href=https://www.marcogomiero.com/posts/2021/ktor-project-structure/>Structuring a Ktor project</a></li><li>Part 2: <a href=https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/>How to persist Ktor logs</a></li><li>Part 3: How to use an in-memory database for testing on Ktor</li><li>Part 4: <a href=https://www.marcogomiero.com/posts/2022/ktor-migration-liquibase/>How to handle database migrations with Liquibase on Ktor</a></li><li>Part 5 <a href=https://www.marcogomiero.com/posts/2022/ktor-setup-documentation/>Generate API documentation from Swagger on Ktor</a></li><li>Part 6: <a href=https://www.marcogomiero.com/posts/2022/ktor-jobs-quartz/>How to schedule jobs with Quartz on Ktor</a></li><li>Part 7: <a href=https://www.marcogomiero.com/posts/2022/backend-from-mobile-ktor/>Moving from mobile to backend development with Ktor</a></li></ul></blockquote><p>Usually, in a backend project, there are different instances of the same database: one for production (or more than one, it depends on the architecture), one for staging, and a local one that runs in the development machine.</p><p>However, for automated testing, none of these databases will be suitable to use. Since the purpose of testing is checking that every part of the software is working as expected, it will be necessary to test also situations where there isn’t any data saved in the database. To achieve that, the database must be cleared after every test (or group of tests) or pre-populated before.</p><p>An approach to achieve that is using an in-memory database. As the name suggests, all the data will be saved in memory and not on disk, so they can be easily deleted when closing the database connection. Another approach could be using Docker to spin up every time a dedicated container for the database, to have a database that is like the one used in production. In my case, I preferred to use an in-memory solution but if you are interested in the topic, I suggest looking at this article by Philip Hauer: <a href=https://phauer.com/2017/dont-use-in-memory-databases-tests-h2/>Don&rsquo;t use In-Memory Databases (H2, Fongo) for Tests</a></p><p>In this article, I will cover how to setup an in-memory database with <a href=https://www.h2database.com/html/main.html>H2</a> for testing on a Ktor project that uses a MySQL database in production.</p><p>This post is part of a series of posts dedicated to Ktor where I cover all the topics that made me struggle during development and that was not easy to achieve out of the box. You can check out the other instances of the series in the index above or <a href=https://twitter.com/marcoGomier>follow me on Twitter</a> to keep up to date.</p><h2 id=setup>Setup</h2><p>The ORM that I’ve decided to use is <a href=https://github.com/JetBrains/Exposed>Exposed</a> from Jetbrains. It is very nice to deal with and it offers the possibility to use a typesafe DSL that wraps SQL and a lightweight data access object.
Exposed supports different databases like MySQL, H2, PostgreSQL, SQLite. For a complete list, refer <a href=https://github.com/JetBrains/Exposed#supported-databases>to the documentation</a>.</p><p>Exposed comes with a <a href=https://github.com/JetBrains/Exposed/wiki/Getting-Started>different set of artifacts</a> that you can decide to use. For this project I’ve added the following:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;org.jetbrains.exposed:exposed-core:</span><span style=color:#5af78e>$exposed</span><span style=color:#5af78e>_version&#34;</span>)
</span></span><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;org.jetbrains.exposed:exposed-dao:</span><span style=color:#5af78e>$exposed</span><span style=color:#5af78e>_version&#34;</span>)
</span></span><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;org.jetbrains.exposed:exposed-jdbc:</span><span style=color:#5af78e>$exposed</span><span style=color:#5af78e>_version&#34;</span>)
</span></span></code></pre></div><p>The connection to the MySQL database is performed with the JDBC driver and with a connection pool provided by <a href=https://github.com/brettwooldridge/HikariCP>Hikari</a>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;com.zaxxer:HikariCP:</span><span style=color:#5af78e>$hikaricp</span><span style=color:#5af78e>_version&#34;</span>)
</span></span><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;mysql:mysql-connector-java:</span><span style=color:#5af78e>$mysql</span><span style=color:#5af78e>_connector_version&#34;</span>)
</span></span></code></pre></div><p>The last required dependency is <a href=https://github.com/h2database/h2database>H2</a> that is needed only for tests.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>testImplementation(<span style=color:#5af78e>&#34;com.h2database:h2:</span><span style=color:#5af78e>$h2</span><span style=color:#5af78e>_version&#34;</span>)
</span></span></code></pre></div><h2 id=database-connection>Database Connection:</h2><p>The connection and the disposal of the database is performed through a method defined in the <code>DatabaseFactory</code> interface</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>interface</span> <span style=color:#f3f99d>DatabaseFactory</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>connect</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>close</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This interface will then have a different implementation, depending on if the server is running in production or for unit or integration testing.</p><p>The factory implementation used in production creates a private <em>HikariDataSource</em> that will be used by the <code>connect</code> method</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseFactoryImpl</span>(appConfig: AppConfig) : DatabaseFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> dbConfig = appConfig.databaseConfig
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>connect</span>() {
</span></span><span style=display:flex><span>		Database.connect(hikari())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>hikari</span>(): HikariDataSource {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> config = HikariConfig()
</span></span><span style=display:flex><span>        config.driverClassName = dbConfig.driverClass
</span></span><span style=display:flex><span>        config.jdbcUrl = dbConfig.url
</span></span><span style=display:flex><span>        config.username = dbConfig.user
</span></span><span style=display:flex><span>        config.password = dbConfig.password
</span></span><span style=display:flex><span>        config.maximumPoolSize = dbConfig.maxPoolSize
</span></span><span style=display:flex><span>        config.isAutoCommit = <span style=color:#ff6ac1>false</span>
</span></span><span style=display:flex><span>        config.transactionIsolation = <span style=color:#5af78e>&#34;TRANSACTION_REPEATABLE_READ&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// More configuration suggestions from https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        config.validate()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> HikariDataSource(config)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>close</span>() {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// used only on Unit tests
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>connect</code> method will be called inside the Ktor module function during the initialization and the setup of the server.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>Application</span>.module(testing: Boolean = <span style=color:#ff6ac1>false</span>, koinModules: List&lt;Module&gt; = listOf(appModule)) {
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> databaseFactory <span style=color:#ff6ac1>by</span> inject&lt;DatabaseFactory&gt;() databaseFactory.connect()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you may have noticed, the <code>DatabaseFactoryImpl</code> class uses some fields provided by <code>AppConfig</code>. These fields are the driver class used for the connection, the name, user, and password of the database, and other fields that are specific to the connection. These fields are placed inside the <code>application.conf</code> file to be able to change them on different instances of the server.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ktor {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  database {
</span></span><span style=display:flex><span>    driverClass = &#34;com.mysql.cj.jdbc.Driver&#34;
</span></span><span style=display:flex><span>    url = &#34;jdbc:mysql://localhost:3308/chucknorris?useUnicode=true&amp;characterEncoding=UTF-8&#34;
</span></span><span style=display:flex><span>    user = &#34;root&#34;
</span></span><span style=display:flex><span>    password = &#34;password&#34;
</span></span><span style=display:flex><span>    maxPoolSize = 3
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After adding the <code>database</code> block, it is necessary to update accordingly the <code>AppConfig</code> class.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseConfig</span>(
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> driverClass: String,
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> url: String,
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> user: String,
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> password: String,
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> maxPoolSize: Int
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>AppConfig</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>lateinit</span> <span style=color:#ff6ac1>var</span> databaseConfig: DatabaseConfig
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>lateinit</span> <span style=color:#ff6ac1>var</span> serverConfig: ServerConfig
</span></span><span style=display:flex><span>	<span style=color:#78787e>// Place here other configurations
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>Application</span>.setupConfig() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#78787e>// Database
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>	<span style=color:#ff6ac1>val</span> databaseObject = environment.config.config(<span style=color:#5af78e>&#34;ktor.database&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> driverClass = databaseObject.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;driverClass&#34;</span>).getString()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> url = databaseObject.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;url&#34;</span>).getString()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> user = databaseObject.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;user&#34;</span>).getString()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> password = databaseObject.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;password&#34;</span>).getString()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> maxPoolSize = databaseObject.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;maxPoolSize&#34;</span>).getString().toInt()
</span></span><span style=display:flex><span>	appConfig.databaseConfig = DatabaseConfig(driverClass, url, user, password, maxPoolSize)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For more informations about the configuration process, you can give a look at the first episode of the series: <a href=https://www.marcogomiero.com/posts/2021/ktor-project-structure#configuration>Structuring a Ktor project</a></p><h2 id=testing>Testing</h2><p>For testing, it is necessary to cover two different situations: unit tests and integration tests (in this case I refer to integration tests that involve the server).</p><h3 id=setup-1>Setup</h3><p><strong>Integration testing</strong> that involves the server is performed with a <code>TestEngine</code> that does not create a web server but hooks directly into the internal mechanism. For more information about testing on Ktor, you can look at the first episode of the series: <a href=https://www.marcogomiero.com/posts/2021/ktor-project-structure#testing>Structuring a Ktor project</a>. When this type of test is run, the same Ktor module function that initializes the server on production is called. In this way, the connection of the database is automatically performed.</p><p>When running <strong>unit tests</strong> instead, the server is not involved, so the connection to the database must be performed manually.</p><p>These two behaviors can be achieved with two implementations of the <code>DatabaseFactory</code>: <code>DatabaseFactoryForServerTest</code> and <code>DatabaseFactoryForUnitTest</code>.</p><p>The former receives the configuration data from the <code>AppConfig</code> class since the Ktor module function will be called.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseFactoryForServerTest</span>(appConfig: AppConfig): DatabaseFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>hikari</span>(): HikariDataSource {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> config = HikariConfig()
</span></span><span style=display:flex><span>        config.driverClassName = dbConfig.driverClass
</span></span><span style=display:flex><span>        config.jdbcUrl = dbConfig.url
</span></span><span style=display:flex><span>        config.maximumPoolSize = dbConfig.maxPoolSize
</span></span><span style=display:flex><span>        config.isAutoCommit = <span style=color:#ff6ac1>true</span>
</span></span><span style=display:flex><span>        config.validate()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> HikariDataSource(config)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The latter instead has the configuration data hardcoded since the connection to the database must be performed manually.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseFactoryForUnitTest</span>: DatabaseFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>hikari</span>(): HikariDataSource {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> config = HikariConfig()
</span></span><span style=display:flex><span>        config.driverClassName = <span style=color:#5af78e>&#34;org.h2.Driver&#34;</span>
</span></span><span style=display:flex><span>        config.jdbcUrl = <span style=color:#5af78e>&#34;jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL&#34;</span>
</span></span><span style=display:flex><span>        config.maximumPoolSize = <span style=color:#ff9f43>2</span>
</span></span><span style=display:flex><span>        config.isAutoCommit = <span style=color:#ff6ac1>true</span>
</span></span><span style=display:flex><span>        config.validate()
</span></span><span style=display:flex><span>        source = HikariDataSource(config)
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> source
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since the database used is <strong>H2</strong>, the driver and the URL change a bit.
The driver class name is now: <code>org.h2.Driver</code> and the URL is: <code>jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL</code>. The URL specifies also some features:</p><ul><li><code>mem</code> -> it tells to use the in-memory version of H2</li><li><code>:</code> -> it does not specify a name for the database</li><li><code>DATABASE_TO_UPPER=false</code> -> it disable the default feature of using uppercase for identifiers. For example, if it is not disabled, the table names are uppercase and queries will fail</li><li><code>MODE=MYSQL</code> -> it uses the MySQL compatibility mode in order to have the same features of MySQL.</li></ul><p>To learn more about H2 database settings and features, I suggest you to look at the documentation for <a href=https://www.h2database.com/javadoc/org/h2/engine/DbSettings.html>settings</a> and <a href=http://www.h2database.com/html/features.html>features</a>.</p><p>After the connection to the database, it is necessary to create its structure, since the database will be destroyed after each test (or after a set of tests).</p><p>To do that, it is possible to use the features of Exposed.
After defining a table with the Exposed DSL (for more info about it, give a look at the <a href=https://github.com/JetBrains/Exposed/wiki/DSL>Exposed documentation</a>):</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>JokeTable</span>: IdTable&lt;String&gt;(name = <span style=color:#5af78e>&#34;joke&#34;</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> createdAt = datetime(<span style=color:#5af78e>&#34;created_at&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> updatedAt = datetime(<span style=color:#5af78e>&#34;updated_at&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>val</span> value = text(<span style=color:#5af78e>&#34;value&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>val</span> id: Column&lt;EntityID&lt;String&gt;&gt; = varchar(<span style=color:#5af78e>&#34;joke_id&#34;</span>, <span style=color:#ff9f43>255</span>).entityId()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>val</span> primaryKey: PrimaryKey = PrimaryKey(id)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>it is possible to create the table:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>SchemaUtils.create(JokeTable)
</span></span></code></pre></div><p>Since this operation must be repeated for every table, it is better to create a function that can be called inside the DatabaseFactory.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>SchemaDefinition</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createSchema</span>() {
</span></span><span style=display:flex><span>        transaction {
</span></span><span style=display:flex><span>            SchemaUtils.create(JokeTable)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>connect</code> function in both the database factories will look like that:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>connect</span>() {
</span></span><span style=display:flex><span>	Database.connect(hikari())
</span></span><span style=display:flex><span>	SchemaDefinition.createSchema()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, during unit tests, it is necessary to manually close the connection to the database, to be sure that all the data are cleared between each test run. To be able to do that, it is necessary to store in the Factory an instance of <code>HikariDataSource</code> that can be closed with the <code>close</code> method.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseFactoryForUnitTest</span>: DatabaseFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>lateinit</span> <span style=color:#ff6ac1>var</span> source: HikariDataSource
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>hikari</span>(): HikariDataSource {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> config = HikariConfig()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>        source = HikariDataSource(config)
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> source
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>close</span>() {
</span></span><span style=display:flex><span>        source.close()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As reference, here are the entire <code>DatabaseFactoryForServerTest</code> and <code>DatabaseFactoryForUnitTest</code> class.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseFactoryForServerTest</span>(appConfig: AppConfig): DatabaseFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> dbConfig = appConfig.databaseConfig
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>connect</span>() {
</span></span><span style=display:flex><span>		Database.connect(hikari())
</span></span><span style=display:flex><span>		SchemaDefinition.createSchema()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>hikari</span>(): HikariDataSource {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> config = HikariConfig()
</span></span><span style=display:flex><span>        config.driverClassName = dbConfig.driverClass
</span></span><span style=display:flex><span>        config.jdbcUrl = dbConfig.url
</span></span><span style=display:flex><span>        config.maximumPoolSize = dbConfig.maxPoolSize
</span></span><span style=display:flex><span>        config.isAutoCommit = <span style=color:#ff6ac1>true</span>
</span></span><span style=display:flex><span>        config.validate()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> HikariDataSource(config)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>close</span>() {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// used only for Unit tests
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>DatabaseFactoryForUnitTest</span>: DatabaseFactory {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>lateinit</span> <span style=color:#ff6ac1>var</span> source: HikariDataSource
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>connect</span>() {
</span></span><span style=display:flex><span>        Database.connect(hikari())
</span></span><span style=display:flex><span>        SchemaDefinition.createSchema()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>hikari</span>(): HikariDataSource {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> config = HikariConfig()
</span></span><span style=display:flex><span>        config.driverClassName = <span style=color:#5af78e>&#34;org.h2.Driver&#34;</span>
</span></span><span style=display:flex><span>        config.jdbcUrl = <span style=color:#5af78e>&#34;jdbc:h2:mem:;DATABASE_TO_UPPER=false;MODE=MYSQL&#34;</span>
</span></span><span style=display:flex><span>        config.maximumPoolSize = <span style=color:#ff9f43>2</span>
</span></span><span style=display:flex><span>        config.isAutoCommit = <span style=color:#ff6ac1>true</span>
</span></span><span style=display:flex><span>        config.validate()
</span></span><span style=display:flex><span>        source = HikariDataSource(config)
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> source
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>close</span>() {
</span></span><span style=display:flex><span>		source.close()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=execution>Execution</h3><p>As mentioned early, during <strong>integration tests</strong> that involve the server, the database connection is performed automatically since the Ktor module function will be called. The only thing to do is to replace in the Koin test module the <code>DatabaseFactory</code> implementation from <code>DatabaseFactoryImpl</code>, which is used in production, to <code>DatabaseFactoryForServerTest</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> appTestModule = module {
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>	singleBy&lt;DatabaseFactory, DatabaseFactoryForServerTest&gt;()
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see in the following example of test, it is not required any initialization or setup in the test class.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>JokeResourceTest</span> : AutoCloseKoinTest() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff9f43>@Test</span>
</span></span><span style=display:flex><span>	<span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>`random joke api works correctly`</span>() = withTestServer() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#78787e>// Setup
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>		<span style=color:#ff6ac1>val</span> joke = transaction {
</span></span><span style=display:flex><span>			Joke.new(<span style=color:#5af78e>&#34;joke_1&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>this</span>.<span style=color:#ff6ac1>value</span> = <span style=color:#5af78e>&#34;Chuck Norris tests are always green&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>this</span>.createdAt = LocalDateTime.now()
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>this</span>.updatedAt = LocalDateTime.now()
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ff6ac1>val</span> href = application.locations.href(
</span></span><span style=display:flex><span>            JokeEndpoint.Random(
</span></span><span style=display:flex><span>                parent = JokeEndpoint()
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>		)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		handleRequest(HttpMethod.Get, href).apply {
</span></span><span style=display:flex><span>            assertEquals(HttpStatusCode.OK, response.status())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> response = Json.decodeFromString&lt;JokeDTO&gt;(response.content<span style=color:#ff6ac1>!!</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            assertEquals(transaction { joke.id.<span style=color:#ff6ac1>value</span> }, response.jokeId)
</span></span><span style=display:flex><span>            assertEquals(transaction { joke.<span style=color:#ff6ac1>value</span> }, response.jokeContent)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On <strong>unit tests</strong> instead, the connection and the disconnection from the database must be performed manually before and after the test, or whenever it is necessary.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>JokeRepositoryImplTest</span> : KoinTest {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>lateinit</span> <span style=color:#ff6ac1>var</span> databaseFactory: DatabaseFactoryForUnitTest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> jokeRepository: JokeRepository <span style=color:#ff6ac1>by</span> inject()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@Before</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>setup</span>() {
</span></span><span style=display:flex><span>        databaseFactory = DatabaseFactoryForUnitTest()
</span></span><span style=display:flex><span>        databaseFactory.connect()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@After</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>tearDown</span>() {
</span></span><span style=display:flex><span>        databaseFactory.close()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>`getRandomJoke returns data correctly`</span>() = runBlockingTest {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusions>Conclusions</h2><p>And that’s it for today. You can find the code mentioned in the article on <a href=https://github.com/prof18/ktor-chuck-norris-sample/tree/main/part3>GitHub</a>.</p><p>In the next episode, I’ll cover database migrations. You can follow me on <a href=https://twitter.com/marcoGomier>Twitter</a> to know when I’ll publish the next episodes.</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-69FZ1TLE7E","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>