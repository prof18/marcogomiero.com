<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introducing Kotlin Multiplatform in an existing project | Marco Gomiero</title><meta name=keywords content><meta name=description content="After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:"><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2021/kmp-existing-project/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-90975904-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Introducing Kotlin Multiplatform in an existing project"><meta property="og:description" content="After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2021/kmp-existing-project/"><meta property="og:image" content="https://www.marcogomiero.com/img/profile.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-25T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/profile.webp"><meta name=twitter:title content="Introducing Kotlin Multiplatform in an existing project"><meta name=twitter:description content="After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Introducing Kotlin Multiplatform in an existing project","item":"https://www.marcogomiero.com/posts/2021/kmp-existing-project/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introducing Kotlin Multiplatform in an existing project","name":"Introducing Kotlin Multiplatform in an existing project","description":"After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).\nThis is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).\nWhen starting a new blank KMP project it is easier to have a mono-repo structure like this:","keywords":[],"articleBody":"      After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).\nThis is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).\nWhen starting a new blank KMP project it is easier to have a mono-repo structure like this:\n. └── kmm-project ├── androidApp ├── iosApp └── shared However, existing projects most likely don’t have a mono-repo structure. And making a refactor to achieve this structure can be extremely difficult for time or management constraints. But KMP is built around the concept of sharing as much non-UI code as possible, and it is possible to start sharing a little piece of tech stack. Then, this “little piece of tech stack” will be served to the existing projects as a library.\nWhere to start from is subjective and it depends on the specific project, but there are some parts that better suit this topic. For example, all the boilerplate code (constants, data models, DTOs, etc), that is boring to write and is more error-prone. Or it could be a feature that centralizes the source of truth (e.g. if a field is nullable or not) because with a single source of truth there will also be a single point of failure. Or it could be some utility or analytics helper that every project has.\nAn important thing to take in mind is that all the features chosen for sharing must have the possibility to be extracted gradually. That’s because, during the evaluation process of KMP, it is better to make a final decision without using too much time. For example, it will be not a good idea to start sharing the entire network layer because you will risk ending up with useless work if KMP is not the right solution for the project. Otherwise, starting with some small features like a DTO or a data model will require less “extraction time” and it will leave enough time to work on the architecture needed to have a Kotlin Multiplatform library in an existing project.\nFor example, at Uniwhere we have decided to start with some DTOs and after validating the process, we have migrated all the others.\nPublishing Architecture The architecture of an existing project with Kotlin Multiplatform will look like this:\n  There is a repository for every platform:\n a repository for the KMP library; a repository for the Backend; a repository for the Android app; a repository for the iOS app.  As mentioned early on, the KMP code is served as a library. The compiler generates a .jar for the JVM, a .aar for Android, and a Framework for iOs. The .jar and the .aar can be published in a Maven repository. A Framework can be published in different places: for example in a CocoaPods repository, in the Swift Package Manager or with Carthage. Since I’m familiar with CocoaPods (and because we are using it at Uniwhere), I’ve decided to stick with it.\nPublishing for Android and the JVM The amount of work needed to publish a JVM and an Android library to Maven is pretty straightforward, thanks to the Maven Publish Plugin. Only a few lines of configuration on the build.gradle.kts file, are necessary (here I’m assuming that you have already configured a Maven repository since it’s not the scope of the article to explain how. Otherwise, you can use a local Maven repository on your computer that does not require any kind of configuration):\nplugins { //...  id(\"maven-publish\") } group = \"\" artifactId = \"\" // If not specified, it will use the name of the project version = \"\" // This block is only needed to publish on a online maven repo publishing { repositories { maven{ credentials { username = \"\" password = \"\" } url = url(\"https://mymavenrepo.com\") } } } After that, it is possible to build and publish the KMP library with the ./gradlew publish command (or with ./gradlew publishToMavenLocal).\nThen, it is possible to pull the library on Android:\nimplementation(\":-android:\") and on the JVM project:\nimplementation(\":-jvm:\") Publishing for iOs  On iOS things are harder.\n Pack for Xcode On newly created KMP projects, there is a Gradle task, named packForXcode, that automatically builds the framework and places it in a specific build folder.\nval packForXcode by tasks.creating(Sync::class) { group = \"build\" val mode = System.getenv(\"CONFIGURATION\") ?: \"DEBUG\" val sdkName = System.getenv(\"SDK_NAME\") ?: \"iphonesimulator\" val targetName = \"ios\" + if (sdkName.startsWith(\"iphoneos\")) \"Arm64\" else \"X64\" val framework = kotlin.targets.getByName(targetName).binaries.getFramework(mode) inputs.property(\"mode\", mode) dependsOn(framework.linkTask) val targetDir = File(buildDir, \"xcode-frameworks\") from({ framework.outputDirectory }) into(targetDir) } tasks.getByName(\"build\").dependsOn(packForXcode) This task is automatically called by Xcode when the iOS (or macOS) application is built.\n  The task uses the configuration of the iOS project to define the build mode and the target architecture.\nval mode = System.getenv(\"CONFIGURATION\") ?: \"DEBUG\" val sdkName = System.getenv(\"SDK_NAME\") ?: \"iphonesimulator\" val targetName = \"ios\" + if (sdkName.startsWith(\"iphoneos\")) \"Arm64\" else \"X64\" The build mode can be RELEASE or DEBUG while the target name depends on the architecture which we are building for. The real devices use the Arm64 architecture, while the simulator uses the host computer architecture which in most of the cases is X64 (at least until when Apple Silicon will be sufficiently spread).\nAnd this is the problem of this task!\nSince the aim is to publish a framework to be used by an existing project, it’s impossible to know a priori which architecture is necessary or the build mode.\n Update: Starting from Kotlin 1.5.20, there is a new task provided by the Kotlin Multiplatform Gradle Plugin named embedAndSignAppleFrameworkForXcode that replaces the packForXcode one. The aim of this task is the same as the old one, that is publishing a framework to be used by an existing project. So it’s impossible to know a priori which architecture is necessary or the build mode. For more info, give a look at the Jetbrains blogpost.\n CocoaPods Gradle Plugin Another way to build a framework from the KMP code is using the CocoaPods Gradle Plugin. This plugin builds the framework and places it inside a CocoaPods repository that will be added as dependency on Xcode (The plugin can be used also to add other Pod libraries on the native target).\nTo start using the plugin, some configurations are necessary:\nplugins { kotlin(\"multiplatform\") version \"1.4.10\" kotlin(\"native.cocoapods\") version \"1.4.10\" } // CocoaPods requires the podspec to have a version.  version = \"1.0\" kotlin { cocoapods { // Configure fields required by CocoaPods.  summary = \"Some description for a Kotlin/Native module\" homepage = \"Link to a Kotlin/Native module homepage\" // You can change the name of the produced framework.  // By default, it is the name of the Gradle project.  frameworkName = \"\" } } Then, during the build, the Podspec file (a file that describes the Pod library - it contains the name, version, and description, where the source should be fetched from, what files to use, the build settings to apply, etc) is generated starting from the information provided in the cocoapods block.\nThe Podspec contains also a script that is automatically added as a build script, called every time the iOS application is built, like packForXcode.\nspec.script_phases = [ { :name = 'Build shared', :execution_position = :before_compile, :shell_path = '/bin/sh', :script =  set -ev REPO_ROOT=\"$PODS_TARGET_SRCROOT\" \"$REPO_ROOT/../gradlew\" -p \"$REPO_ROOT\" :shared:syncFramework \\ -Pkotlin.native.cocoapods.target=$KOTLIN_TARGET \\ -Pkotlin.native.cocoapods.configuration=$CONFIGURATION \\ -Pkotlin.native.cocoapods.cflags=\"$OTHER_CFLAGS\" \\ -Pkotlin.native.cocoapods.paths.headers=\"$HEADER_SEARCH_PATHS\" \\ -Pkotlin.native.cocoapods.paths.frameworks=\"$FRAMEWORK_SEARCH_PATHS\" SCRIPT } ] Unfortunately, this script has the same problems as packForXcode, because the configuration and the target architecture are computed during the build phase.\n-Pkotlin.native.cocoapods.target=$KOTLIN_TARGET \\ -Pkotlin.native.cocoapods.configuration=$CONFIGURATION \\ So, also the CocoaPods Gradle Plugin can’t be used.\nFat Framework The solution is to use a Fat Framework that contains the code for every required architecture. To build it, there is a Gradle task named FatFrameworkTask that can be customized to meet the specific needs.\nThe first step is building a custom Gradle task to build a debug version of the Fat Framework.\ntasks { register(\"universalFrameworkDebug\", org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask::class) { baseName = libName from( iosArm64().binaries.getFramework(\"\", \"Debug\"), iosX64().binaries.getFramework(\"\", \"Debug\") ) destinationDir = buildDir.resolve(\"\") group = \"\" description = \"Create the debug fat framework for iOs\" dependsOn(\"linkDebugFrameworkIosArm64\") dependsOn(\"linkDebugFrameworkIosX64\") } } This custom Gradle task, named universalFrameworkDebug is necessary to provide some customizations to the FatFrameworkTask. After some cosmetic info, like the name and the group of the Framework, the required architectures and configurations must be provided. In this case, the required architectures are x64 for the simulator and arm64 for the real devices. The configuration instead is Debug.\nfrom( iosArm64().binaries.getFramework(\"\", \"Debug\"), iosX64().binaries.getFramework(\"\", \"Debug\") ) The last needed information is the destination of the framework.\ndestinationDir = buildDir.resolve(\") The destination will be a CocoaPods repository that at the end is a git repository that contains the framework, the debug symbols, and a Podspec file.\n An example of a CocoaPod repo hosted on a git repo\n  The git repository uses branches and tagging for handling debug and release versions. The debug versions of the Framework are pushed directly to the develop branch without any tagging. The release version instead is pushed on master and tagged.\nFor more information about setting up a private CocoaPod repo, I suggest you give a look at the official documentation.\nAfter pushing the changes on git, the Pod library is ready to be pulled by XCode. On the Podfile of the iOs project, is necessary to specify the Pod library with the information about the source and the version.\nFor debug releases, it is enough to specify to pull the latest version from the develop branch\npod '', :git = \"git@github.com:/.git\", :branch = 'develop' For production releases instead, it is better to specify the required version number.\npod '', :git = \"git@github.com:/.git\", :tag = '' The last step is building another Gradle task, to build a release version of the Fat Framework.\ntasks { register(\"universalFrameworkRelease\", org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask::class) { baseName = libName from( iosArm64().binaries.getFramework(\"\", \"Release\"), iosX64().binaries.getFramework(\"\", \"Release\") ) destinationDir = buildDir.resolve(\"\") group = \"\" description = \"Create the debug fat framework for iOs\" dependsOn(\"linkReleaseFrameworkIosArm64\") dependsOn(\"linkReleaseFrameworkIosX64\") } } The script is the same as the previous one, with the exception that the target is changed from Debug to Release.\nAnd, that’s it! Finally, it is possible to start using the KMP library on iOS as well.\nHowever, there is room for improvement and I wanted to minimize the effort of publishing. All the steps for publishing the framework in the CocoaPods repository can be automated with a Gradle task.\nThe publishDevFramework task will build the framework and automatically publish the changes in the develop branch of the CocoaPods repository.\ntasks { register(\"publishDevFramework\") { description = \"Publish iOs framweork to the Cocoa Repo\" project.exec { workingDir = File(\"\") commandLine(\"git\", \"checkout\", \"develop\").standardOutput } dependsOn(\"universalFrameworkDebug\") doLast { val dir = File(\"/.podspec\") val tempFile = File(\"/.podspec.new\") val reader = dir.bufferedReader() val writer = tempFile.bufferedWriter() var currentLine: String? while (reader.readLine().also { currLine - currentLine = currLine } != null) { if (currentLine?.startsWith(\"s.version\") == true) { writer.write(\"s.version = \\\"${libVersionName}\\\"\" + System.lineSeparator()) } else { writer.write(currentLine + System.lineSeparator()) } } writer.close() reader.close() val successful = tempFile.renameTo(dir) if (successful) { val dateFormatter = SimpleDateFormat(\"dd/MM/yyyy - HH:mm\", Locale.getDefault()) project.exec { workingDir = File(\"\") commandLine(\"git\", \"commit\", \"-a\", \"-m\", \"\\\"New dev release: ${libVersionName}-${dateFormatter.format(Date())}\\\"\").standardOutput } project.exec { workingDir = File(\"\") commandLine(\"git\", \"push\", \"origin\", \"develop\").standardOutput } } } } } First of all, the task changes the working branch and then builds the debug framework.\nproject.exec { workingDir = File(\"\") commandLine(\"git\", \"checkout\", \"develop\").standardOutput } dependsOn(\"universalFrameworkDebug\") Before publishing the new version, the version name inside the Podspec file must be updated.\n... s.name = \" s.version = \"\" ... And this is done automatically by the task.\nval dir = File(\"/.podspec\") ... if (currentLine?.startsWith(\"s.version\") == true) { writer.write(\"s.version = \\\"${libVersionName}\\\"\" + System.lineSeparator()) } And at the end, the new changes are committed and published into the develop branch of the repository.\nval dateFormatter = SimpleDateFormat(\"dd/MM/yyyy - HH:mm\", Locale.getDefault()) project.exec { workingDir = File(\"\") commandLine(\"git\", \"commit\", \"-a\", \"-m\", \"\\\"New dev release: ${libVersionName}-${dateFormatter.format(Date())}\\\"\").standardOutput } project.exec { workingDir = File(\"\") commandLine(\"git\", \"push\", \"origin\", \"develop\").standardOutput } To publish a release version of the Framework, there is the publishFramework task.\ntasks { register(\"publishFramework\") { description = \"Publish iOs framework to the Cocoa Repo\" project.exec { workingDir = File(\"\") commandLine(\"git\", \"checkout\", \"master\").standardOutput } dependsOn(\"universalFrameworkRelease\") doLast { val dir = File(\"/.podspec\") val tempFile = File(\"/.podspec.new\") val reader = dir.bufferedReader() val writer = tempFile.bufferedWriter() var currentLine: String? while (reader.readLine().also { currLine - currentLine = currLine } != null) { if (currentLine?.startsWith(\"s.version\") == true) { writer.write(\"s.version = \\\"${libVersionName}\\\"\" + System.lineSeparator()) } else { writer.write(currentLine + System.lineSeparator()) } } writer.close() reader.close() val successful = tempFile.renameTo(dir) if (successful) { project.exec { workingDir = File(\"\") commandLine(\"git\", \"commit\", \"-a\", \"-m\", \"\\\"New release: ${libVersionName}\\\"\").standardOutput } project.exec { workingDir = File(\"\") commandLine(\"git\", \"tag\", libVersionName).standardOutput } project.exec { workingDir = File(\"\") commandLine(\"git\", \"push\", \"origin\", \"master\", \"--tags\").standardOutput } } } } } This task is very similar to the publishDevFramework task. First of all, since it is a release, the master branch will be used.\nproject.exec { workingDir = File(\"\") commandLine(\"git\", \"checkout\", \"master\").standardOutput } dependsOn(\"universalFrameworkRelease\") Then, before publishing, the commit will be tagged to specify the version name of the release.\nproject.exec { workingDir = File(\"\") commandLine(\"git\", \"commit\", \"-a\", \"-m\", \"\\\"New release: ${libVersionName}\\\"\").standardOutput } project.exec { workingDir = File(\"\") commandLine(\"git\", \"tag\", libVersionName).standardOutput } project.exec { workingDir = File(\"$rootDir/../../hn-foundation-cocoa\") commandLine(\"git\", \"push\", \"origin\", \"master\", \"--tags\").standardOutput } And, that’s it! When the KMP library is ready to be published, three tasks can ben called:\n publish to publish JVM and Android artifacts; publishDevFramework to publish a debug version of the iOs Framework; publishFramework to publish a release version of the iOs Framework.   Update: FatFrameworks seems not to be the “current state of the art” solution to distribute multiple architectures at the same time. In fact, Apple during WWDC 2019 has introduced XCFramework, a binary that can contain multiple platform-specific variants (even for iOS and macOS at the same time). To understand how to integrate KMP into existing code, give a look at my new article.\n Conclusions As shown in this article, the process of integrating Kotlin Multiplatform in an existing project requires more work on the architecture side. That’s why is preferable to start sharing a feature that can be extracted gradually.\nThe framework to follow is:\n Start little and then go bigger.\n By starting little, it is possible to validate the process with a “contained” effort, and then, after the validation, it is possible to go bigger and start sharing more and more features. For example at Uniwhere, we started sharing the DTOs and after validating the process, we decided to share also the persistence layer with SQLDelight.\nAll the code that I showed in this article came from a sample that I’ve published on GitHub (if you are interested only in the custom Gradle task, click here). This sample is composed of an Android app, an iOs app, and a backend that share some common code via a Kotlin Multiplatform library.\n Update: I’ve grouped all the tasks mentioned in the article in a Gradle plugin! To know more about it, give a look to this post.\n Bonus: I’ve spoke about this topic in a talk in the Kotlin Dev Room at Fosdem 2021.\nHere’s the recording of the session:\n and the slides:\n ","wordCount":"2537","inLanguage":"en","datePublished":"2021-02-25T00:00:00Z","dateModified":"2021-02-25T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2021/kmp-existing-project/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Introducing Kotlin Multiplatform in an existing project</h1><div class=post-meta style=margin-top:16px><span title="2021-02-25 00:00:00 +0000 UTC">25 February 2021</span>&nbsp;·&nbsp;12 min</div></header><div class=post-content><div id=banner style=overflow:hidden;justify-content:space-around><div style=display:inline-block;margin-right:10px><a href=https://androidweekly.net/issues/issue-455><img style=margin:0 src=https://androidweekly.net/issues/issue-455/badge></a></div><div style=display:inline-block><a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=22e5320947"><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23239-%237874b4></a></div></div><p>After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).</p><p>This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).</p><p>When starting a new blank KMP project it is easier to have a mono-repo structure like this:</p><pre><code>.
└── kmm-project
    ├── androidApp
    ├── iosApp
    └── shared
</code></pre><p>However, existing projects most likely don’t have a mono-repo structure. And making a refactor to achieve this structure can be extremely difficult for time or management constraints. But KMP is built around the concept of sharing as much non-UI code as possible, and it is possible to start sharing a little piece of tech stack. Then, this “little piece of tech stack” will be served to the existing projects as a library.</p><p>Where to start from is subjective and it depends on the specific project, but there are some parts that better suit this topic. For example, all the boilerplate code (constants, data models, DTOs, etc), that is boring to write and is more error-prone. Or it could be a feature that centralizes the source of truth (e.g. if a field is nullable or not) because with a single source of truth there will also be a single point of failure. Or it could be some utility or analytics helper that every project has.</p><p>An important thing to take in mind is that all the features chosen for sharing must have the possibility to be extracted gradually. That’s because, during the evaluation process of KMP, it is better to make a final decision without using too much time. For example, it will be not a good idea to start sharing the entire network layer because you will risk ending up with useless work if KMP is not the right solution for the project. Otherwise, starting with some small features like a DTO or a data model will require less “extraction time” and it will leave enough time to work on the architecture needed to have a Kotlin Multiplatform library in an existing project.</p><p>For example, at <a href=https://www.uniwhere.com/>Uniwhere</a> we have decided to start with some DTOs and after validating the process, we have migrated all the others.</p><h2 id=publishing-architecture>Publishing Architecture<a hidden class=anchor aria-hidden=true href=#publishing-architecture>#</a></h2><p>The architecture of an existing project with Kotlin Multiplatform will look like this:</p><figure><a href=/img/kmp-existing-project/kmp-publish-arch.png><img loading=lazy src=/img/kmp-existing-projects/kmp-publish-arch.png></a></figure><p>There is a repository for every platform:</p><ul><li>a repository for the KMP library;</li><li>a repository for the Backend;</li><li>a repository for the Android app;</li><li>a repository for the iOS app.</li></ul><p>As mentioned early on, the KMP code is served as a library. The compiler generates a <em>.jar</em> for the JVM, a <em>.aar</em> for Android, and a <em>Framework</em> for iOs. The <em>.jar</em> and the <em>.aar</em> can be published in a <em>Maven</em> repository. A <em>Framework</em> can be published in different places: for example in a <em><a href=https://cocoapods.org/>CocoaPods</a></em> repository, in the <a href=https://swift.org/package-manager/>Swift Package Manager</a> or with <a href=https://github.com/Carthage/Carthage>Carthage</a>. Since I’m familiar with CocoaPods (and because we are using it at Uniwhere), I’ve decided to stick with it.</p><h3 id=publishing-for-android-and-the-jvm>Publishing for Android and the JVM<a hidden class=anchor aria-hidden=true href=#publishing-for-android-and-the-jvm>#</a></h3><p>The amount of work needed to publish a JVM and an Android library to Maven is pretty straightforward, thanks to the <a href=https://docs.gradle.org/current/userguide/publishing_maven.html>Maven Publish Plugin</a>.
Only a few lines of configuration on the <em>build.gradle.kts</em> file, are necessary (here I’m assuming that you have already configured a Maven repository since it’s not the scope of the article to explain how. Otherwise, you can use a local Maven repository on your computer that does not require any kind of configuration):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>plugins {
    <span style=color:#75715e>//...
</span><span style=color:#75715e></span>    id(<span style=color:#e6db74>&#34;maven-publish&#34;</span>)
}

group = <span style=color:#e6db74>&#34;&lt;your-group-id&gt;&#34;</span>
artifactId = <span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span> <span style=color:#75715e>// If not specified, it will use the name of the project
</span><span style=color:#75715e></span>version = <span style=color:#e6db74>&#34;&lt;version-name&gt;&#34;</span>

<span style=color:#75715e>// This block is only needed to publish on a online maven repo
</span><span style=color:#75715e></span>publishing {
    repositories {
        maven{
            credentials {
                username = <span style=color:#e6db74>&#34;&lt;username&gt;&#34;</span>
                password = <span style=color:#e6db74>&#34;&lt;pwd&gt;&#34;</span>
            }
            url = url(<span style=color:#e6db74>&#34;https://mymavenrepo.com&#34;</span>)
        }
    }
}

</code></pre></div><p>After that, it is possible to build and publish the KMP library with the <code>./gradlew publish</code> command (or with <code>./gradlew publishToMavenLocal</code>).</p><p>Then, it is possible to pull the library on Android:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>implementation(<span style=color:#e6db74>&#34;&lt;your-group-id&gt;:&lt;your-library-name&gt;-android:&lt;version-name&gt;&#34;</span>)
</code></pre></div><p>and on the JVM project:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>implementation(<span style=color:#e6db74>&#34;&lt;your-group-id&gt;:&lt;your-library-name&gt;-jvm:&lt;version-name&gt;&#34;</span>)
</code></pre></div><h3 id=publishing-for-ios>Publishing for iOs<a hidden class=anchor aria-hidden=true href=#publishing-for-ios>#</a></h3><blockquote><p>On iOS things are harder.</p></blockquote><h4 id=pack-for-xcode>Pack for Xcode<a hidden class=anchor aria-hidden=true href=#pack-for-xcode>#</a></h4><p>On newly created KMP projects, there is a Gradle task, named <strong><code>packForXcode</code></strong>, that automatically builds the framework and places it in a specific build folder.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> packForXcode <span style=color:#66d9ef>by</span> tasks.creating(Sync<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>) {
    group = <span style=color:#e6db74>&#34;build&#34;</span>
    <span style=color:#66d9ef>val</span> mode = System.getenv(<span style=color:#e6db74>&#34;CONFIGURATION&#34;</span>) <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;DEBUG&#34;</span>
    <span style=color:#66d9ef>val</span> sdkName = System.getenv(<span style=color:#e6db74>&#34;SDK_NAME&#34;</span>) <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;iphonesimulator&#34;</span>
    <span style=color:#66d9ef>val</span> targetName = <span style=color:#e6db74>&#34;ios&#34;</span> + <span style=color:#66d9ef>if</span> (sdkName.startsWith(<span style=color:#e6db74>&#34;iphoneos&#34;</span>)) <span style=color:#e6db74>&#34;Arm64&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;X64&#34;</span>
    <span style=color:#66d9ef>val</span> framework = kotlin.targets.getByName&lt;KotlinNativeTarget&gt;(targetName).binaries.getFramework(mode)
    inputs.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;mode&#34;</span>, mode)
    dependsOn(framework.linkTask)
    <span style=color:#66d9ef>val</span> targetDir = File(buildDir, <span style=color:#e6db74>&#34;xcode-frameworks&#34;</span>)
    from({ framework.outputDirectory })
    into(targetDir)
}
tasks.getByName(<span style=color:#e6db74>&#34;build&#34;</span>).dependsOn(packForXcode)
</code></pre></div><p>This task is automatically called by Xcode when the iOS (or macOS) application is built.</p><figure><a href=/img/kmp-existing-projects/build-script-xcode.png><img loading=lazy src=/img/kmp-existing-projects/build-script-xcode.png></a></figure><p>The task uses the configuration of the iOS project to define the build mode and the target architecture.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> mode = System.getenv(<span style=color:#e6db74>&#34;CONFIGURATION&#34;</span>) <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;DEBUG&#34;</span>
<span style=color:#66d9ef>val</span> sdkName = System.getenv(<span style=color:#e6db74>&#34;SDK_NAME&#34;</span>) <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;iphonesimulator&#34;</span>
<span style=color:#66d9ef>val</span> targetName = <span style=color:#e6db74>&#34;ios&#34;</span> + <span style=color:#66d9ef>if</span> (sdkName.startsWith(<span style=color:#e6db74>&#34;iphoneos&#34;</span>)) <span style=color:#e6db74>&#34;Arm64&#34;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;X64&#34;</span>
</code></pre></div><p>The build mode can be <code>RELEASE</code> or <code>DEBUG</code> while the target name depends on the architecture which we are building for. The real devices use the <em>Arm64</em> architecture, while the simulator uses the host computer architecture which in most of the cases is <em>X64</em> (at least until when Apple Silicon will be sufficiently spread).</p><p>And this is the problem of this task!</p><p>Since the aim is to publish a framework to be used by an existing project, it’s impossible to know a priori which architecture is necessary or the build mode.</p><blockquote><p>Update: Starting from Kotlin 1.5.20, there is a new task provided by the Kotlin Multiplatform Gradle Plugin named <code>embedAndSignAppleFrameworkForXcode</code> that replaces the <code>packForXcode</code> one. The aim of this task is the same as the old one, that is publishing a framework to be used by an existing project. So it&rsquo;s impossible to know a priori which architecture is necessary or the build mode. For more info, give a look <a href=https://blog.jetbrains.com/kotlin/2021/07/multiplatform-gradle-plugin-improved-for-connecting-kmm-modules/>at the Jetbrains blogpost</a>.</p></blockquote><h4 id=cocoapods-gradle-plugin>CocoaPods Gradle Plugin<a hidden class=anchor aria-hidden=true href=#cocoapods-gradle-plugin>#</a></h4><p>Another way to build a framework from the KMP code is using the <a href=https://kotlinlang.org/docs/reference/native/cocoapods.html>CocoaPods Gradle Plugin</a>. This plugin builds the framework and places it inside a CocoaPods repository that will be added as dependency on Xcode (The plugin can be used also to add other Pod libraries on the native target).</p><p>To start using the plugin, some configurations are necessary:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>plugins {
     kotlin(<span style=color:#e6db74>&#34;multiplatform&#34;</span>) version <span style=color:#e6db74>&#34;1.4.10&#34;</span>
     kotlin(<span style=color:#e6db74>&#34;native.cocoapods&#34;</span>) version <span style=color:#e6db74>&#34;1.4.10&#34;</span>
 }

 <span style=color:#75715e>// CocoaPods requires the podspec to have a version.
</span><span style=color:#75715e></span> version = <span style=color:#e6db74>&#34;1.0&#34;</span>

 kotlin {
     cocoapods {
         <span style=color:#75715e>// Configure fields required by CocoaPods.
</span><span style=color:#75715e></span>         summary = <span style=color:#e6db74>&#34;Some description for a Kotlin/Native module&#34;</span>
         homepage = <span style=color:#e6db74>&#34;Link to a Kotlin/Native module homepage&#34;</span>

         <span style=color:#75715e>// You can change the name of the produced framework.
</span><span style=color:#75715e></span>         <span style=color:#75715e>// By default, it is the name of the Gradle project.
</span><span style=color:#75715e></span>         frameworkName = <span style=color:#e6db74>&#34;&lt;framework-name&gt;&#34;</span>
     }
 }
</code></pre></div><p>Then, during the build, the <a href=https://guides.cocoapods.org/syntax/podspec.html>Podspec file</a> (a file that describes the Pod library - it contains the name, version, and description, where the source should be fetched from, what files to use, the build settings to apply, etc) is generated starting from the information provided in the <code>cocoapods</code> block.</p><p>The Podspec contains also a script that is automatically added as a build script, called every time the iOS application is built, like <code>packForXcode</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>spec<span style=color:#f92672>.</span>script_phases <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>
    {
        <span style=color:#e6db74>:name</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;Build shared&#39;</span>,
        <span style=color:#e6db74>:execution_position</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>:before_compile</span>,
        <span style=color:#e6db74>:shell_path</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;/bin/sh&#39;</span>,
        <span style=color:#e6db74>:script</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&lt;&lt;-SCRIPT
</span><span style=color:#e6db74></span>            set <span style=color:#f92672>-</span>ev
            <span style=color:#66d9ef>REPO_ROOT</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;$PODS_TARGET_SRCROOT&#34;</span>
            <span style=color:#e6db74>&#34;$REPO_ROOT/../gradlew&#34;</span> <span style=color:#f92672>-</span>p <span style=color:#e6db74>&#34;$REPO_ROOT&#34;</span> <span style=color:#e6db74>:shared:syncFramework</span> \
                <span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>target<span style=color:#f92672>=</span>$KOTLIN_TARGET \
                <span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>configuration<span style=color:#f92672>=</span>$CONFIGURATION \
                <span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>cflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;$OTHER_CFLAGS&#34;</span> \
                <span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>paths<span style=color:#f92672>.</span>headers<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;$HEADER_SEARCH_PATHS&#34;</span> \
                <span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>paths<span style=color:#f92672>.</span>frameworks<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;$FRAMEWORK_SEARCH_PATHS&#34;</span>
        <span style=color:#66d9ef>SCRIPT</span>
    }
<span style=color:#f92672>]</span>
</code></pre></div><p>Unfortunately, this script has the same problems as <code>packForXcode</code>, because the configuration and the target architecture are computed during the build phase.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>target<span style=color:#f92672>=</span>$KOTLIN_TARGET \
<span style=color:#f92672>-</span><span style=color:#66d9ef>Pkotlin</span><span style=color:#f92672>.</span>native<span style=color:#f92672>.</span>cocoapods<span style=color:#f92672>.</span>configuration<span style=color:#f92672>=</span>$CONFIGURATION \
</code></pre></div><p>So, also the CocoaPods Gradle Plugin can’t be used.</p><h4 id=fat-framework>Fat Framework<a hidden class=anchor aria-hidden=true href=#fat-framework>#</a></h4><p>The solution is to use a Fat Framework that contains the code for every required architecture. To build it, there is a Gradle task named <code>FatFrameworkTask</code> that can be customized to meet the specific needs.</p><p>The first step is building a custom Gradle task to build a debug version of the Fat Framework.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>tasks {
    register(<span style=color:#e6db74>&#34;universalFrameworkDebug&#34;</span>, org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>) {
        baseName = libName
        from(
            iosArm64().binaries.getFramework(<span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#e6db74>&#34;Debug&#34;</span>),
            iosX64().binaries.getFramework(<span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#e6db74>&#34;Debug&#34;</span>)
        )
        destinationDir = buildDir.resolve(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
        group = <span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>
        description = <span style=color:#e6db74>&#34;Create the debug fat framework for iOs&#34;</span>
        dependsOn(<span style=color:#e6db74>&#34;link&lt;your-library-name&gt;DebugFrameworkIosArm64&#34;</span>)
        dependsOn(<span style=color:#e6db74>&#34;link&lt;your-library-name&gt;DebugFrameworkIosX64&#34;</span>)
    }
}        
</code></pre></div><p>This custom Gradle task, named <code>universalFrameworkDebug</code> is necessary to provide some customizations to the <code>FatFrameworkTask</code>. After some cosmetic info, like the name and the group of the Framework, the required architectures and configurations must be provided. In this case, the required architectures are <em>x64</em> for the simulator and <em>arm64</em> for the real devices. The configuration instead is <code>Debug</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>from(
    iosArm64().binaries.getFramework(<span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#e6db74>&#34;Debug&#34;</span>),
    iosX64().binaries.getFramework(<span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#e6db74>&#34;Debug&#34;</span>)
)
</code></pre></div><p>The last needed information is the destination of the framework.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>destinationDir = buildDir.resolve(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&#34;</span>)
</code></pre></div><p>The destination will be a CocoaPods repository that at the end is a git repository that contains the framework, the debug symbols, and a Podspec file.</p><figure><a href=/img/kmp-existing-projects/cocoa-repo-git.png><img loading=lazy src=/img/kmp-existing-projects/cocoa-repo-git.png alt="An example of a CocoaPod repo hosted on a git repo"></a><figcaption><p>An example of a CocoaPod repo hosted on a git repo</p></figcaption></figure><p>The git repository uses branches and tagging for handling debug and release versions. The debug versions of the Framework are pushed directly to the develop branch without any tagging. The release version instead is pushed on master and tagged.</p><p>For more information about setting up a private CocoaPod repo, I suggest you give a look at the <a href=https://guides.cocoapods.org/making/private-cocoapods.html>official documentation</a>.</p><p>After pushing the changes on git, the Pod library is ready to be pulled by XCode. On the <code>Podfile</code> of the iOs project, is necessary to specify the Pod library with the information about the source and the version.</p><p>For debug releases, it is enough to specify to pull the latest version from the <code>develop</code> branch</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>pod <span style=color:#e6db74>&#39;&lt;your-library-name&gt;&#39;</span>, <span style=color:#e6db74>:git</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;git@github.com:&lt;git-username&gt;/&lt;repo-name&gt;.git&#34;</span>, <span style=color:#e6db74>:branch</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;develop&#39;</span>
</code></pre></div><p>For production releases instead, it is better to specify the required version number.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>pod <span style=color:#e6db74>&#39;&lt;your-library-name&gt;&#39;</span>, <span style=color:#e6db74>:git</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;git@github.com:&lt;git-username&gt;/&lt;repo-name&gt;.git&#34;</span>, <span style=color:#e6db74>:tag</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#39;&lt;version-number&gt;&#39;</span>
</code></pre></div><p>The last step is building another Gradle task, to build a release version of the Fat Framework.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>tasks {
    register(<span style=color:#e6db74>&#34;universalFrameworkRelease&#34;</span>, org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>) {
        baseName = libName
        from(
            iosArm64().binaries.getFramework(<span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#e6db74>&#34;Release&#34;</span>),
            iosX64().binaries.getFramework(<span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#e6db74>&#34;Release&#34;</span>)
        )
        destinationDir = buildDir.resolve(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
        group = <span style=color:#e6db74>&#34;&lt;your-library-name&gt;&#34;</span>
        description = <span style=color:#e6db74>&#34;Create the debug fat framework for iOs&#34;</span>
        dependsOn(<span style=color:#e6db74>&#34;link&lt;your-library-name&gt;ReleaseFrameworkIosArm64&#34;</span>)
        dependsOn(<span style=color:#e6db74>&#34;link&lt;your-library-name&gt;ReleaseFrameworkIosX64&#34;</span>)
    }
}        
</code></pre></div><p>The script is the same as the previous one, with the exception that the target is changed from <code>Debug</code> to <code>Release</code>.</p><p>And, that’s it! Finally, it is possible to start using the KMP library on iOS as well.</p><p>However, there is room for improvement and I wanted to minimize the effort of publishing. All the steps for publishing the framework in the CocoaPods repository can be automated with a Gradle task.</p><p>The <code>publishDevFramework</code> task will build the framework and automatically publish the changes in the develop branch of the CocoaPods repository.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>tasks {
    register(<span style=color:#e6db74>&#34;publishDevFramework&#34;</span>) {
        description = <span style=color:#e6db74>&#34;Publish iOs framweork to the Cocoa Repo&#34;</span>
    
        project.exec {
            workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
            commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;checkout&#34;</span>, <span style=color:#e6db74>&#34;develop&#34;</span>).standardOutput
        }
    
        dependsOn(<span style=color:#e6db74>&#34;universalFrameworkDebug&#34;</span>)
    
        doLast {
            <span style=color:#66d9ef>val</span> dir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec&#34;</span>)
            <span style=color:#66d9ef>val</span> tempFile = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec.new&#34;</span>)
    
            <span style=color:#66d9ef>val</span> reader = dir.bufferedReader()
            <span style=color:#66d9ef>val</span> writer = tempFile.bufferedWriter()
            <span style=color:#66d9ef>var</span> currentLine: String?
    
            <span style=color:#66d9ef>while</span> (reader.readLine().also { currLine <span style=color:#f92672>-&gt;</span> currentLine = currLine } <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
                <span style=color:#66d9ef>if</span> (currentLine<span style=color:#f92672>?.</span>startsWith(<span style=color:#e6db74>&#34;s.version&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>) {
                    writer.write(<span style=color:#e6db74>&#34;s.version       = </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>${libVersionName}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span> + System.lineSeparator())
                } <span style=color:#66d9ef>else</span> {
                    writer.write(currentLine + System.lineSeparator())
                }
            }
            writer.close()
            reader.close()
            <span style=color:#66d9ef>val</span> successful = tempFile.renameTo(dir)
    
            <span style=color:#66d9ef>if</span> (successful) {
    
                <span style=color:#66d9ef>val</span> dateFormatter = SimpleDateFormat(<span style=color:#e6db74>&#34;dd/MM/yyyy - HH:mm&#34;</span>, Locale.getDefault())
                project.exec {
                    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
                    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;commit&#34;</span>, <span style=color:#e6db74>&#34;-a&#34;</span>, <span style=color:#e6db74>&#34;-m&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>New dev release: </span><span style=color:#e6db74>${libVersionName}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${dateFormatter.format(Date())}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>).standardOutput
                }
    
                project.exec {
                    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
                    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;push&#34;</span>, <span style=color:#e6db74>&#34;origin&#34;</span>, <span style=color:#e6db74>&#34;develop&#34;</span>).standardOutput
                }
            }
        }
    }
}
</code></pre></div><p>First of all, the task changes the working branch and then builds the debug framework.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;checkout&#34;</span>, <span style=color:#e6db74>&#34;develop&#34;</span>).standardOutput
}

dependsOn(<span style=color:#e6db74>&#34;universalFrameworkDebug&#34;</span>)
</code></pre></div><p>Before publishing the new version, the version name inside the Podspec file must be updated.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#f92672>...</span>
s<span style=color:#f92672>.</span>name          <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;your-library-name&#34;</span>
s<span style=color:#f92672>.</span>version       <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;version-name&gt;&#34;</span>
<span style=color:#f92672>...</span>
</code></pre></div><p>And this is done automatically by the task.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> dir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec&#34;</span>)
<span style=color:#f92672>..</span>.
<span style=color:#66d9ef>if</span> (currentLine<span style=color:#f92672>?.</span>startsWith(<span style=color:#e6db74>&#34;s.version&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>) {
    writer.write(<span style=color:#e6db74>&#34;s.version       = </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>${libVersionName}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span> + System.lineSeparator())
} 
</code></pre></div><p>And at the end, the new changes are committed and published into the develop branch of the repository.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> dateFormatter = SimpleDateFormat(<span style=color:#e6db74>&#34;dd/MM/yyyy - HH:mm&#34;</span>, Locale.getDefault())
project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;commit&#34;</span>, <span style=color:#e6db74>&#34;-a&#34;</span>, <span style=color:#e6db74>&#34;-m&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>New dev release: </span><span style=color:#e6db74>${libVersionName}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>${dateFormatter.format(Date())}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>).standardOutput
}
    
project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;push&#34;</span>, <span style=color:#e6db74>&#34;origin&#34;</span>, <span style=color:#e6db74>&#34;develop&#34;</span>).standardOutput
}
</code></pre></div><p>To publish a release version of the Framework, there is the <code>publishFramework</code> task.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>tasks {
    register(<span style=color:#e6db74>&#34;publishFramework&#34;</span>) {
        description = <span style=color:#e6db74>&#34;Publish iOs framework to the Cocoa Repo&#34;</span>
    
        project.exec {
            workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
            commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;checkout&#34;</span>, <span style=color:#e6db74>&#34;master&#34;</span>).standardOutput
        }
    
        dependsOn(<span style=color:#e6db74>&#34;universalFrameworkRelease&#34;</span>)
    
        doLast {
            <span style=color:#66d9ef>val</span> dir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec&#34;</span>)
            <span style=color:#66d9ef>val</span> tempFile = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec.new&#34;</span>)
    
            <span style=color:#66d9ef>val</span> reader = dir.bufferedReader()
            <span style=color:#66d9ef>val</span> writer = tempFile.bufferedWriter()
            <span style=color:#66d9ef>var</span> currentLine: String?
    
            <span style=color:#66d9ef>while</span> (reader.readLine().also { currLine <span style=color:#f92672>-&gt;</span> currentLine = currLine } <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
                <span style=color:#66d9ef>if</span> (currentLine<span style=color:#f92672>?.</span>startsWith(<span style=color:#e6db74>&#34;s.version&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>) {
                    writer.write(<span style=color:#e6db74>&#34;s.version       = </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>${libVersionName}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span> + System.lineSeparator())
                } <span style=color:#66d9ef>else</span> {
                    writer.write(currentLine + System.lineSeparator())
                }
            }
            writer.close()
            reader.close()
            <span style=color:#66d9ef>val</span> successful = tempFile.renameTo(dir)
    
            <span style=color:#66d9ef>if</span> (successful) {
    
                project.exec {
                    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
                    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;commit&#34;</span>, <span style=color:#e6db74>&#34;-a&#34;</span>, <span style=color:#e6db74>&#34;-m&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>New release: </span><span style=color:#e6db74>${libVersionName}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>).standardOutput
                }
    
                project.exec {
                    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
                    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;tag&#34;</span>, libVersionName).standardOutput
                }
    
                project.exec {
                    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
                    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;push&#34;</span>, <span style=color:#e6db74>&#34;origin&#34;</span>, <span style=color:#e6db74>&#34;master&#34;</span>, <span style=color:#e6db74>&#34;--tags&#34;</span>).standardOutput
                }
            }
        }
    }
}
</code></pre></div><p>This task is very similar to the <code>publishDevFramework</code> task. First of all, since it is a release, the master branch will be used.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;checkout&#34;</span>, <span style=color:#e6db74>&#34;master&#34;</span>).standardOutput
}

dependsOn(<span style=color:#e6db74>&#34;universalFrameworkRelease&#34;</span>)
</code></pre></div><p>Then, before publishing, the commit will be tagged to specify the version name of the release.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;commit&#34;</span>, <span style=color:#e6db74>&#34;-a&#34;</span>, <span style=color:#e6db74>&#34;-m&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>New release: </span><span style=color:#e6db74>${libVersionName}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>).standardOutput
}
    
project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;tag&#34;</span>, libVersionName).standardOutput
}
    
project.exec {
    workingDir = File(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$rootDir</span><span style=color:#e6db74>/../../hn-foundation-cocoa&#34;</span>)
    commandLine(<span style=color:#e6db74>&#34;git&#34;</span>, <span style=color:#e6db74>&#34;push&#34;</span>, <span style=color:#e6db74>&#34;origin&#34;</span>, <span style=color:#e6db74>&#34;master&#34;</span>, <span style=color:#e6db74>&#34;--tags&#34;</span>).standardOutput
}
</code></pre></div><p>And, that’s it! When the KMP library is ready to be published, three tasks can ben called:</p><ul><li><code>publish</code> to publish JVM and Android artifacts;</li><li><code>publishDevFramework</code> to publish a debug version of the iOs Framework;</li><li><code>publishFramework</code> to publish a release version of the iOs Framework.</li></ul><blockquote><p>Update: FatFrameworks seems not to be the “current state of the art” solution to distribute multiple architectures at the same time. In fact, Apple during <a href=https://developer.apple.com/videos/play/wwdc2019/416/>WWDC 2019</a> has introduced <a href=https://help.apple.com/xcode/mac/11.4/#/dev544efab96>XCFramework</a>, a binary that can contain multiple platform-specific variants (even for iOS and macOS at the same time). To understand how to integrate KMP into existing code, give a look at my <a href=https://www.marcogomiero.com/posts/2021/build-xcframework-kmp/>new article</a>.</p></blockquote><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>As shown in this article, the process of integrating Kotlin Multiplatform in an existing project requires more work on the architecture side. That’s why is preferable to start sharing a feature that can be extracted gradually.</p><p>The framework to follow is:</p><blockquote><p>Start little and then go bigger.</p></blockquote><p>By starting little, it is possible to validate the process with a “contained” effort, and then, after the validation, it is possible to go bigger and start sharing more and more features. For example at Uniwhere, we started sharing the DTOs and after validating the process, we decided to share also the persistence layer with <a href=https://cashapp.github.io/sqldelight/>SQLDelight</a>.</p><p>All the code that I showed in this article came from <a href=https://github.com/prof18/shared-hn-android-ios-backend>a sample that I’ve published on GitHub</a> (if you are interested only in the custom Gradle task, <a href=https://github.com/prof18/shared-hn-android-ios-backend/blob/master/hn-foundation/build.gradle.kts#L99>click here</a>). This sample is composed of an Android app, an iOs app, and a backend that share some common code via a Kotlin Multiplatform library.</p><blockquote><p>Update: I’ve grouped all the tasks mentioned in the article in a Gradle plugin! To know more about it, give a look to <a href=https://www.marcogomiero.com/posts/2021/kmp-fatframework-cocoa-release/>this post</a>.</p></blockquote><h2 id=bonus>Bonus:<a hidden class=anchor aria-hidden=true href=#bonus>#</a></h2><p>I’ve spoke about this topic in a talk <a href=https://fosdem.org/2021/schedule/event/and_that_folks_is_how_we_shared_code/>in the Kotlin Dev Room at Fosdem 2021</a>.</p><p>Here’s the recording of the session:</p><br><video controls width=100%>
<source src=https://mirror.as35701.net/video.fosdem.org/2021/D.kotlin/and_that_folks_is_how_we_shared_code.webm type=video/webm></video><p>and the slides:</p><br><script async class=speakerdeck-embed data-id=e29e5d5369894442a23544dc6feb4b4c data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.marcogomiero.com/posts/2021/kmp-fatframework-cocoa-release/><span class=title>« Prev</span><br><span>Introducing KMP FatFramework Cocoa, a Gradle plugin for iOS FatFramework</span></a>
<a class=next href=https://www.marcogomiero.com/posts/2021/move-libray-jcenter-to-maven/><span class=title>Next »</span><br><span>Migrating old artifacts from JCenter to MavenCentral</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>