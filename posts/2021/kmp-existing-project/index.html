<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Introducing Kotlin Multiplatform in an existing project - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:"><meta property="og:image" content><meta property="og:title" content="Introducing Kotlin Multiplatform in an existing project"><meta property="og:description" content="After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2021/kmp-existing-project/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-25T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introducing Kotlin Multiplatform in an existing project"><meta name=twitter:description content="After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:"><script src=https://www.marcogomiero.com/js/feather.min.js></script>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.2d1f13dc82ea2d94683809543a326af8a9a1f3a6c000f7b7af5d8f02a2e6ec25.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write</span></a>
<a href=/talks/><span>Speak</span></a>
<a href=/projects/><span>Build</span></a>
<a href=/about-me/><span>About</span></a>
| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Introducing Kotlin Multiplatform in an existing project</h1><div class=post-meta><span title='2021-02-25 00:00:00 +0000 UTC'>25 February 2021</span></div></div><section class=body><span class=raw-html><div class=post-award-container><a href=https://androidweekly.net/issues/issue-455><img src=https://androidweekly.net/issues/issue-455/badge></a>
<a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=22e5320947"><img src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23239-%237874b4></a></div></span><p>After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).</p><p>This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).</p><p>When starting a new blank KMP project it is easier to have a mono-repo structure like this:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.
</span></span><span style=display:flex><span>└── kmm-project
</span></span><span style=display:flex><span>    ├── androidApp
</span></span><span style=display:flex><span>    ├── iosApp
</span></span><span style=display:flex><span>    └── shared
</span></span></code></pre></div><p>However, existing projects most likely don’t have a mono-repo structure. And making a refactor to achieve this structure can be extremely difficult for time or management constraints. But KMP is built around the concept of sharing as much non-UI code as possible, and it is possible to start sharing a little piece of tech stack. Then, this “little piece of tech stack” will be served to the existing projects as a library.</p><p>Where to start from is subjective and it depends on the specific project, but there are some parts that better suit this topic. For example, all the boilerplate code (constants, data models, DTOs, etc), that is boring to write and is more error-prone. Or it could be a feature that centralizes the source of truth (e.g. if a field is nullable or not) because with a single source of truth there will also be a single point of failure. Or it could be some utility or analytics helper that every project has.</p><p>An important thing to take in mind is that all the features chosen for sharing must have the possibility to be extracted gradually. That’s because, during the evaluation process of KMP, it is better to make a final decision without using too much time. For example, it will be not a good idea to start sharing the entire network layer because you will risk ending up with useless work if KMP is not the right solution for the project. Otherwise, starting with some small features like a DTO or a data model will require less “extraction time” and it will leave enough time to work on the architecture needed to have a Kotlin Multiplatform library in an existing project.</p><p>For example, at <a href=https://www.uniwhere.com/>Uniwhere</a> we have decided to start with some DTOs and after validating the process, we have migrated all the others.</p><h2 id=publishing-architecture>Publishing Architecture</h2><p>The architecture of an existing project with Kotlin Multiplatform will look like this:</p><figure><a href=/img/kmp-existing-project/kmp-publish-arch.png><img src=/img/kmp-existing-projects/kmp-publish-arch.png></a></figure><p>There is a repository for every platform:</p><ul><li>a repository for the KMP library;</li><li>a repository for the Backend;</li><li>a repository for the Android app;</li><li>a repository for the iOS app.</li></ul><p>As mentioned early on, the KMP code is served as a library. The compiler generates a <em>.jar</em> for the JVM, a <em>.aar</em> for Android, and a <em>Framework</em> for iOs. The <em>.jar</em> and the <em>.aar</em> can be published in a <em>Maven</em> repository. A <em>Framework</em> can be published in different places: for example in a <em><a href=https://cocoapods.org/>CocoaPods</a></em> repository, in the <a href=https://swift.org/package-manager/>Swift Package Manager</a> or with <a href=https://github.com/Carthage/Carthage>Carthage</a>. Since I’m familiar with CocoaPods (and because we are using it at Uniwhere), I’ve decided to stick with it.</p><h3 id=publishing-for-android-and-the-jvm>Publishing for Android and the JVM</h3><p>The amount of work needed to publish a JVM and an Android library to Maven is pretty straightforward, thanks to the <a href=https://docs.gradle.org/current/userguide/publishing_maven.html>Maven Publish Plugin</a>.
Only a few lines of configuration on the <em>build.gradle.kts</em> file, are necessary (here I’m assuming that you have already configured a Maven repository since it’s not the scope of the article to explain how. Otherwise, you can use a local Maven repository on your computer that does not require any kind of configuration):</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>plugins {
</span></span><span style=display:flex><span>    <span style=color:#78787e>//...
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    id(<span style=color:#5af78e>&#34;maven-publish&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>group = <span style=color:#5af78e>&#34;&lt;your-group-id&gt;&#34;</span>
</span></span><span style=display:flex><span>artifactId = <span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span> <span style=color:#78787e>// If not specified, it will use the name of the project
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>version = <span style=color:#5af78e>&#34;&lt;version-name&gt;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// This block is only needed to publish on a online maven repo
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>publishing {
</span></span><span style=display:flex><span>    repositories {
</span></span><span style=display:flex><span>        maven{
</span></span><span style=display:flex><span>            credentials {
</span></span><span style=display:flex><span>                username = <span style=color:#5af78e>&#34;&lt;username&gt;&#34;</span>
</span></span><span style=display:flex><span>                password = <span style=color:#5af78e>&#34;&lt;pwd&gt;&#34;</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            url = url(<span style=color:#5af78e>&#34;https://mymavenrepo.com&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After that, it is possible to build and publish the KMP library with the <code>./gradlew publish</code> command (or with <code>./gradlew publishToMavenLocal</code>).</p><p>Then, it is possible to pull the library on Android:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;&lt;your-group-id&gt;:&lt;your-library-name&gt;-android:&lt;version-name&gt;&#34;</span>)
</span></span></code></pre></div><p>and on the JVM project:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>implementation(<span style=color:#5af78e>&#34;&lt;your-group-id&gt;:&lt;your-library-name&gt;-jvm:&lt;version-name&gt;&#34;</span>)
</span></span></code></pre></div><h3 id=publishing-for-ios>Publishing for iOs</h3><blockquote><p>On iOS things are harder.</p></blockquote><h4 id=pack-for-xcode>Pack for Xcode</h4><p>On newly created KMP projects, there is a Gradle task, named <strong><code>packForXcode</code></strong>, that automatically builds the framework and places it in a specific build folder.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> packForXcode <span style=color:#ff6ac1>by</span> tasks.creating(Sync<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>) {
</span></span><span style=display:flex><span>    group = <span style=color:#5af78e>&#34;build&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> mode = System.getenv(<span style=color:#5af78e>&#34;CONFIGURATION&#34;</span>) <span style=color:#ff6ac1>?:</span> <span style=color:#5af78e>&#34;DEBUG&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> sdkName = System.getenv(<span style=color:#5af78e>&#34;SDK_NAME&#34;</span>) <span style=color:#ff6ac1>?:</span> <span style=color:#5af78e>&#34;iphonesimulator&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> targetName = <span style=color:#5af78e>&#34;ios&#34;</span> + <span style=color:#ff6ac1>if</span> (sdkName.startsWith(<span style=color:#5af78e>&#34;iphoneos&#34;</span>)) <span style=color:#5af78e>&#34;Arm64&#34;</span> <span style=color:#ff6ac1>else</span> <span style=color:#5af78e>&#34;X64&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> framework = kotlin.targets.getByName&lt;KotlinNativeTarget&gt;(targetName).binaries.getFramework(mode)
</span></span><span style=display:flex><span>    inputs.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;mode&#34;</span>, mode)
</span></span><span style=display:flex><span>    dependsOn(framework.linkTask)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> targetDir = File(buildDir, <span style=color:#5af78e>&#34;xcode-frameworks&#34;</span>)
</span></span><span style=display:flex><span>    from({ framework.outputDirectory })
</span></span><span style=display:flex><span>    into(targetDir)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>tasks.getByName(<span style=color:#5af78e>&#34;build&#34;</span>).dependsOn(packForXcode)
</span></span></code></pre></div><p>This task is automatically called by Xcode when the iOS (or macOS) application is built.</p><figure><a href=/img/kmp-existing-projects/build-script-xcode.png><img src=/img/kmp-existing-projects/build-script-xcode.png></a></figure><p>The task uses the configuration of the iOS project to define the build mode and the target architecture.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> mode = System.getenv(<span style=color:#5af78e>&#34;CONFIGURATION&#34;</span>) <span style=color:#ff6ac1>?:</span> <span style=color:#5af78e>&#34;DEBUG&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>val</span> sdkName = System.getenv(<span style=color:#5af78e>&#34;SDK_NAME&#34;</span>) <span style=color:#ff6ac1>?:</span> <span style=color:#5af78e>&#34;iphonesimulator&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>val</span> targetName = <span style=color:#5af78e>&#34;ios&#34;</span> + <span style=color:#ff6ac1>if</span> (sdkName.startsWith(<span style=color:#5af78e>&#34;iphoneos&#34;</span>)) <span style=color:#5af78e>&#34;Arm64&#34;</span> <span style=color:#ff6ac1>else</span> <span style=color:#5af78e>&#34;X64&#34;</span>
</span></span></code></pre></div><p>The build mode can be <code>RELEASE</code> or <code>DEBUG</code> while the target name depends on the architecture which we are building for. The real devices use the <em>Arm64</em> architecture, while the simulator uses the host computer architecture which in most of the cases is <em>X64</em> (at least until when Apple Silicon will be sufficiently spread).</p><p>And this is the problem of this task!</p><p>Since the aim is to publish a framework to be used by an existing project, it’s impossible to know a priori which architecture is necessary or the build mode.</p><blockquote><p>Update: Starting from Kotlin 1.5.20, there is a new task provided by the Kotlin Multiplatform Gradle Plugin named <code>embedAndSignAppleFrameworkForXcode</code> that replaces the <code>packForXcode</code> one. The aim of this task is the same as the old one, that is publishing a framework to be used by an existing project. So it&rsquo;s impossible to know a priori which architecture is necessary or the build mode. For more info, give a look <a href=https://blog.jetbrains.com/kotlin/2021/07/multiplatform-gradle-plugin-improved-for-connecting-kmm-modules/>at the Jetbrains blogpost</a>.</p></blockquote><h4 id=cocoapods-gradle-plugin>CocoaPods Gradle Plugin</h4><p>Another way to build a framework from the KMP code is using the <a href=https://kotlinlang.org/docs/reference/native/cocoapods.html>CocoaPods Gradle Plugin</a>. This plugin builds the framework and places it inside a CocoaPods repository that will be added as dependency on Xcode (The plugin can be used also to add other Pod libraries on the native target).</p><p>To start using the plugin, some configurations are necessary:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>plugins {
</span></span><span style=display:flex><span>     kotlin(<span style=color:#5af78e>&#34;multiplatform&#34;</span>) version <span style=color:#5af78e>&#34;1.4.10&#34;</span>
</span></span><span style=display:flex><span>     kotlin(<span style=color:#5af78e>&#34;native.cocoapods&#34;</span>) version <span style=color:#5af78e>&#34;1.4.10&#34;</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#78787e>// CocoaPods requires the podspec to have a version.
</span></span></span><span style=display:flex><span><span style=color:#78787e></span> version = <span style=color:#5af78e>&#34;1.0&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> kotlin {
</span></span><span style=display:flex><span>     cocoapods {
</span></span><span style=display:flex><span>         <span style=color:#78787e>// Configure fields required by CocoaPods.
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>         summary = <span style=color:#5af78e>&#34;Some description for a Kotlin/Native module&#34;</span>
</span></span><span style=display:flex><span>         homepage = <span style=color:#5af78e>&#34;Link to a Kotlin/Native module homepage&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         <span style=color:#78787e>// You can change the name of the produced framework.
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>         <span style=color:#78787e>// By default, it is the name of the Gradle project.
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>         frameworkName = <span style=color:#5af78e>&#34;&lt;framework-name&gt;&#34;</span>
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>Then, during the build, the <a href=https://guides.cocoapods.org/syntax/podspec.html>Podspec file</a> (a file that describes the Pod library - it contains the name, version, and description, where the source should be fetched from, what files to use, the build settings to apply, etc) is generated starting from the information provided in the <code>cocoapods</code> block.</p><p>The Podspec contains also a script that is automatically added as a build script, called every time the iOS application is built, like <code>packForXcode</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>spec<span style=color:#ff6ac1>.</span>script_phases <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>[</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#5af78e>:name</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&#39;Build shared&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#5af78e>:execution_position</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>:before_compile</span>,
</span></span><span style=display:flex><span>        <span style=color:#5af78e>:shell_path</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&#39;/bin/sh&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#5af78e>:script</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&lt;&lt;-SCRIPT
</span></span></span><span style=display:flex><span><span style=color:#5af78e></span>            set <span style=color:#ff6ac1>-</span>ev
</span></span><span style=display:flex><span>            <span style=color:#ff9f43>REPO_ROOT</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;$PODS_TARGET_SRCROOT&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#5af78e>&#34;$REPO_ROOT/../gradlew&#34;</span> <span style=color:#ff6ac1>-</span><span style=color:#ff5c57>p</span> <span style=color:#5af78e>&#34;$REPO_ROOT&#34;</span> <span style=color:#5af78e>:shared:syncFramework</span> \
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>target<span style=color:#ff6ac1>=</span><span style=color:#ff5c57>$KOTLIN_TARGET</span> \
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>configuration<span style=color:#ff6ac1>=</span><span style=color:#ff5c57>$CONFIGURATION</span> \
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>cflags<span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;$OTHER_CFLAGS&#34;</span> \
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>paths<span style=color:#ff6ac1>.</span>headers<span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;$HEADER_SEARCH_PATHS&#34;</span> \
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>paths<span style=color:#ff6ac1>.</span>frameworks<span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;$FRAMEWORK_SEARCH_PATHS&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff9f43>SCRIPT</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#ff6ac1>]</span>
</span></span></code></pre></div><p>Unfortunately, this script has the same problems as <code>packForXcode</code>, because the configuration and the target architecture are computed during the build phase.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>target<span style=color:#ff6ac1>=</span><span style=color:#ff5c57>$KOTLIN_TARGET</span> \
</span></span><span style=display:flex><span><span style=color:#ff6ac1>-</span><span style=color:#ff9f43>Pkotlin</span><span style=color:#ff6ac1>.</span>native<span style=color:#ff6ac1>.</span>cocoapods<span style=color:#ff6ac1>.</span>configuration<span style=color:#ff6ac1>=</span><span style=color:#ff5c57>$CONFIGURATION</span> \
</span></span></code></pre></div><p>So, also the CocoaPods Gradle Plugin can’t be used.</p><h4 id=fat-framework>Fat Framework</h4><p>The solution is to use a Fat Framework that contains the code for every required architecture. To build it, there is a Gradle task named <code>FatFrameworkTask</code> that can be customized to meet the specific needs.</p><p>The first step is building a custom Gradle task to build a debug version of the Fat Framework.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>tasks {
</span></span><span style=display:flex><span>    register(<span style=color:#5af78e>&#34;universalFrameworkDebug&#34;</span>, org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>) {
</span></span><span style=display:flex><span>        baseName = libName
</span></span><span style=display:flex><span>        from(
</span></span><span style=display:flex><span>            iosArm64().binaries.getFramework(<span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#5af78e>&#34;Debug&#34;</span>),
</span></span><span style=display:flex><span>            iosX64().binaries.getFramework(<span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#5af78e>&#34;Debug&#34;</span>)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        destinationDir = buildDir.resolve(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>        group = <span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>
</span></span><span style=display:flex><span>        description = <span style=color:#5af78e>&#34;Create the debug fat framework for iOs&#34;</span>
</span></span><span style=display:flex><span>        dependsOn(<span style=color:#5af78e>&#34;link&lt;your-library-name&gt;DebugFrameworkIosArm64&#34;</span>)
</span></span><span style=display:flex><span>        dependsOn(<span style=color:#5af78e>&#34;link&lt;your-library-name&gt;DebugFrameworkIosX64&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}        
</span></span></code></pre></div><p>This custom Gradle task, named <code>universalFrameworkDebug</code> is necessary to provide some customizations to the <code>FatFrameworkTask</code>. After some cosmetic info, like the name and the group of the Framework, the required architectures and configurations must be provided. In this case, the required architectures are <em>x64</em> for the simulator and <em>arm64</em> for the real devices. The configuration instead is <code>Debug</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>from(
</span></span><span style=display:flex><span>    iosArm64().binaries.getFramework(<span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#5af78e>&#34;Debug&#34;</span>),
</span></span><span style=display:flex><span>    iosX64().binaries.getFramework(<span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#5af78e>&#34;Debug&#34;</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>The last needed information is the destination of the framework.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>destinationDir = buildDir.resolve(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&#34;</span>)
</span></span></code></pre></div><p>The destination will be a CocoaPods repository that at the end is a git repository that contains the framework, the debug symbols, and a Podspec file.</p><figure><a href=/img/kmp-existing-projects/cocoa-repo-git.png><img src=/img/kmp-existing-projects/cocoa-repo-git.png alt="An example of a CocoaPod repo hosted on a git repo"></a><figcaption><p>An example of a CocoaPod repo hosted on a git repo</p></figcaption></figure><p>The git repository uses branches and tagging for handling debug and release versions. The debug versions of the Framework are pushed directly to the develop branch without any tagging. The release version instead is pushed on master and tagged.</p><p>For more information about setting up a private CocoaPod repo, I suggest you give a look at the <a href=https://guides.cocoapods.org/making/private-cocoapods.html>official documentation</a>.</p><p>After pushing the changes on git, the Pod library is ready to be pulled by XCode. On the <code>Podfile</code> of the iOs project, is necessary to specify the Pod library with the information about the source and the version.</p><p>For debug releases, it is enough to specify to pull the latest version from the <code>develop</code> branch</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pod <span style=color:#5af78e>&#39;&lt;your-library-name&gt;&#39;</span>, <span style=color:#5af78e>:git</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&#34;git@github.com:&lt;git-username&gt;/&lt;repo-name&gt;.git&#34;</span>, <span style=color:#5af78e>:branch</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&#39;develop&#39;</span>
</span></span></code></pre></div><p>For production releases instead, it is better to specify the required version number.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>pod <span style=color:#5af78e>&#39;&lt;your-library-name&gt;&#39;</span>, <span style=color:#5af78e>:git</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&#34;git@github.com:&lt;git-username&gt;/&lt;repo-name&gt;.git&#34;</span>, <span style=color:#5af78e>:tag</span> <span style=color:#ff6ac1>=&gt;</span> <span style=color:#5af78e>&#39;&lt;version-number&gt;&#39;</span>
</span></span></code></pre></div><p>The last step is building another Gradle task, to build a release version of the Fat Framework.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>tasks {
</span></span><span style=display:flex><span>    register(<span style=color:#5af78e>&#34;universalFrameworkRelease&#34;</span>, org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>) {
</span></span><span style=display:flex><span>        baseName = libName
</span></span><span style=display:flex><span>        from(
</span></span><span style=display:flex><span>            iosArm64().binaries.getFramework(<span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#5af78e>&#34;Release&#34;</span>),
</span></span><span style=display:flex><span>            iosX64().binaries.getFramework(<span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>, <span style=color:#5af78e>&#34;Release&#34;</span>)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        destinationDir = buildDir.resolve(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>        group = <span style=color:#5af78e>&#34;&lt;your-library-name&gt;&#34;</span>
</span></span><span style=display:flex><span>        description = <span style=color:#5af78e>&#34;Create the debug fat framework for iOs&#34;</span>
</span></span><span style=display:flex><span>        dependsOn(<span style=color:#5af78e>&#34;link&lt;your-library-name&gt;ReleaseFrameworkIosArm64&#34;</span>)
</span></span><span style=display:flex><span>        dependsOn(<span style=color:#5af78e>&#34;link&lt;your-library-name&gt;ReleaseFrameworkIosX64&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}        
</span></span></code></pre></div><p>The script is the same as the previous one, with the exception that the target is changed from <code>Debug</code> to <code>Release</code>.</p><p>And, that’s it! Finally, it is possible to start using the KMP library on iOS as well.</p><p>However, there is room for improvement and I wanted to minimize the effort of publishing. All the steps for publishing the framework in the CocoaPods repository can be automated with a Gradle task.</p><p>The <code>publishDevFramework</code> task will build the framework and automatically publish the changes in the develop branch of the CocoaPods repository.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>tasks {
</span></span><span style=display:flex><span>    register(<span style=color:#5af78e>&#34;publishDevFramework&#34;</span>) {
</span></span><span style=display:flex><span>        description = <span style=color:#5af78e>&#34;Publish iOs framweork to the Cocoa Repo&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        project.exec {
</span></span><span style=display:flex><span>            workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>            commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;checkout&#34;</span>, <span style=color:#5af78e>&#34;develop&#34;</span>).standardOutput
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        dependsOn(<span style=color:#5af78e>&#34;universalFrameworkDebug&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        doLast {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> dir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> tempFile = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec.new&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> reader = dir.bufferedReader()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> writer = tempFile.bufferedWriter()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>var</span> currentLine: String?
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>while</span> (reader.readLine().also { currLine <span style=color:#ff6ac1>-&gt;</span> currentLine = currLine } <span style=color:#ff6ac1>!=</span> <span style=color:#ff6ac1>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (currentLine<span style=color:#ff6ac1>?.</span>startsWith(<span style=color:#5af78e>&#34;s.version&#34;</span>) <span style=color:#ff6ac1>==</span> <span style=color:#ff6ac1>true</span>) {
</span></span><span style=display:flex><span>                    writer.write(<span style=color:#5af78e>&#34;s.version       = </span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span> + System.lineSeparator())
</span></span><span style=display:flex><span>                } <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>                    writer.write(currentLine + System.lineSeparator())
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            writer.close()
</span></span><span style=display:flex><span>            reader.close()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> successful = tempFile.renameTo(dir)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (successful) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>val</span> dateFormatter = SimpleDateFormat(<span style=color:#5af78e>&#34;dd/MM/yyyy - HH:mm&#34;</span>, Locale.getDefault())
</span></span><span style=display:flex><span>                project.exec {
</span></span><span style=display:flex><span>                    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>                    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;commit&#34;</span>, <span style=color:#5af78e>&#34;-a&#34;</span>, <span style=color:#5af78e>&#34;-m&#34;</span>, <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>New dev release: </span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>-</span><span style=color:#5af78e>${dateFormatter.format(Date())}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span>).standardOutput
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                project.exec {
</span></span><span style=display:flex><span>                    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>                    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;push&#34;</span>, <span style=color:#5af78e>&#34;origin&#34;</span>, <span style=color:#5af78e>&#34;develop&#34;</span>).standardOutput
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First of all, the task changes the working branch and then builds the debug framework.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;checkout&#34;</span>, <span style=color:#5af78e>&#34;develop&#34;</span>).standardOutput
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dependsOn(<span style=color:#5af78e>&#34;universalFrameworkDebug&#34;</span>)
</span></span></code></pre></div><p>Before publishing the new version, the version name inside the Podspec file must be updated.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#ff6ac1>...</span>
</span></span><span style=display:flex><span>s<span style=color:#ff6ac1>.</span>name          <span style=color:#ff6ac1>=</span> <span style=color:#5af78e>&#34;&lt;your-library-name&#34;</span>
</span></span><span style=display:flex><span>s<span style=color:#ff6ac1>.</span>version       <span style=color:#ff6ac1>=</span> <span style=color:#5af78e>&#34;&lt;version-name&gt;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>...</span>
</span></span></code></pre></div><p>And this is done automatically by the task.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> dir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span><span style=color:#ff6ac1>if</span> (currentLine<span style=color:#ff6ac1>?.</span>startsWith(<span style=color:#5af78e>&#34;s.version&#34;</span>) <span style=color:#ff6ac1>==</span> <span style=color:#ff6ac1>true</span>) {
</span></span><span style=display:flex><span>    writer.write(<span style=color:#5af78e>&#34;s.version       = </span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span> + System.lineSeparator())
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>And at the end, the new changes are committed and published into the develop branch of the repository.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> dateFormatter = SimpleDateFormat(<span style=color:#5af78e>&#34;dd/MM/yyyy - HH:mm&#34;</span>, Locale.getDefault())
</span></span><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;commit&#34;</span>, <span style=color:#5af78e>&#34;-a&#34;</span>, <span style=color:#5af78e>&#34;-m&#34;</span>, <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>New dev release: </span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>-</span><span style=color:#5af78e>${dateFormatter.format(Date())}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span>).standardOutput
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;push&#34;</span>, <span style=color:#5af78e>&#34;origin&#34;</span>, <span style=color:#5af78e>&#34;develop&#34;</span>).standardOutput
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To publish a release version of the Framework, there is the <code>publishFramework</code> task.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>tasks {
</span></span><span style=display:flex><span>    register(<span style=color:#5af78e>&#34;publishFramework&#34;</span>) {
</span></span><span style=display:flex><span>        description = <span style=color:#5af78e>&#34;Publish iOs framework to the Cocoa Repo&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        project.exec {
</span></span><span style=display:flex><span>            workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>            commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;checkout&#34;</span>, <span style=color:#5af78e>&#34;master&#34;</span>).standardOutput
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        dependsOn(<span style=color:#5af78e>&#34;universalFrameworkRelease&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        doLast {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> dir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> tempFile = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;/&lt;your-library-name&gt;.podspec.new&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> reader = dir.bufferedReader()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> writer = tempFile.bufferedWriter()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>var</span> currentLine: String?
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>while</span> (reader.readLine().also { currLine <span style=color:#ff6ac1>-&gt;</span> currentLine = currLine } <span style=color:#ff6ac1>!=</span> <span style=color:#ff6ac1>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (currentLine<span style=color:#ff6ac1>?.</span>startsWith(<span style=color:#5af78e>&#34;s.version&#34;</span>) <span style=color:#ff6ac1>==</span> <span style=color:#ff6ac1>true</span>) {
</span></span><span style=display:flex><span>                    writer.write(<span style=color:#5af78e>&#34;s.version       = </span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span> + System.lineSeparator())
</span></span><span style=display:flex><span>                } <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>                    writer.write(currentLine + System.lineSeparator())
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            writer.close()
</span></span><span style=display:flex><span>            reader.close()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> successful = tempFile.renameTo(dir)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (successful) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                project.exec {
</span></span><span style=display:flex><span>                    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>                    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;commit&#34;</span>, <span style=color:#5af78e>&#34;-a&#34;</span>, <span style=color:#5af78e>&#34;-m&#34;</span>, <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>New release: </span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span>).standardOutput
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                project.exec {
</span></span><span style=display:flex><span>                    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>                    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;tag&#34;</span>, libVersionName).standardOutput
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>                project.exec {
</span></span><span style=display:flex><span>                    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>                    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;push&#34;</span>, <span style=color:#5af78e>&#34;origin&#34;</span>, <span style=color:#5af78e>&#34;master&#34;</span>, <span style=color:#5af78e>&#34;--tags&#34;</span>).standardOutput
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This task is very similar to the <code>publishDevFramework</code> task. First of all, since it is a release, the master branch will be used.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;checkout&#34;</span>, <span style=color:#5af78e>&#34;master&#34;</span>).standardOutput
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dependsOn(<span style=color:#5af78e>&#34;universalFrameworkRelease&#34;</span>)
</span></span></code></pre></div><p>Then, before publishing, the commit will be tagged to specify the version name of the release.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;commit&#34;</span>, <span style=color:#5af78e>&#34;-a&#34;</span>, <span style=color:#5af78e>&#34;-m&#34;</span>, <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>New release: </span><span style=color:#5af78e>${libVersionName}</span><span style=color:#5af78e>\&#34;</span><span style=color:#5af78e>&#34;</span>).standardOutput
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;&lt;fat-framework-destination&gt;&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;tag&#34;</span>, libVersionName).standardOutput
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>project.exec {
</span></span><span style=display:flex><span>    workingDir = File(<span style=color:#5af78e>&#34;</span><span style=color:#5af78e>$rootDir</span><span style=color:#5af78e>/../../hn-foundation-cocoa&#34;</span>)
</span></span><span style=display:flex><span>    commandLine(<span style=color:#5af78e>&#34;git&#34;</span>, <span style=color:#5af78e>&#34;push&#34;</span>, <span style=color:#5af78e>&#34;origin&#34;</span>, <span style=color:#5af78e>&#34;master&#34;</span>, <span style=color:#5af78e>&#34;--tags&#34;</span>).standardOutput
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And, that’s it! When the KMP library is ready to be published, three tasks can ben called:</p><ul><li><code>publish</code> to publish JVM and Android artifacts;</li><li><code>publishDevFramework</code> to publish a debug version of the iOs Framework;</li><li><code>publishFramework</code> to publish a release version of the iOs Framework.</li></ul><blockquote><p>Update: FatFrameworks seems not to be the “current state of the art” solution to distribute multiple architectures at the same time. In fact, Apple during <a href=https://developer.apple.com/videos/play/wwdc2019/416/>WWDC 2019</a> has introduced <a href=https://help.apple.com/xcode/mac/11.4/#/dev544efab96>XCFramework</a>, a binary that can contain multiple platform-specific variants (even for iOS and macOS at the same time). To understand how to integrate KMP into existing code, give a look at my <a href=https://www.marcogomiero.com/posts/2021/build-xcframework-kmp/>new article</a>.</p></blockquote><h2 id=conclusions>Conclusions</h2><p>As shown in this article, the process of integrating Kotlin Multiplatform in an existing project requires more work on the architecture side. That’s why is preferable to start sharing a feature that can be extracted gradually.</p><p>The framework to follow is:</p><blockquote><p>Start little and then go bigger.</p></blockquote><p>By starting little, it is possible to validate the process with a “contained” effort, and then, after the validation, it is possible to go bigger and start sharing more and more features. For example at Uniwhere, we started sharing the DTOs and after validating the process, we decided to share also the persistence layer with <a href=https://cashapp.github.io/sqldelight/>SQLDelight</a>.</p><p>All the code that I showed in this article came from <a href=https://github.com/prof18/shared-hn-android-ios-backend>a sample that I’ve published on GitHub</a> (if you are interested only in the custom Gradle task, <a href=https://github.com/prof18/shared-hn-android-ios-backend/blob/master/hn-foundation/build.gradle.kts#L99>click here</a>). This sample is composed of an Android app, an iOs app, and a backend that share some common code via a Kotlin Multiplatform library.</p><blockquote><p>Update: I’ve grouped all the tasks mentioned in the article in a Gradle plugin! To know more about it, give a look to <a href=https://www.marcogomiero.com/posts/2021/kmp-fatframework-cocoa-release/>this post</a>.</p></blockquote><h2 id=bonus>Bonus:</h2><p>I’ve spoke about this topic in a talk <a href=https://fosdem.org/2021/schedule/event/and_that_folks_is_how_we_shared_code/>in the Kotlin Dev Room at Fosdem 2021</a>.</p><p>Here’s the recording of the session:</p><span class=raw-html><br><video controls width=100%>
<source src=https://mirror.as35701.net/video.fosdem.org/2021/D.kotlin/and_that_folks_is_how_we_shared_code.webm type=video/webm></video></span><p>and the slides:</p><span class=raw-html><br></span><script async class=speakerdeck-embed data-id=e29e5d5369894442a23544dc6feb4b4c data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-69FZ1TLE7E","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>