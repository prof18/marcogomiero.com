<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Structuring a Ktor project | Marco Gomiero</title><meta name=keywords content><meta name=description content="SERIES: Building a backend with Ktor
 Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   It’s been a few months since I’ve started working with Ktor to build the backend of Revelop."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2021/ktor-project-structure/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-90975904-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Structuring a Ktor project"><meta property="og:description" content="SERIES: Building a backend with Ktor
 Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   It’s been a few months since I’ve started working with Ktor to build the backend of Revelop."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2021/ktor-project-structure/"><meta property="og:image" content="https://www.marcogomiero.com/img/profile.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-07T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/profile.webp"><meta name=twitter:title content="Structuring a Ktor project"><meta name=twitter:description content="SERIES: Building a backend with Ktor
 Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   It’s been a few months since I’ve started working with Ktor to build the backend of Revelop."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Structuring a Ktor project","item":"https://www.marcogomiero.com/posts/2021/ktor-project-structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Structuring a Ktor project","name":"Structuring a Ktor project","description":"SERIES: Building a backend with Ktor\n Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   It’s been a few months since I’ve started working with Ktor to build the backend of Revelop.","keywords":[],"articleBody":"   SERIES: Building a backend with Ktor\n Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor   It’s been a few months since I’ve started working with Ktor to build the backend of Revelop. We decided to go with Ktor because it is a lightweight framework, easy to use and with a gentle learning curve even for a mobile developer.\nToday I decided to start a series of posts dedicated to Ktor. With these articles, I want to cover all the topics that made me struggle during development and that was not easy to achieve out of the box. To cite a few: using an in-memory database for testing, handling database migration, setting up logging on disk and using dependency injection.\nIn this first instance of the series, I will show how I’ve structured the Ktor project I’m working on. I’ll cover dependency injection, configurations, and testing.\nBut before moving on, a quick introduction about Ktor is mandatory.\n Ktor is an asynchronous framework for creating microservices, web applications, and more. It’s fun, free, and open source.\nFrom ktor.io\n Ktor is a lightweight framework that lets easily build backends, web applications, mobile and browser applications. It can be used to create both server and client-side applications (it is compatible with Kotlin Multiplatform as well). Ktor is highly configurable with extensions and it is possible to configure a custom pipeline through a Kotlin DSL. And finally, Ktor is truly asynchronous and uses Kotlin Coroutines to make the development easier without the callback hell.\nThis is “an elevator pitch” of Ktor, to know all the details I’ll suggest looking to the documentation.\nCreate a new Ktor Project The starting point of a Ktor project definitely lies in the wizard included in IntelliJ. The wizard lets you choose between all the different features that Ktor provides and it will generate a bare-bone project ready to be used.\n  If you don’t like IntelliJ, the wizard is also available on start.ktor.io.\n  The project that I built as a reference for this series contains a few set of features:\n Call Logging Content Negotiation kotlinx.serialization Locations Routing  The project is a simple backend that returns random Chuck Norris jokes. The jokes are saved in a database and they came from the Chuck Norris IO project.\nThe wizard creates a default Application.kt file that contains the module function that initializes the server pipeline, install the selected features, register the routes, etc. In this function, all the configurations and the classes needed to run the server must be provided or initialized.\nDependency Injection with Koin Before moving on, it is a good idea to setup Dependency Injection. I’ll use Koin, that has built-in support for Ktor.\n// Koin for Ktor implementation \"io.insert-koin:koin-ktor:$koin_version\" // SLF4J Logger implementation \"io.insert-koin:koin-logger-slf4j:$koin_version\" To use Koin, it is necessary to install the appropriate feature inside the module function. I recommend doing it as the first thing in the setup pipeline.\ninstall(Koin) { slf4jLogger() modules(appModule) } val appModule = module { single() single { JokeRepositoryImpl() } } The Koin module is defined in a separate file, just to keep the Application class and the Ktor module function as clean as possible.\nAfter that, the dependency graph is built, and inside Application, Routing and Route scope, it is possible to retrieve the dependencies like in a KoinComponent\nval myClass by inject() For more information about Koin on Ktor, refer to the documentation\nConfiguration On Ktor it is possible to set some configurations, like host address and port, in code (if using the embeddedServer) or in an external file (application.conf) with the HOCON format (if using the EngineMain).\nThe wizard automatically creates an application.conf file in the application resources directory.\nktor { deployment { port = 8080 port = ${?PORT} } application { modules = [com.prof18.ktor.chucknorris.sample.ApplicationKt.module] } } . └── src ├── main │ ├── kotlin │ │ └── com │ │ └── ... │ └── resources │ ├── application.conf └── test ├── kotlin │ └── com │ └── ... └── resources ├── ... This configuration file will be automatically loaded and parsed by Ktor when the server is started. It is also possible to provide a custom configuration file instead of the one from resources with a command-line argument:\njava -jar ktor-backend.jar -config=/config-folder/application.conf This is helpful for example to provide different configurations for databases or for external service (in part 3 I’ll show a use case of this feature).\nBut, besides the default value provided by the framework, it is possible to create custom configurations to use later in the code. For example, I’ve created a new section with a Boolean field that will indicate if the instance is running on a staging or production server.\nktor { ... server { isProd = false } ... } Every section will be mapped in the code with a data class\ndata class ServerConfig( val isProd: Boolean ) that is contained in a wider class, named AppConfig with all the different custom configurations.\nclass AppConfig { lateinit var serverConfig: ServerConfig // Place here other configurations } The fields of this class then will be initialized inside the Application scope.\nfun Application.setupConfig() { val appConfig by inject() // Server  val serverObject = environment.config.config(\"ktor.server\") val isProd = serverObject.property(\"isProd\").getString().toBoolean() appConfig.serverConfig = ServerConfig(isProd) } With this setup, when a configuration field must be accessed, the AppConfig class can be simply retrieved from Koin.\nProject structure The structure of a project is a completely subjective topic and it does not invalidate the functionalities nor the correct behavior. However, I think that properly structuring a project is beneficial for better maintainability and scalability.\nHere, I will share a structure that worked for me and that I found interesting. If you have any suggestion about alternative structures or if you notice something wrong in what I’m sharing, feel free to reach me out on Twitter @marcoGomier.\nSince the Application.kt file is the entrypoint for the server, I left it at the root level of the src  main  kotlin   folder.\nThen, I’ve created a bunch of folders that contain “configuration code”:\n di: it contains the code where the Koin modules are defined, as described above config: it contains the code that maps the configuration fields from the application.conf file, as described above database: it contains the code necessary to open (and close) the connection to the database. I’ll describe it in the next articles of the series.  . ├── Application.kt ├── config │ └── AppConfig.kt ├── database │ ├── DatabaseFactory.kt │ └── DatabaseFactoryImpl.kt ├── di └── AppModule.kt Then, I’ve created the features folder. This top-level folder contains, as the name suggests, all the different features of the backend. For example, if the backend provides a set of API calls to authenticate a user, to handle jokes (get, create, delete, etc), and to handle the user (logout, update some settings, etc) there will be three different folders:\n. ├── features ├── auth │ └── ... ├── jokes │ └── ... └── user └── ... In the sample project, the backend will provide only an API to get a random Joke, so there will be only a folder named jokes under the features folder.\nThe structure of every “feature folder” will follow some principles of the Clean Architecture. I’ve decided to stick with it because I’ve used it in some Android projects and I like it. But, this will be an adapted solution with only some aspects of the architecture. If you don’t know Clean Architecture and you want to know more about it, I suggest giving a look at the Uncle Bob’s article and, if you are an Android developer, to this Ray Wenderich’s article.\nThe layers of Clean Architecture that I’ve used here are 3:\n data domain presentation  The data layer contains the definitions of all the data sources. In this case, all the needed data are contained in the database, so there will be only code needed to interact with the database.\n└── jokes ├── data ├── JokeLocalDataSource.kt ├── JokeLocalDataSourceImpl.kt └── dao └── Joke.kt If the backend needs also to retrieve data from other APIs, here there will be also a remote data source.\n└── jokes └── data ├── local │ ├── JokeLocalDataSource.kt │ ├── JokeLocalDataSourceImpl.kt │ └── dao │ └── Joke.kt └── remote ├── JokeRemoteDataSource.kt ├── JokeRemoteDataSourceImpl.kt └── dto └── JokeRemoteDTO.kt The domain layer contains the models, the business logic, and the mappers between the DAOs and the DTOs. The business logic is implemented by following the Repository pattern. The repository will contain the code necessary to retrieve, save and manipulate data from the data sources.\n└── jokes ├── domain ├── JokeRepository.kt ├── JokeRepositoryImpl.kt ├── mapper │ └── DTOMapper.kt └── model └── JokeDTO.kt And at the end, the presentation layer. Since this is not an application with a user interface, I decided to change the name from presentation to resource. In this layer, there will be the definitions of the REST endpoints that the backend exposes. I’ve decided to use the word resource because I like to think that REST endpoints are resources that give or handle data. This is just a personal opinion, for example, you can call these layer `controller or whatever.\n└── jokes └── resource └── JokeResource.kt The JokeResource file will contain the classes that define each route and an extension function of Route that contains the definition of every endpoint.\n@Location(\"joke\") class JokeEndpoint { @Location(\"/random\") class Random(val parent: JokeEndpoint) } fun Route.jokeEndpoint() { val jokeRepository by inject() get { call.respond(jokeRepository.getRandomJoke()) } } Using an extension function, unlock the possibility to have a much cleaner module function: in this way, it is possible to define the endpoints in different files and call them inside the routing block in the module function.\nfun Application.module(...) { ... routing { jokeEndpoint() ... } ... } And as reference, here’s the entire structure that I’ve described:\n. └── sample ├── Application.kt ├── config │ └── AppConfig.kt ├── database │ ├── DatabaseFactory.kt │ └── DatabaseFactoryImpl.kt ├── di │ └── AppModule.kt └── features └── jokes ├── data │ ├── JokeLocalDataSource.kt │ ├── JokeLocalDataSourceImpl.kt │ └── dao │ └── Joke.kt ├── domain │ ├── JokeRepository.kt │ ├── JokeRepositoryImpl.kt │ ├── mapper │ │ └── DTOMapper.kt │ └── model │ └── JokeDTO.kt └── resource └── JokeResource.kt Testing And last but not least, testing. Ktor is designed to allow easily testable applications. It does not create a web server but it hooks directly into the internal mechanism with a TestEngine. In this way, the execution of tests will be quicker rather than spinning up a complete web server for testing.\nWith the withTestApplication function it is possible to set up a test environment and then, with the handleRequest function it is possible to perform the request and verify that the results are the same as expected.\n@Test fun testRequests() = withTestApplication(module(testing = true)) { with(handleRequest(HttpMethod.Get, \"/\")) { assertEquals(HttpStatusCode.OK, response.status()) assertEquals(\"Hello from Ktor Testable sample application\", response.content) } } However, before testing the endpoints, it is necessary to set up the dependencies that the system under test will use and all the custom configurations defined in the application.conf.\nTo populate the configurations, the MapApplicationConfig can be used and passed to the withTestApplication function.\nfun MapApplicationConfig.createConfigForTesting() { // Server config  put(\"ktor.server.isProd\", \"false\") } @Test fun testRequests() = withTestApplication({ (environment.config as MapApplicationConfig).apply { createConfigForTesting() } module(testing = true) // Call here your application's module }) { ... } The dependencies instead will be automatically provided by Koin. But, to provide a fake implementation of a dependency, some changes must be made.\nAs described above, the Koin module is ”hardcoded” inside the Ktor module function (to be precise is defined in another file but not injected in the constructor).\ninstall(Koin) { slf4jLogger() modules(appModule) } To modify the Koin module during testing, I’ve modified the Ktor module function to accept a list of Koin modules. This list has as the default value the Koin module that was previously hardcoded.\nfun Application.module(testing: Boolean = false, koinModules: List = listOf(appModule)) { install(Koin) { slf4jLogger() modules(koinModules) } } In this way, during testing, it is possible to change one or more dependencies.\nval appTestModule = module { single() single { DatabaseFactoryForServerTest() } single { JokeLocalDataSourceImpl() } } val fakeRepositoryModule = module { single { FakeJokeRepository() } } @Test fun testRequests() = withTestApplication({ (environment.config as MapApplicationConfig).apply { createConfigForTesting() } module(testing = true, koinModules = listOf(appTestModule, fakeRepositoryModule)) }) { ... } Conclusion Although it seems a boring task, structuring a project is a very important thing. In fact, starting with an unsafe foundation will put your product in danger, making it unscalable and hard to maintain throughout the time. However, there isn’t a right way to structure a project because every project is different and has different needs. What I suggest to do, is to find the right solution for your needs and the structure that I’ve shared here is the one that satisfied me.\nAnd that’s it for today. You can find the code mentioned in the article on GitHub.\nIn the next episodes, I’ll cover logging and databases. You can follow me on Twitter to know when I’ll publish the next episode.\n","wordCount":"2220","inLanguage":"en","datePublished":"2021-04-07T00:00:00Z","dateModified":"2021-04-07T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2021/ktor-project-structure/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Structuring a Ktor project</h1><div class=post-meta style=margin-top:16px><span title="2021-04-07 00:00:00 +0000 UTC">7 April 2021</span>&nbsp;·&nbsp;11 min</div></header><div class=post-content><a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=b99d6298aa"><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23245-%237874b4></a><blockquote><p><strong>SERIES: Building a backend with Ktor</strong></p><ul><li>Part 1: Structuring a Ktor project</li><li>Part 2: <a href=https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/>How to persist Ktor logs</a></li><li>Part 3: <a href=https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/>How to use an in-memory database for testing on Ktor</a></li><li>Part 4: <a href=https://www.marcogomiero.com/posts/2022/ktor-migration-liquibase/>How to handle database migrations with Liquibase on Ktor</a></li><li>Part 5 <a href=https://www.marcogomiero.com/posts/2022/ktor-setup-documentation/>Generate API documentation from Swagger on Ktor</a></li><li>Part 6: <a href=https://www.marcogomiero.com/posts/2022/ktor-jobs-quartz/>How to schedule jobs with Quartz on Ktor</a></li></ul></blockquote><p>It’s been a few months since I’ve started working with <a href=https://ktor.io/>Ktor</a> to build the backend of <a href=https://revelop.app/>Revelop</a>. We decided to go with Ktor because it is a lightweight framework, easy to use and with a gentle learning curve even for a mobile developer.</p><p>Today I decided to start a series of posts dedicated to Ktor. With these articles, I want to cover all the topics that made me struggle during development and that was not easy to achieve out of the box. To cite a few: using an in-memory database for testing, handling database migration, setting up logging on disk and using dependency injection.</p><p>In this first instance of the series, I will show how I’ve structured the Ktor project I&rsquo;m working on. I’ll cover dependency injection, configurations, and testing.</p><p>But before moving on, a quick introduction about Ktor is mandatory.</p><blockquote><p>Ktor is an asynchronous framework for creating microservices, web applications, and more. It’s fun, free, and open source.</p><p>From <a href=https://ktor.io/>ktor.io</a></p></blockquote><p>Ktor is a lightweight framework that lets easily build backends, web applications, mobile and browser applications. It can be used to create both server and client-side applications (it is compatible with Kotlin Multiplatform as well). Ktor is highly configurable with extensions and it is possible to configure a custom pipeline through a Kotlin DSL. And finally, Ktor is truly asynchronous and uses Kotlin Coroutines to make the development easier without the callback hell.</p><p>This is “an elevator pitch” of Ktor, to know all the details I’ll suggest looking <a href=https://ktor.io/docs/welcome.html>to the documentation</a>.</p><h2 id=create-a-new-ktor-project>Create a new Ktor Project<a hidden class=anchor aria-hidden=true href=#create-a-new-ktor-project>#</a></h2><p>The starting point of a Ktor project definitely lies in the wizard included in IntelliJ. The wizard lets you choose between all the different features that Ktor provides and it will generate a bare-bone project ready to be used.</p><figure><a href=/img/ktor-series/ktor-wizard-Intellij.png><img loading=lazy src=/img/ktor-series/ktor-wizard-Intellij.png></a></figure><p>If you don’t like IntelliJ, the wizard is also available on <a href=https://start.ktor.io/>start.ktor.io</a>.</p><figure><a href=/img/ktor-series/ktor-web-wizard.png><img loading=lazy src=/img/ktor-series/ktor-web-wizard.png></a></figure><p>The project that I built as a reference for this series contains a few set of features:</p><ul><li>Call Logging</li><li>Content Negotiation</li><li>kotlinx.serialization</li><li>Locations</li><li>Routing</li></ul><p>The project is a simple backend that returns random Chuck Norris jokes. The jokes are saved in a database and they came from the <a href=https://github.com/chucknorris-io/chuck-db>Chuck Norris IO project</a>.</p><p>The wizard creates a default <code>Application.kt</code> file that contains the <a href=https://ktor.io/docs/modules.html><code>module</code></a> function that initializes the server pipeline, install the selected features, register the routes, etc. In this function, all the configurations and the classes needed to run the server must be provided or initialized.</p><h2 id=dependency-injection-with-koin>Dependency Injection with Koin<a hidden class=anchor aria-hidden=true href=#dependency-injection-with-koin>#</a></h2><p>Before moving on, it is a good idea to setup Dependency Injection. I’ll use <strong><a href=https://insert-koin.io>Koin</a></strong>, that has built-in support for Ktor.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// Koin for Ktor
</span><span style=color:#75715e></span>implementation <span style=color:#e6db74>&#34;io.insert-koin:koin-ktor:</span><span style=color:#e6db74>$koin_version</span><span style=color:#e6db74>&#34;</span>
<span style=color:#75715e>// SLF4J Logger
</span><span style=color:#75715e></span>implementation <span style=color:#e6db74>&#34;io.insert-koin:koin-logger-slf4j:</span><span style=color:#e6db74>$koin_version</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>To use Koin, it is necessary to install the appropriate feature inside the <code>module</code> function. I recommend doing it as the first thing in the setup pipeline.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>install(Koin) {
    slf4jLogger()
    modules(appModule)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> appModule = module {
    single&lt;MyClass&gt;()
    single&lt;JokeRepository&gt; { JokeRepositoryImpl() }
}
</code></pre></div><p>The Koin module is defined in a separate file, just to keep the <code>Application</code> class and the Ktor <code>module</code> function as clean as possible.</p><p>After that, the dependency graph is built, and inside <code>Application</code>, <code>Routing</code> and <code>Route</code> scope, it is possible to retrieve the dependencies like in a <code>KoinComponent</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> myClass <span style=color:#66d9ef>by</span> inject&lt;MyClass&gt;()
</code></pre></div><p>For more information about Koin on Ktor, refer to the <a href=https://insert-koin.io/docs/reference/koin-ktor/ktor/>documentation</a></p><h2 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h2><p>On Ktor it is possible to <a href=https://ktor.io/docs/configurations.html>set some configurations</a>, like host address and port, in code (if using the <a href=https://ktor.io/docs/create-server.html#embedded-server><code>embeddedServer</code></a>) or in an external file (<code>application.conf</code>) with the HOCON format (if using the <a href=https://ktor.io/docs/create-server.html#engine-main><code>EngineMain</code></a>).</p><p>The wizard automatically creates an <code>application.conf</code> file in the application <code>resources</code> directory.</p><pre><code class=language-hocon data-lang=hocon>ktor {
  deployment {
    port = 8080
    port = ${?PORT}
  }
  application {
    modules = [com.prof18.ktor.chucknorris.sample.ApplicationKt.module]
  }
}
</code></pre><pre><code>.
└── src
    ├── main
    │   ├── kotlin
    │   │   └── com
    │   │       └── ...
    │   └── resources
    │       ├── application.conf
    └── test
        ├── kotlin
        │   └── com
        │       └── ...
        └── resources
            ├──  ...

</code></pre><p>This configuration file will be automatically loaded and parsed by Ktor when the server is started. It is also possible to provide a custom configuration file instead of the one from resources with a command-line argument:</p><pre><code>java -jar ktor-backend.jar -config=/config-folder/application.conf
</code></pre><p>This is helpful for example to provide different configurations for databases or for external service (in part 3 I’ll show a use case of this feature).</p><p>But, besides the <a href=https://ktor.io/docs/configurations.html#hocon-file>default value provided by the framework</a>, it is possible to create custom configurations to use later in the code.
For example, I’ve created a new section with a Boolean field that will indicate if the instance is running on a staging or production server.</p><pre><code class=language-hocon data-lang=hocon>ktor {
  ...
  server {
    isProd = false
  }
  ...
}
</code></pre><p>Every section will be mapped in the code with a <code>data class</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerConfig</span>(
    <span style=color:#66d9ef>val</span> isProd: Boolean
)
</code></pre></div><p>that is contained in a wider class, named <code>AppConfig</code> with all the different custom configurations.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppConfig</span> {
    <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> serverConfig: ServerConfig
    <span style=color:#75715e>// Place here other configurations
</span><span style=color:#75715e></span>}
</code></pre></div><p>The fields of this class then will be initialized inside the <code>Application</code> scope.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Application</span>.setupConfig() {
    <span style=color:#66d9ef>val</span> appConfig <span style=color:#66d9ef>by</span> inject&lt;AppConfig&gt;()

    <span style=color:#75715e>// Server
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> serverObject = environment.config.config(<span style=color:#e6db74>&#34;ktor.server&#34;</span>)
    <span style=color:#66d9ef>val</span> isProd = serverObject.<span style=color:#66d9ef>property</span>(<span style=color:#e6db74>&#34;isProd&#34;</span>).getString().toBoolean()
    appConfig.serverConfig = ServerConfig(isProd)
}
</code></pre></div><p>With this setup, when a configuration field must be accessed, the AppConfig class can be simply retrieved from Koin.</p><h2 id=project-structure>Project structure<a hidden class=anchor aria-hidden=true href=#project-structure>#</a></h2><p>The structure of a project is a completely subjective topic and it does not invalidate the functionalities nor the correct behavior. However, I think that properly structuring a project is beneficial for better maintainability and scalability.</p><p>Here, I will share a structure that worked for me and that I found interesting. If you have any suggestion about alternative structures or if you notice something wrong in what I’m sharing, feel free to reach me out on Twitter <a href=https://twitter.com/marcoGomier>@marcoGomier</a>.</p><p>Since the <code>Application.kt</code> file is the entrypoint for the server, I left it at the root level of the <code>src > main > kotlin > &lt;package-name></code> folder.</p><p>Then, I’ve created a bunch of folders that contain “configuration code”:</p><ul><li><code>di</code>: it contains the code where the <code>Koin</code> modules are defined, <a href=#dependency-injection-with-koin>as described above</a></li><li><code>config</code>: it contains the code that maps the configuration fields from the <code>application.conf</code> file, <a href=#configuration>as described above</a></li><li><code>database</code>: it contains the code necessary to open (and close) the connection to the database. I’ll describe it in the next articles of the series.</li></ul><pre><code>.
├── Application.kt
├── config
│   └── AppConfig.kt
├── database
│   ├── DatabaseFactory.kt
│   └── DatabaseFactoryImpl.kt
├── di
    └── AppModule.kt
</code></pre><p>Then, I’ve created the <code>features</code> folder. This top-level folder contains, as the name suggests, all the different features of the backend. For example, if the backend provides a set of API calls to authenticate a user, to handle jokes (get, create, delete, etc), and to handle the user (logout, update some settings, etc) there will be three different folders:</p><pre><code>.
├── features
    ├── auth
    │   └── ...
    ├── jokes
    │   └── ...
    └── user
        └── ...
</code></pre><p>In the sample project, the backend will provide only an API to get a random Joke, so there will be only a folder named <code>jokes</code> under the <code>features</code> folder.</p><p>The structure of every “feature folder” will follow some principles of the <strong>Clean Architecture</strong>. I’ve decided to stick with it because I’ve used it in some Android projects and I like it. But, this will be an adapted solution with only some aspects of the architecture. If you don’t know Clean Architecture and you want to know more about it, I suggest giving a look at the <a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Uncle Bob’s article</a> and, if you are an Android developer, to this <a href=https://www.raywenderlich.com/3595916-clean-architecture-tutorial-for-android-getting-started>Ray Wenderich’s article</a>.</p><p>The layers of Clean Architecture that I’ve used here are 3:</p><ul><li>data</li><li>domain</li><li>presentation</li></ul><p>The <strong>data layer</strong> contains the definitions of all the data sources. In this case, all the needed data are contained in the database, so there will be only code needed to interact with the database.</p><pre><code>└── jokes
    ├── data
        ├── JokeLocalDataSource.kt
        ├── JokeLocalDataSourceImpl.kt
        └── dao
            └── Joke.kt
</code></pre><p>If the backend needs also to retrieve data from other APIs, here there will be also a remote data source.</p><pre><code>└── jokes
    └── data
        ├── local
        │   ├── JokeLocalDataSource.kt
	│   ├── JokeLocalDataSourceImpl.kt
	│   └── dao
	│       └── Joke.kt
        └── remote
            ├── JokeRemoteDataSource.kt
	    ├── JokeRemoteDataSourceImpl.kt
	    └── dto
	        └── JokeRemoteDTO.kt
</code></pre><p>The <strong>domain layer</strong> contains the models, the business logic, and the mappers between the DAOs and the DTOs. The business logic is implemented by following the Repository pattern. The repository will contain the code necessary to retrieve, save and manipulate data from the data sources.</p><pre><code>└── jokes
    ├── domain
        ├── JokeRepository.kt
        ├── JokeRepositoryImpl.kt
        ├── mapper
        │   └── DTOMapper.kt
        └── model
            └── JokeDTO.kt
</code></pre><p>And at the end, the <strong>presentation</strong> layer. Since this is not an application with a user interface, I decided to change the name from presentation to <strong>resource</strong>. In this layer, there will be the definitions of the REST endpoints that the backend exposes. I’ve decided to use the word <em>resource</em> because I like to think that REST endpoints are resources that give or handle data. This is just a personal opinion, for example, you can call these layer `<em>controller</em> or whatever.</p><pre><code>└── jokes
    └── resource
	└── JokeResource.kt
</code></pre><p>The <code>JokeResource</code> file will contain <a href=https://ktor.io/docs/features-locations.html#route-classes>the classes that define each route</a> and an extension function of <code>Route</code> that contains the definition of every endpoint.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@Location</span>(<span style=color:#e6db74>&#34;joke&#34;</span>)
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JokeEndpoint</span> {

    <span style=color:#a6e22e>@Location</span>(<span style=color:#e6db74>&#34;/random&#34;</span>)
    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Random</span>(<span style=color:#66d9ef>val</span> parent: JokeEndpoint)
}

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Route</span>.jokeEndpoint() {

    <span style=color:#66d9ef>val</span> jokeRepository <span style=color:#66d9ef>by</span> inject&lt;JokeRepository&gt;()

    <span style=color:#66d9ef>get</span>&lt;JokeEndpoint.Random&gt; {
        call.respond(jokeRepository.getRandomJoke())
    }
}
</code></pre></div><p>Using an extension function, unlock the possibility to have a much cleaner module function: in this way, it is possible to define the endpoints in different files and call them inside the <code>routing</code> block in the <code>module</code> function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Application</span>.module(<span style=color:#f92672>..</span>.) {
    <span style=color:#f92672>..</span>.
    routing {
        jokeEndpoint()
        <span style=color:#f92672>..</span>.
    }
    <span style=color:#f92672>..</span>.
}
</code></pre></div><p>And as reference, here’s the entire structure that I’ve described:</p><pre><code>.
└── sample
    ├── Application.kt
    ├── config
    │   └── AppConfig.kt
    ├── database
    │   ├── DatabaseFactory.kt
    │   └── DatabaseFactoryImpl.kt
    ├── di
    │   └── AppModule.kt
    └── features
        └── jokes
            ├── data
            │   ├── JokeLocalDataSource.kt
            │   ├── JokeLocalDataSourceImpl.kt
            │   └── dao
            │       └── Joke.kt
            ├── domain
            │   ├── JokeRepository.kt
            │   ├── JokeRepositoryImpl.kt
            │   ├── mapper
            │   │   └── DTOMapper.kt
            │   └── model
            │       └── JokeDTO.kt
            └── resource
                └── JokeResource.kt

</code></pre><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>And last but not least, testing. Ktor is designed to allow easily testable applications. It does not create a web server but it hooks directly into the internal mechanism with a <a href=https://ktor.io/docs/testing.html><code>TestEngine</code></a>. In this way, the execution of tests will be quicker rather than spinning up a complete web server for testing.</p><p>With the <code>withTestApplication</code> function it is possible to set up a test environment and then, with the <code>handleRequest</code> function it is possible to perform the request and verify that the results are the same as expected.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>testRequests</span>() = withTestApplication(module(testing = <span style=color:#66d9ef>true</span>)) {
    with(handleRequest(HttpMethod.Get, <span style=color:#e6db74>&#34;/&#34;</span>)) {
        assertEquals(HttpStatusCode.OK, response.status())
        assertEquals(<span style=color:#e6db74>&#34;Hello from Ktor Testable sample application&#34;</span>, response.content)
    }
}
</code></pre></div><p>However, before testing the endpoints, it is necessary to set up the dependencies that the system under test will use and all the custom configurations defined in the <code>application.conf</code>.</p><p>To populate the configurations, the <code>MapApplicationConfig</code> can be used and passed to the <code>withTestApplication</code> function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>MapApplicationConfig</span>.createConfigForTesting() {
    <span style=color:#75715e>// Server config
</span><span style=color:#75715e></span>    put(<span style=color:#e6db74>&#34;ktor.server.isProd&#34;</span>, <span style=color:#e6db74>&#34;false&#34;</span>)
}

<span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>testRequests</span>() = withTestApplication({
    (environment.config <span style=color:#66d9ef>as</span> MapApplicationConfig).apply {
       createConfigForTesting()
    }
    module(testing = <span style=color:#66d9ef>true</span>) <span style=color:#75715e>// Call here your application&#39;s module
</span><span style=color:#75715e></span>}) {
    <span style=color:#f92672>..</span>.
}
</code></pre></div><p>The dependencies instead will be automatically provided by Koin. But, to provide a fake implementation of a dependency, some changes must be made.</p><p><a href=#dependency-injection-with-koin>As described above</a>, the Koin module is ”hardcoded” inside the Ktor module function (to be precise is defined in another file but not injected in the constructor).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>install(Koin) {
    slf4jLogger()
    modules(appModule)
}
</code></pre></div><p>To modify the Koin module during testing, I’ve modified the Ktor <code>module</code> function to accept a list of Koin modules. This list has as the default value the Koin module that was previously hardcoded.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Application</span>.module(testing: Boolean = <span style=color:#66d9ef>false</span>, koinModules: List&lt;Module&gt; = listOf(appModule)) {
    install(Koin) {
        slf4jLogger()
        modules(koinModules)
    }
}
</code></pre></div><p>In this way, during testing, it is possible to change one or more dependencies.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> appTestModule = module {
    single&lt;AppConfig&gt;()
    single&lt;DatabaseFactory&gt; { DatabaseFactoryForServerTest() }
    single&lt;JokeLocalDataSource&gt; { JokeLocalDataSourceImpl() }
}

<span style=color:#66d9ef>val</span> fakeRepositoryModule = module {
    single&lt;JokeRepository&gt; { FakeJokeRepository() }
}

<span style=color:#a6e22e>@Test</span>
<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>testRequests</span>() = withTestApplication({
    (environment.config <span style=color:#66d9ef>as</span> MapApplicationConfig).apply {
       createConfigForTesting()
    }
    module(testing = <span style=color:#66d9ef>true</span>, koinModules = listOf(appTestModule, fakeRepositoryModule))
}) {
    <span style=color:#f92672>..</span>.
}
</code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Although it seems a boring task, structuring a project is a very important thing. In fact, starting with an unsafe foundation will put your product in danger, making it unscalable and hard to maintain throughout the time.
However, there isn’t a right way to structure a project because every project is different and has different needs. What I suggest to do, is to find the right solution <strong>for your needs</strong> and the structure that I’ve shared here is the one that satisfied me.</p><p>And that’s it for today. You can find the code mentioned in the article on <a href=https://github.com/prof18/ktor-chuck-norris-sample/tree/part1>GitHub</a>.</p><p>In the next episodes, I’ll cover logging and databases. You can follow me on <a href=https://twitter.com/marcoGomier>Twitter</a> to know when I’ll publish the next episode.</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/><span class=title>« Prev</span><br><span>How to persist Ktor logs</span></a>
<a class=next href=https://www.marcogomiero.com/posts/2021/audio-video-setup/><span class=title>Next »</span><br><span>My audio & video setup after 4 years of remote working</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>