<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Structuring a Ktor project - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="SERIES: Building a backend with Ktor
Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor Part 7: Moving from mobile to backend development with Ktor It’s been a few months since I’ve started working with Ktor to build the backend of Revelop."><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:title" content="Structuring a Ktor project"><meta property="og:description" content="SERIES: Building a backend with Ktor
Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor Part 7: Moving from mobile to backend development with Ktor It’s been a few months since I’ve started working with Ktor to build the backend of Revelop."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2021/ktor-project-structure/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-07T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structuring a Ktor project"><meta name=twitter:description content="SERIES: Building a backend with Ktor
Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Part 3: How to use an in-memory database for testing on Ktor Part 4: How to handle database migrations with Liquibase on Ktor Part 5 Generate API documentation from Swagger on Ktor Part 6: How to schedule jobs with Quartz on Ktor Part 7: Moving from mobile to backend development with Ktor It’s been a few months since I’ve started working with Ktor to build the backend of Revelop."><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><script src=https://www.marcogomiero.com/js/feather.min.js></script>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.2d1f13dc82ea2d94683809543a326af8a9a1f3a6c000f7b7af5d8f02a2e6ec25.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write</span></a>
<a href=/talks/><span>Speak</span></a>
<a href=/projects/><span>Build</span></a>
<a href=/about-me/><span>About</span></a>
| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Structuring a Ktor project</h1><div class=post-meta><span title='2021-04-07 00:00:00 +0000 UTC'>7 April 2021</span></div></div><section class=body><span class=raw-html><a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=b99d6298aa"><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23245-%237874b4></a></span><blockquote><p><strong>SERIES: Building a backend with Ktor</strong></p><ul><li>Part 1: Structuring a Ktor project</li><li>Part 2: <a href=https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/>How to persist Ktor logs</a></li><li>Part 3: <a href=https://www.marcogomiero.com/posts/2021/ktor-in-memory-db-testing/>How to use an in-memory database for testing on Ktor</a></li><li>Part 4: <a href=https://www.marcogomiero.com/posts/2022/ktor-migration-liquibase/>How to handle database migrations with Liquibase on Ktor</a></li><li>Part 5 <a href=https://www.marcogomiero.com/posts/2022/ktor-setup-documentation/>Generate API documentation from Swagger on Ktor</a></li><li>Part 6: <a href=https://www.marcogomiero.com/posts/2022/ktor-jobs-quartz/>How to schedule jobs with Quartz on Ktor</a></li><li>Part 7: <a href=https://www.marcogomiero.com/posts/2022/backend-from-mobile-ktor/>Moving from mobile to backend development with Ktor</a></li></ul></blockquote><p>It’s been a few months since I’ve started working with <a href=https://ktor.io/>Ktor</a> to build the backend of <a href=https://revelop.app/>Revelop</a>. We decided to go with Ktor because it is a lightweight framework, easy to use and with a gentle learning curve even for a mobile developer.</p><p>Today I decided to start a series of posts dedicated to Ktor. With these articles, I want to cover all the topics that made me struggle during development and that was not easy to achieve out of the box. To cite a few: using an in-memory database for testing, handling database migration, setting up logging on disk and using dependency injection.</p><p>In this first instance of the series, I will show how I’ve structured the Ktor project I&rsquo;m working on. I’ll cover dependency injection, configurations, and testing.</p><p>But before moving on, a quick introduction about Ktor is mandatory.</p><blockquote><p>Ktor is an asynchronous framework for creating microservices, web applications, and more. It’s fun, free, and open source.</p><p>From <a href=https://ktor.io/>ktor.io</a></p></blockquote><p>Ktor is a lightweight framework that lets easily build backends, web applications, mobile and browser applications. It can be used to create both server and client-side applications (it is compatible with Kotlin Multiplatform as well). Ktor is highly configurable with extensions and it is possible to configure a custom pipeline through a Kotlin DSL. And finally, Ktor is truly asynchronous and uses Kotlin Coroutines to make the development easier without the callback hell.</p><p>This is “an elevator pitch” of Ktor, to know all the details I’ll suggest looking <a href=https://ktor.io/docs/welcome.html>to the documentation</a>.</p><h2 id=create-a-new-ktor-project>Create a new Ktor Project</h2><p>The starting point of a Ktor project definitely lies in the wizard included in IntelliJ. The wizard lets you choose between all the different features that Ktor provides and it will generate a bare-bone project ready to be used.</p><figure><a href=/img/ktor-series/ktor-wizard-Intellij.png><img src=/img/ktor-series/ktor-wizard-Intellij.png></a></figure><p>If you don’t like IntelliJ, the wizard is also available on <a href=https://start.ktor.io/>start.ktor.io</a>.</p><figure><a href=/img/ktor-series/ktor-web-wizard.png><img src=/img/ktor-series/ktor-web-wizard.png></a></figure><p>The project that I built as a reference for this series contains a few set of features:</p><ul><li>Call Logging</li><li>Content Negotiation</li><li>kotlinx.serialization</li><li>Locations</li><li>Routing</li></ul><p>The project is a simple backend that returns random Chuck Norris jokes. The jokes are saved in a database and they came from the <a href=https://github.com/chucknorris-io/chuck-db>Chuck Norris IO project</a>.</p><p>The wizard creates a default <code>Application.kt</code> file that contains the <a href=https://ktor.io/docs/modules.html><code>module</code></a> function that initializes the server pipeline, install the selected features, register the routes, etc. In this function, all the configurations and the classes needed to run the server must be provided or initialized.</p><h2 id=dependency-injection-with-koin>Dependency Injection with Koin</h2><p>Before moving on, it is a good idea to setup Dependency Injection. I’ll use <strong><a href=https://insert-koin.io>Koin</a></strong>, that has built-in support for Ktor.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Koin for Ktor
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>implementation <span style=color:#5af78e>&#34;io.insert-koin:koin-ktor:</span><span style=color:#5af78e>$koin</span><span style=color:#5af78e>_version&#34;</span>
</span></span><span style=display:flex><span><span style=color:#78787e>// SLF4J Logger
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>implementation <span style=color:#5af78e>&#34;io.insert-koin:koin-logger-slf4j:</span><span style=color:#5af78e>$koin</span><span style=color:#5af78e>_version&#34;</span>
</span></span></code></pre></div><p>To use Koin, it is necessary to install the appropriate feature inside the <code>module</code> function. I recommend doing it as the first thing in the setup pipeline.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>install(Koin) {
</span></span><span style=display:flex><span>    slf4jLogger()
</span></span><span style=display:flex><span>    modules(appModule)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> appModule = module {
</span></span><span style=display:flex><span>    single&lt;MyClass&gt;()
</span></span><span style=display:flex><span>    single&lt;JokeRepository&gt; { JokeRepositoryImpl() }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The Koin module is defined in a separate file, just to keep the <code>Application</code> class and the Ktor <code>module</code> function as clean as possible.</p><p>After that, the dependency graph is built, and inside <code>Application</code>, <code>Routing</code> and <code>Route</code> scope, it is possible to retrieve the dependencies like in a <code>KoinComponent</code></p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> myClass <span style=color:#ff6ac1>by</span> inject&lt;MyClass&gt;()
</span></span></code></pre></div><p>For more information about Koin on Ktor, refer to the <a href=https://insert-koin.io/docs/reference/koin-ktor/ktor/>documentation</a></p><h2 id=configuration>Configuration</h2><p>On Ktor it is possible to <a href=https://ktor.io/docs/configurations.html>set some configurations</a>, like host address and port, in code (if using the <a href=https://ktor.io/docs/create-server.html#embedded-server><code>embeddedServer</code></a>) or in an external file (<code>application.conf</code>) with the HOCON format (if using the <a href=https://ktor.io/docs/create-server.html#engine-main><code>EngineMain</code></a>).</p><p>The wizard automatically creates an <code>application.conf</code> file in the application <code>resources</code> directory.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ktor {
</span></span><span style=display:flex><span>  deployment {
</span></span><span style=display:flex><span>    port = 8080
</span></span><span style=display:flex><span>    port = ${?PORT}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  application {
</span></span><span style=display:flex><span>    modules = [com.prof18.ktor.chucknorris.sample.ApplicationKt.module]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.
</span></span><span style=display:flex><span>└── src
</span></span><span style=display:flex><span>    ├── main
</span></span><span style=display:flex><span>    │   ├── kotlin
</span></span><span style=display:flex><span>    │   │   └── com
</span></span><span style=display:flex><span>    │   │       └── ...
</span></span><span style=display:flex><span>    │   └── resources
</span></span><span style=display:flex><span>    │       ├── application.conf
</span></span><span style=display:flex><span>    └── test
</span></span><span style=display:flex><span>        ├── kotlin
</span></span><span style=display:flex><span>        │   └── com
</span></span><span style=display:flex><span>        │       └── ...
</span></span><span style=display:flex><span>        └── resources
</span></span><span style=display:flex><span>            ├──  ...
</span></span></code></pre></div><p>This configuration file will be automatically loaded and parsed by Ktor when the server is started. It is also possible to provide a custom configuration file instead of the one from resources with a command-line argument:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>java -jar ktor-backend.jar -config=/config-folder/application.conf
</span></span></code></pre></div><p>This is helpful for example to provide different configurations for databases or for external service (in part 3 I’ll show a use case of this feature).</p><p>But, besides the <a href=https://ktor.io/docs/configurations.html#hocon-file>default value provided by the framework</a>, it is possible to create custom configurations to use later in the code.
For example, I’ve created a new section with a Boolean field that will indicate if the instance is running on a staging or production server.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ktor {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  server {
</span></span><span style=display:flex><span>    isProd = false
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Every section will be mapped in the code with a <code>data class</code></p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>ServerConfig</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> isProd: Boolean
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>that is contained in a wider class, named <code>AppConfig</code> with all the different custom configurations.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>AppConfig</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>lateinit</span> <span style=color:#ff6ac1>var</span> serverConfig: ServerConfig
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Place here other configurations
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span></code></pre></div><p>The fields of this class then will be initialized inside the <code>Application</code> scope.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>Application</span>.setupConfig() {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> appConfig <span style=color:#ff6ac1>by</span> inject&lt;AppConfig&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Server
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    <span style=color:#ff6ac1>val</span> serverObject = environment.config.config(<span style=color:#5af78e>&#34;ktor.server&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> isProd = serverObject.<span style=color:#ff6ac1>property</span>(<span style=color:#5af78e>&#34;isProd&#34;</span>).getString().toBoolean()
</span></span><span style=display:flex><span>    appConfig.serverConfig = ServerConfig(isProd)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this setup, when a configuration field must be accessed, the AppConfig class can be simply retrieved from Koin.</p><h2 id=project-structure>Project structure</h2><p>The structure of a project is a completely subjective topic and it does not invalidate the functionalities nor the correct behavior. However, I think that properly structuring a project is beneficial for better maintainability and scalability.</p><p>Here, I will share a structure that worked for me and that I found interesting. If you have any suggestion about alternative structures or if you notice something wrong in what I’m sharing, feel free to reach me out on Twitter <a href=https://twitter.com/marcoGomier>@marcoGomier</a>.</p><p>Since the <code>Application.kt</code> file is the entrypoint for the server, I left it at the root level of the <code>src > main > kotlin > &lt;package-name></code> folder.</p><p>Then, I’ve created a bunch of folders that contain “configuration code”:</p><ul><li><code>di</code>: it contains the code where the <code>Koin</code> modules are defined, <a href=#dependency-injection-with-koin>as described above</a></li><li><code>config</code>: it contains the code that maps the configuration fields from the <code>application.conf</code> file, <a href=#configuration>as described above</a></li><li><code>database</code>: it contains the code necessary to open (and close) the connection to the database. I’ll describe it in the next articles of the series.</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── Application.kt
</span></span><span style=display:flex><span>├── config
</span></span><span style=display:flex><span>│   └── AppConfig.kt
</span></span><span style=display:flex><span>├── database
</span></span><span style=display:flex><span>│   ├── DatabaseFactory.kt
</span></span><span style=display:flex><span>│   └── DatabaseFactoryImpl.kt
</span></span><span style=display:flex><span>├── di
</span></span><span style=display:flex><span>    └── AppModule.kt
</span></span></code></pre></div><p>Then, I’ve created the <code>features</code> folder. This top-level folder contains, as the name suggests, all the different features of the backend. For example, if the backend provides a set of API calls to authenticate a user, to handle jokes (get, create, delete, etc), and to handle the user (logout, update some settings, etc) there will be three different folders:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── features
</span></span><span style=display:flex><span>    ├── auth
</span></span><span style=display:flex><span>    │   └── ...
</span></span><span style=display:flex><span>    ├── jokes
</span></span><span style=display:flex><span>    │   └── ...
</span></span><span style=display:flex><span>    └── user
</span></span><span style=display:flex><span>        └── ...
</span></span></code></pre></div><p>In the sample project, the backend will provide only an API to get a random Joke, so there will be only a folder named <code>jokes</code> under the <code>features</code> folder.</p><p>The structure of every “feature folder” will follow some principles of the <strong>Clean Architecture</strong>. I’ve decided to stick with it because I’ve used it in some Android projects and I like it. But, this will be an adapted solution with only some aspects of the architecture. If you don’t know Clean Architecture and you want to know more about it, I suggest giving a look at the <a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Uncle Bob’s article</a> and, if you are an Android developer, to this <a href=https://www.raywenderlich.com/3595916-clean-architecture-tutorial-for-android-getting-started>Ray Wenderich’s article</a>.</p><p>The layers of Clean Architecture that I’ve used here are 3:</p><ul><li>data</li><li>domain</li><li>presentation</li></ul><p>The <strong>data layer</strong> contains the definitions of all the data sources. In this case, all the needed data are contained in the database, so there will be only code needed to interact with the database.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>└── jokes
</span></span><span style=display:flex><span>    ├── data
</span></span><span style=display:flex><span>        ├── JokeLocalDataSource.kt
</span></span><span style=display:flex><span>        ├── JokeLocalDataSourceImpl.kt
</span></span><span style=display:flex><span>        └── dao
</span></span><span style=display:flex><span>            └── Joke.kt
</span></span></code></pre></div><p>If the backend needs also to retrieve data from other APIs, here there will be also a remote data source.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>└── jokes
</span></span><span style=display:flex><span>    └── data
</span></span><span style=display:flex><span>        ├── local
</span></span><span style=display:flex><span>        │   ├── JokeLocalDataSource.kt
</span></span><span style=display:flex><span>	│   ├── JokeLocalDataSourceImpl.kt
</span></span><span style=display:flex><span>	│   └── dao
</span></span><span style=display:flex><span>	│       └── Joke.kt
</span></span><span style=display:flex><span>        └── remote
</span></span><span style=display:flex><span>            ├── JokeRemoteDataSource.kt
</span></span><span style=display:flex><span>	    ├── JokeRemoteDataSourceImpl.kt
</span></span><span style=display:flex><span>	    └── dto
</span></span><span style=display:flex><span>	        └── JokeRemoteDTO.kt
</span></span></code></pre></div><p>The <strong>domain layer</strong> contains the models, the business logic, and the mappers between the DAOs and the DTOs. The business logic is implemented by following the Repository pattern. The repository will contain the code necessary to retrieve, save and manipulate data from the data sources.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>└── jokes
</span></span><span style=display:flex><span>    ├── domain
</span></span><span style=display:flex><span>        ├── JokeRepository.kt
</span></span><span style=display:flex><span>        ├── JokeRepositoryImpl.kt
</span></span><span style=display:flex><span>        ├── mapper
</span></span><span style=display:flex><span>        │   └── DTOMapper.kt
</span></span><span style=display:flex><span>        └── model
</span></span><span style=display:flex><span>            └── JokeDTO.kt
</span></span></code></pre></div><p>And at the end, the <strong>presentation</strong> layer. Since this is not an application with a user interface, I decided to change the name from presentation to <strong>resource</strong>. In this layer, there will be the definitions of the REST endpoints that the backend exposes. I’ve decided to use the word <em>resource</em> because I like to think that REST endpoints are resources that give or handle data. This is just a personal opinion, for example, you can call these layer `<em>controller</em> or whatever.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>└── jokes
</span></span><span style=display:flex><span>    └── resource
</span></span><span style=display:flex><span>	└── JokeResource.kt
</span></span></code></pre></div><p>The <code>JokeResource</code> file will contain <a href=https://ktor.io/docs/features-locations.html#route-classes>the classes that define each route</a> and an extension function of <code>Route</code> that contains the definition of every endpoint.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Location</span>(<span style=color:#5af78e>&#34;joke&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>JokeEndpoint</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@Location</span>(<span style=color:#5af78e>&#34;/random&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>Random</span>(<span style=color:#ff6ac1>val</span> parent: JokeEndpoint)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>Route</span>.jokeEndpoint() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> jokeRepository <span style=color:#ff6ac1>by</span> inject&lt;JokeRepository&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>get</span>&lt;JokeEndpoint.Random&gt; {
</span></span><span style=display:flex><span>        call.respond(jokeRepository.getRandomJoke())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using an extension function, unlock the possibility to have a much cleaner module function: in this way, it is possible to define the endpoints in different files and call them inside the <code>routing</code> block in the <code>module</code> function.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>Application</span>.module(<span style=color:#ff6ac1>..</span>.) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>    routing {
</span></span><span style=display:flex><span>        jokeEndpoint()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And as reference, here’s the entire structure that I’ve described:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.
</span></span><span style=display:flex><span>└── sample
</span></span><span style=display:flex><span>    ├── Application.kt
</span></span><span style=display:flex><span>    ├── config
</span></span><span style=display:flex><span>    │   └── AppConfig.kt
</span></span><span style=display:flex><span>    ├── database
</span></span><span style=display:flex><span>    │   ├── DatabaseFactory.kt
</span></span><span style=display:flex><span>    │   └── DatabaseFactoryImpl.kt
</span></span><span style=display:flex><span>    ├── di
</span></span><span style=display:flex><span>    │   └── AppModule.kt
</span></span><span style=display:flex><span>    └── features
</span></span><span style=display:flex><span>        └── jokes
</span></span><span style=display:flex><span>            ├── data
</span></span><span style=display:flex><span>            │   ├── JokeLocalDataSource.kt
</span></span><span style=display:flex><span>            │   ├── JokeLocalDataSourceImpl.kt
</span></span><span style=display:flex><span>            │   └── dao
</span></span><span style=display:flex><span>            │       └── Joke.kt
</span></span><span style=display:flex><span>            ├── domain
</span></span><span style=display:flex><span>            │   ├── JokeRepository.kt
</span></span><span style=display:flex><span>            │   ├── JokeRepositoryImpl.kt
</span></span><span style=display:flex><span>            │   ├── mapper
</span></span><span style=display:flex><span>            │   │   └── DTOMapper.kt
</span></span><span style=display:flex><span>            │   └── model
</span></span><span style=display:flex><span>            │       └── JokeDTO.kt
</span></span><span style=display:flex><span>            └── resource
</span></span><span style=display:flex><span>                └── JokeResource.kt
</span></span></code></pre></div><h2 id=testing>Testing</h2><p>And last but not least, testing. Ktor is designed to allow easily testable applications. It does not create a web server but it hooks directly into the internal mechanism with a <a href=https://ktor.io/docs/testing.html><code>TestEngine</code></a>. In this way, the execution of tests will be quicker rather than spinning up a complete web server for testing.</p><p>With the <code>withTestApplication</code> function it is possible to set up a test environment and then, with the <code>handleRequest</code> function it is possible to perform the request and verify that the results are the same as expected.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Test</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>testRequests</span>() = withTestApplication(module(testing = <span style=color:#ff6ac1>true</span>)) {
</span></span><span style=display:flex><span>    with(handleRequest(HttpMethod.Get, <span style=color:#5af78e>&#34;/&#34;</span>)) {
</span></span><span style=display:flex><span>        assertEquals(HttpStatusCode.OK, response.status())
</span></span><span style=display:flex><span>        assertEquals(<span style=color:#5af78e>&#34;Hello from Ktor Testable sample application&#34;</span>, response.content)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, before testing the endpoints, it is necessary to set up the dependencies that the system under test will use and all the custom configurations defined in the <code>application.conf</code>.</p><p>To populate the configurations, the <code>MapApplicationConfig</code> can be used and passed to the <code>withTestApplication</code> function.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>MapApplicationConfig</span>.createConfigForTesting() {
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Server config
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    put(<span style=color:#5af78e>&#34;ktor.server.isProd&#34;</span>, <span style=color:#5af78e>&#34;false&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Test</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>testRequests</span>() = withTestApplication({
</span></span><span style=display:flex><span>    (environment.config <span style=color:#ff6ac1>as</span> MapApplicationConfig).apply {
</span></span><span style=display:flex><span>       createConfigForTesting()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    module(testing = <span style=color:#ff6ac1>true</span>) <span style=color:#78787e>// Call here your application&#39;s module
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The dependencies instead will be automatically provided by Koin. But, to provide a fake implementation of a dependency, some changes must be made.</p><p><a href=#dependency-injection-with-koin>As described above</a>, the Koin module is ”hardcoded” inside the Ktor module function (to be precise is defined in another file but not injected in the constructor).</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>install(Koin) {
</span></span><span style=display:flex><span>    slf4jLogger()
</span></span><span style=display:flex><span>    modules(appModule)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To modify the Koin module during testing, I’ve modified the Ktor <code>module</code> function to accept a list of Koin modules. This list has as the default value the Koin module that was previously hardcoded.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>Application</span>.module(testing: Boolean = <span style=color:#ff6ac1>false</span>, koinModules: List&lt;Module&gt; = listOf(appModule)) {
</span></span><span style=display:flex><span>    install(Koin) {
</span></span><span style=display:flex><span>        slf4jLogger()
</span></span><span style=display:flex><span>        modules(koinModules)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this way, during testing, it is possible to change one or more dependencies.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> appTestModule = module {
</span></span><span style=display:flex><span>    single&lt;AppConfig&gt;()
</span></span><span style=display:flex><span>    single&lt;DatabaseFactory&gt; { DatabaseFactoryForServerTest() }
</span></span><span style=display:flex><span>    single&lt;JokeLocalDataSource&gt; { JokeLocalDataSourceImpl() }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>val</span> fakeRepositoryModule = module {
</span></span><span style=display:flex><span>    single&lt;JokeRepository&gt; { FakeJokeRepository() }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Test</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>testRequests</span>() = withTestApplication({
</span></span><span style=display:flex><span>    (environment.config <span style=color:#ff6ac1>as</span> MapApplicationConfig).apply {
</span></span><span style=display:flex><span>       createConfigForTesting()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    module(testing = <span style=color:#ff6ac1>true</span>, koinModules = listOf(appTestModule, fakeRepositoryModule))
</span></span><span style=display:flex><span>}) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>Although it seems a boring task, structuring a project is a very important thing. In fact, starting with an unsafe foundation will put your product in danger, making it unscalable and hard to maintain throughout the time.
However, there isn’t a right way to structure a project because every project is different and has different needs. What I suggest to do, is to find the right solution <strong>for your needs</strong> and the structure that I’ve shared here is the one that satisfied me.</p><p>And that’s it for today. You can find the code mentioned in the article on <a href=https://github.com/prof18/ktor-chuck-norris-sample/tree/main/part1>GitHub</a>.</p><p>In the next episodes, I’ll cover logging and databases. You can follow me on <a href=https://twitter.com/marcoGomier>Twitter</a> to know when I’ll publish the next episode.</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-69FZ1TLE7E","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>