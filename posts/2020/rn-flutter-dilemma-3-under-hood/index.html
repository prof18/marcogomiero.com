<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Flutter or React Native, a cross-platform dilemma - How they work - (Part 3) | Marco Gomiero</title><meta name=keywords content><meta name=description content="Welcome to the third part of this article series about React Native and Flutter. In the latest episode, we have talked about User Interfaces and how to build them in the two frameworks. In this article, we&rsquo;ll go deeper under the hoods to understand how things work. But I will not go deeper with lot&rsquo;s of details and implementation things, because I want to make you understand how the thing works at a high level."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-3-under-hood/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-90975904-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)"><meta property="og:description" content="Welcome to the third part of this article series about React Native and Flutter. In the latest episode, we have talked about User Interfaces and how to build them in the two frameworks. In this article, we&rsquo;ll go deeper under the hoods to understand how things work. But I will not go deeper with lot&rsquo;s of details and implementation things, because I want to make you understand how the thing works at a high level."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-3-under-hood/"><meta property="og:image" content="https://www.marcogomiero.com/img/flutter-rn/virtual-dom.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-16T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-16T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/flutter-rn/virtual-dom.png"><meta name=twitter:title content="Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)"><meta name=twitter:description content="Welcome to the third part of this article series about React Native and Flutter. In the latest episode, we have talked about User Interfaces and how to build them in the two frameworks. In this article, we&rsquo;ll go deeper under the hoods to understand how things work. But I will not go deeper with lot&rsquo;s of details and implementation things, because I want to make you understand how the thing works at a high level."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)","item":"https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-3-under-hood/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)","name":"Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)","description":"Welcome to the third part of this article series about React Native and Flutter. In the latest episode, we have talked about User Interfaces and how to build them in the two frameworks. In this article, we\u0026rsquo;ll go deeper under the hoods to understand how things work. But I will not go deeper with lot\u0026rsquo;s of details and implementation things, because I want to make you understand how the thing works at a high level.","keywords":[],"articleBody":"Welcome to the third part of this article series about React Native and Flutter. In the latest episode, we have talked about User Interfaces and how to build them in the two frameworks. In this article, we’ll go deeper under the hoods to understand how things work. But I will not go deeper with lot’s of details and implementation things, because I want to make you understand how the thing works at a high level. If you are interested to go deeper, I will leave across the article some links for further information.\nBut, before moving on, I suggest you read the previous articles of the series if you have lost them.\nFlutter or React Native, a cross-platform dilemma - Introduction - (Part 1)\nFlutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)\nReact Native Let’s start by analyzing the internals of Rect Native. React Native has an internal infrastructure that is called “the Bridge” and that is built at runtime. The main purpose of the bridge is to create a connection between the native part of the application and the Javascript one, so it can be possible to call native code from the javascript part of the application and vice-versa. The communication between the two different parts is event-driven and in the following gif, you can see an example of that kind of communication.\nAn example of communication between Native and Javascript\nLet’s analyze what happens here. Let’s suppose that we have opened our application. Then, the native code notifies to the bridge that the app has been opened and so the bridge generates a serialized payload that contains that information. This payload is sent to the Javascript code that decides what to do; for example, it decides to render the simple “Hello World” app that we showed in the latest episode. So again, the information is sent back to the bridge that serializes that information and it sends it back to the native code. At this time, the native code has received all the information that it needs to render the view of the application. These exchanges of information are performed in an asynchronous way: the messages are collected in a queue that is flushed every 5 ms by default to avoid too much message sending in a short period of time. Nevertheless, this message passing causes some delays especially with a complex layout or long list with complex items. In fact, the Facebook team is working on a new architecture (codename Fabric) to address this issue and let the UI update synchronously. In just two words, they will get rid of the bridge and the serialization and there will be a Javascript Interface to allow the communication between the Javascript part and the native one. For more information about Fabric I suggest you look to this talk: React Native’s New Architecture - Parashuram N - React Conf 2018\nFlutter Flutter instead works in a completely different way. In fact, all the widgets are managed and rendered using an engine (written in C++). In the figure below, you can see a representation of the Flutter Engine.\nFlutter Engine\nAs you can see, there is a block called “Skia”. Skia is an open-source 2D graphic library managed by Google and you may already know about it, because it is used by Chrome, Chrome OS, Android, Firefox and many others. And in Flutter, Skia is responsible for rendering the widgets in a canvas. In this way, there isn’t a continuous communication between the “cross-platform technology” and the native part and everything is faster. Moreover, all the Dart code is compiled to native code to speed things up. be aware that the compilation to native code is performed only for production build and for this reason debug builds can be slower.\nComparison So, in React Native there is a correspondence between the components and the native widgets while Flutter includes its own widgets. This choice has pros and cons. Imagine that Apple and Google update the TextView with some flowers on the shape: an app developed with React Native will ( or better should ) show the flowers without any intervention while an app developed with Flutter won’t show it until the Flutter team will add it on their custom TextView. This is a con because we need to wait for another update if there are new things available on the native UI. The pro instead is that there isn’t any delay due to the bridge initialization and the runtime translation needed to enable the communication between the javascript part and the native one.\nCommon interesting features And finally, I want to conclude with some interesting features that both Flutter and React Native have.\nHot Reload The first one is “Hot Reload”, i.e. the capability of loading new changes without recompiling the entire application again. This feature is really really useful for example when you are trying different colors, font sizes, etc; waiting for an entire recompilation for these little changes it would be such a pain. In Flutter this feature is possible thanks to a combination of Ahead-of-time (AOT) and Just-in-time compilation. In fact, as mentioned earlier, Flutter generates machine code for production builds. For the debug builds instead, there is a virtual machine that can receive the new code, replace the old one and maintain the state. Here you can find more information about hot reload in Flutter.\nIn React Native instead, the Hot Reload is built on top of Hot Module Replacement by Webpack. Basically there is a runtime included in the app that receives the new code and it replaces the old one. If you are interested in the details, I suggest you read this blog post from Facebook.\nUpdate only components/widgets that have changed Both Flutter and React Native are declarative frameworks. This means that we define the current UI state (e.g. a loading state, an error state, etc.) and the framework manages the state changes. To achieve these, the framework creates an abstract representation of the UI and when the UI state has changed, it builds a new representation that it will be compared and to the previous one and only the differences will be rendered.\nTo achieve these, React Native uses a Virtual DOM as UI representation (as you can see in the image below, basically a JSON file that contains all the information about the UI component).\nVirtual DOM\nThen the different DOMs are compared using reconciliation, a heuristic diff comparison algorithm. For more information about it, you can give a look to the React documentation.\nFlutter instead builds an Element Tree as a representation of the UI but instead, it does not use a tree-diffing algorithm to find the differences but instead, for each element of the UI the children list are examined independently.\nFlutter Element Tree\nFor more information about it, you can give a look to the Flutter documentation.\n“Frankenstein” App With Flutter and React Native, you can create a view, a screen or even an entire feature and then integrate it in an existing native application. This possibility can be really useful for example for very fast-evolving features or for an MVP feature that we are not so sure that it will be useful or even for a feature that will not be used so much. So it really depends on your situation but I can assure you that is not a crazy thing and maybe in the future, you could find yourself in this situation.\nWith React Native, you have to use in your native application a view that will act as a container of the RN app and then you load the javascript bundle that you have previously generated with a kilometric command.\nreact-native bundle \\ --verbose \\ --platform android \\ --dev false --entry-file index.js \\ --bundle-output your-project/app/src/main/assets/index.android.bundle \\ --assets-dest your-project/app/src/main/res \\ --sourcemap-output utils/android.main.bundle.map For more information, please visit the official documentation.\nAlso in Flutter, you have to define a container view in your native application but instead, you don’t need to write a kilometric command to generate bundle: you just add the Flutter project directly from Android Studio and that’s it! ( for iOs there is more work to do: you have to add a Flutter SDK hook to the CocoaPods and to Xcode build phase ).\nAgain, for more information, I suggest you read the official documentation\nAnd we have reached the end of this journey through the internals of Flutter and React Native. I understand that I went through lots of things in this article but I think that it’s necessary to know a little bit about how things work if you choose and work with these frameworks. In fact, the way how these frameworks work can affect your product.\nIn the next (final) episode, we’ll wrap things up and I’ll help you resolve the dilemma!\n","wordCount":"1479","inLanguage":"en","image":"https://www.marcogomiero.com/img/flutter-rn/virtual-dom.png","datePublished":"2020-03-16T00:00:00Z","dateModified":"2020-03-16T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-3-under-hood/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)</h1><div class=post-meta style=margin-top:16px><span title='2020-03-16 00:00:00 +0000 UTC'>16 March 2020</span>&nbsp;·&nbsp;7 min</div></header><div class=post-content><p>Welcome to the third part of this article series about React Native and Flutter. In the latest episode, we have talked about User Interfaces and how to build them in the two frameworks. In this article, we&rsquo;ll go deeper under the hoods to understand how things work. But I will not go deeper with lot&rsquo;s of details and implementation things, because I want to make you understand how the thing works at a high level. If you are interested to go deeper, I will leave across the article some links for further information.</p><p>But, before moving on, I suggest you read the previous articles of the series if you have lost them.</p><blockquote><p><a href=http://marcogomiero.com/posts/2019/rn-flutter-dilemma-1-intro/>Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)</a></p></blockquote><blockquote><p><a href=http://marcogomiero.com/posts/2019/rn-flutter-dilemma-2-ui/>Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)</a></p></blockquote><h2 id=react-native>React Native<a hidden class=anchor aria-hidden=true href=#react-native>#</a></h2><p>Let&rsquo;s start by analyzing the internals of Rect Native. React Native has an internal infrastructure that is called &ldquo;the <strong>Bridge</strong>&rdquo; and that is built at runtime. The main purpose of the bridge is to create a connection between the native part of the application and the Javascript one, so it can be possible to call native code from the javascript part of the application and vice-versa. The communication between the two different parts is event-driven and in the following gif, you can see an example of that kind of communication.</p><figure><img loading=lazy src=/img/flutter-rn/js-bridge.gif alt=image><figcaption><p>An example of communication between Native and Javascript</p></figcaption></figure><p>Let&rsquo;s analyze what happens here. Let&rsquo;s suppose that we have opened our application. Then, the native code notifies to the bridge that the app has been opened and so the bridge generates a serialized payload that contains that information. This payload is sent to the Javascript code that decides what to do; for example, it decides to render the simple &ldquo;Hello World&rdquo; app that we showed in the latest episode. So again, the information is sent back to the bridge that serializes that information and it sends it back to the native code. At this time, the native code has received all the information that it needs to render the view of the application.
These exchanges of information are performed in an asynchronous way: the messages are collected in a queue that is flushed every 5 ms by default to avoid too much message sending in a short period of time. Nevertheless, this message passing causes some delays especially with a complex layout or long list with complex items.
In fact, the Facebook team is working on a new architecture (codename Fabric) to address this issue and let the UI update synchronously. In just two words, they will get rid of the bridge and the serialization and there will be a Javascript Interface to allow the communication between the Javascript part and the native one. For more information about Fabric I suggest you look to this talk: <a href="https://www.youtube.com/watch?v=UcqRXTriUVI"><em>React Native&rsquo;s New Architecture - Parashuram N - React Conf 2018</em></a></p><h2 id=flutter>Flutter<a hidden class=anchor aria-hidden=true href=#flutter>#</a></h2><p>Flutter instead works in a completely different way. In fact, all the widgets are managed and rendered using an engine (written in C++). In the figure below, you can see a representation of the Flutter Engine.</p><figure><img loading=lazy src=/img/flutter-rn/engine.png alt=image><figcaption><p>Flutter Engine</p></figcaption></figure><p>As you can see, there is a block called &ldquo;Skia&rdquo;. <a href=https://skia.org/>Skia</a> is an open-source 2D graphic library managed by Google and you may already know about it, because it is used by Chrome, Chrome OS, Android, Firefox and many others. And in Flutter, Skia is responsible for rendering the widgets in a canvas. In this way, there isn&rsquo;t a continuous communication between the &ldquo;cross-platform technology&rdquo; and the native part and everything is faster. Moreover, all the Dart code is compiled to native code to speed things up. be aware that the compilation to native code is performed only for production build and for this reason debug builds can be slower.</p><h2 id=comparison>Comparison<a hidden class=anchor aria-hidden=true href=#comparison>#</a></h2><p>So, in React Native there is a correspondence between the components and the native widgets while Flutter includes its own widgets. This choice has pros and cons. Imagine that Apple and Google update the TextView with some flowers on the shape: an app developed with React Native will ( or better should ) show the flowers without any intervention while an app developed with Flutter won&rsquo;t show it until the Flutter team will add it on their custom TextView. This is a con because we need to wait for another update if there are new things available on the native UI. The pro instead is that there isn&rsquo;t any delay due to the bridge initialization and the runtime translation needed to enable the communication between the javascript part and the native one.</p><h2 id=common-interesting-features>Common interesting features<a hidden class=anchor aria-hidden=true href=#common-interesting-features>#</a></h2><p>And finally, I want to conclude with some interesting features that both Flutter and React Native have.</p><h3 id=hot-reload>Hot Reload<a hidden class=anchor aria-hidden=true href=#hot-reload>#</a></h3><p>The first one is &ldquo;<strong>Hot Reload</strong>&rdquo;, i.e. the capability of loading new changes without recompiling the entire application again. This feature is really really useful for example when you are trying different colors, font sizes, etc; waiting for an entire recompilation for these little changes it would be such a pain.
In Flutter this feature is possible thanks to a combination of <em>Ahead-of-time</em> (AOT) and <em>Just-in-time</em> compilation. In fact, as mentioned earlier, Flutter generates machine code for production builds. For the debug builds instead, there is a virtual machine that can receive the new code, replace the old one and maintain the state. <a href=https://flutter.dev/docs/resources/technical-overview>Here</a> you can find more information about hot reload in Flutter.</p><p>In React Native instead, the Hot Reload is built on top of <em>Hot Module Replacement</em> by Webpack. Basically there is a runtime included in the app that receives the new code and it replaces the old one. If you are interested in the details, I suggest you read <a href=https://facebook.github.io/react-native/blog/2016/03/24/introducing-hot-reloading.html>this blog post</a> from Facebook.</p><h2 id=update-only-componentswidgets-that-have-changed>Update only components/widgets that have changed<a hidden class=anchor aria-hidden=true href=#update-only-componentswidgets-that-have-changed>#</a></h2><p>Both Flutter and React Native are declarative frameworks. This means that we define the current UI state (e.g. a loading state, an error state, etc.) and the framework manages the state changes. To achieve these, the framework creates an abstract representation of the UI and when the UI state has changed, it builds a new representation that it will be compared and to the previous one and only the differences will be rendered.</p><p>To achieve these, React Native uses a Virtual DOM as UI representation (as you can see in the image below, basically a JSON file that contains all the information about the UI component).</p><figure><img loading=lazy src=/img/flutter-rn/virtual-dom.png alt=image><figcaption><p>Virtual DOM</p></figcaption></figure><p>Then the different DOMs are compared using reconciliation, a heuristic diff comparison algorithm. For more information about it, you can give a look <a href=https://reactjs.org/docs/reconciliation.html>to the React documentation</a>.</p><p>Flutter instead builds an Element Tree as a representation of the UI but instead, it does not use a tree-diffing algorithm to find the differences but instead, for each element of the UI the children list are examined independently.</p><figure><img loading=lazy src=/img/flutter-rn/element-tree.png alt=image><figcaption><p>Flutter Element Tree</p></figcaption></figure><p>For more information about it, you can give a look <a href=https://flutter.dev/docs/resources/inside-flutter>to the Flutter documentation</a>.</p><h2 id=frankenstein-app>“Frankenstein” App<a hidden class=anchor aria-hidden=true href=#frankenstein-app>#</a></h2><p>With Flutter and React Native, you can create a view, a screen or even an entire feature and then integrate it in an existing native application. This possibility can be really useful for example for very fast-evolving features or for an MVP feature that we are not so sure that it will be useful or even for a feature that will not be used so much. So it really depends on your situation but I can assure you that is not a crazy thing and maybe in the future, you could find yourself in this situation.</p><p>With React Native, you have to use in your native application a view that will act as a container of the RN app and then you load the javascript bundle that you have previously generated with a kilometric command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>react-native bundle <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--verbose <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--platform android <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--dev false 
</span></span><span style=display:flex><span>--entry-file index.js <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--bundle-output your-project/app/src/main/assets/index.android.bundle <span style=color:#ae81ff>\ </span>
</span></span><span style=display:flex><span>--assets-dest your-project/app/src/main/res <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--sourcemap-output utils/android.main.bundle.map
</span></span></code></pre></div><p>For more information, please visit the <a href=https://facebook.github.io/react-native/docs/integration-with-existing-apps>official documentation</a>.</p><p>Also in Flutter, you have to define a container view in your native application but instead, you don&rsquo;t need to write a kilometric command to generate bundle: you just add the Flutter project directly from Android Studio and that&rsquo;s it! ( for iOs there is more work to do: you have to add a Flutter SDK hook to the CocoaPods and to Xcode build phase ).</p><p>Again, for more information, I suggest you read the <a href=https://flutter.dev/docs/development/add-to-app>official documentation</a></p><hr><p>And we have reached the end of this journey through the internals of Flutter and React Native. I understand that I went through lots of things in this article but I think that it&rsquo;s necessary to know a little bit about how things work if you choose and work with these frameworks. In fact, the way how these frameworks work can affect your product.</p><p>In the next (final) episode, we&rsquo;ll wrap things up and I&rsquo;ll help you resolve the dilemma!</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>