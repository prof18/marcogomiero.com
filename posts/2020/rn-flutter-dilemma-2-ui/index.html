<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2) | Marco Gomiero</title><meta name=keywords content><meta name=description content="Welcome to the second part of this comparison about React Native and Flutter. In the first episode, we have introduced the two frameworks with some history and with a comparison between the languages that these two frameworks use.
If you have lost the first episode, I suggest you read it before moving on.
 Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)
 In this article, I will explain how to build user interfaces in React Native and Flutter."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-2-ui/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-90975904-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)"><meta property="og:description" content="Welcome to the second part of this comparison about React Native and Flutter. In the first episode, we have introduced the two frameworks with some history and with a comparison between the languages that these two frameworks use.
If you have lost the first episode, I suggest you read it before moving on.
 Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)
 In this article, I will explain how to build user interfaces in React Native and Flutter."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-2-ui/"><meta property="og:image" content="https://www.marcogomiero.com/img/flutter-rn/widgets.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-07T08:00:00+00:00"><meta property="article:modified_time" content="2020-01-07T08:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/flutter-rn/widgets.png"><meta name=twitter:title content="Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)"><meta name=twitter:description content="Welcome to the second part of this comparison about React Native and Flutter. In the first episode, we have introduced the two frameworks with some history and with a comparison between the languages that these two frameworks use.
If you have lost the first episode, I suggest you read it before moving on.
 Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)
 In this article, I will explain how to build user interfaces in React Native and Flutter."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)","item":"https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-2-ui/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)","name":"Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)","description":"Welcome to the second part of this comparison about React Native and Flutter. In the first episode, we have introduced the two frameworks with some history and with a comparison between the languages that these two frameworks use.\nIf you have lost the first episode, I suggest you read it before moving on.\n Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)\n In this article, I will explain how to build user interfaces in React Native and Flutter.","keywords":[],"articleBody":"Welcome to the second part of this comparison about React Native and Flutter. In the first episode, we have introduced the two frameworks with some history and with a comparison between the languages that these two frameworks use.\nIf you have lost the first episode, I suggest you read it before moving on.\n Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)\n In this article, I will explain how to build user interfaces in React Native and Flutter. Disclaimer: This article will not cover all the deep aspects of the two frameworks, but I want to give you an overview to better understand the differences. For much deeper details, I suggest you look at the official documentation (React Native - Flutter)\nReact Native Let’s jump immediately into some code (a simple Hello World).\n// React Native import React from \"react\"; import { StyleSheet, Text, View } from \"react-native\"; export default class App extends React.Component { render() { return ( View style={styles.container} TextHello world!Text View ); } } const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: \"#fff\", alignItems: \"center\", justifyContent: \"center\" } }); The entry point of this Hello World is the render method. Inside this method, we declare all the items (these items have a precise name, but I’ll reveal it in a moment) that has to be rendered on the screen. In this case, there is a View with inside a Text. These items are called Components and a Component is the basic building block that composes the UI. Of course, as showed in the example above, the Components can be nested together to build more complex components and UIs.\nThe Components are declared and stylized (the styling is done by using CSS) by using a Domain Specific Language called JSX. This DSL is basically a (very simple) mixture of Javascript and XML. For more information about JSX, please refer to the documentation.\nText ellipsizeMode={\"tail\"} numberOfLines={this.props.numberOfLines || 100} style={{fontSize: 14}}  \"Hello World\" Text The React team has already developed lots of Components that we can use (there is a list of the available Components in the documentation) but we can also download and use Components developed by third-party developers. Every Component can be used in a standalone way or it can be combined with other ones to create a more complex one.\n  Components catalogue.\n  Flutter And now, let’s move to Flutter. As before, we start with a simple Hello World.\n// Flutter import 'package:flutter/material.dart'; void main() = runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: Text(\"Flutter Demo Home Page\"), ), body: Center( child: Text(\"Hello World\"), ), ), ); } } In Flutter, the equivalent of Components are Widgets and in the example above, for example instead of View and Text we have Center and Text. Flutter takes inspiration from React and the main idea is that the UI is built out of widgets. In fact, in Flutter everything is a widget: for example, the structural elements of the application ( buttons, menu, dialogs, etc ), the stylistic elements ( opacity, transformations, etc ) and also the aspect of the layout ( margins, paddings, alignments, etc ) are widgets. And even the application itself is a widget. In fact, the entire Hello World application that is defined before is a widget (MyApp) and more precisely a Stateless widget. In Flutter, you can use a Stateless or a Statefulwidget depending if you have to manage the state of the application.\nThe entry point of the widget is the build method, that we have override every time we define a new widget. As you can see in the example above, we have declared a bunch of widgets: the MaterialApp widget where we can declare some theme customization, the Scaffold widget that provides the main structure of an application and finally the “real content” of our application, i.e. the Center widget with a Text widget as children.\nAs the components in React Native, the widgets can be nested together to create to build more complex widgets and UIs. The Flutter team has already developed lots of widgets that we can use (there is a list of the available widgets in the documentation) but we can also download and use widgets developed by third-party developers.\n  Widgets catalogue.\n  Recap So, in Flutter we remain in the Dart context to define User Interfaces, while in React Native we have to learn a DSL (but is very simple). In both frameworks, we can modularize the UI by mixing simple “blocks”. And this modularization is highly suggested to avoid a mess codebase and a lot of nested widgets/components in your code.\nAlongside with the modularization of the UI, you should also add state management in your application. In this way, you can separate the presentation logic from the business logic, you can sync data between different components/widget, you can have a more testable code, etc. This topic will not be covered in this series of articles, but I want to give you some quick tips/suggestions. Both in Rect Native and Flutter, there is a “naive” way to manage the state provided by the framework. In a few words, you can define a default state and then update it by calling a setState method. When this method is called the UI is redrawn (with of course some optimizations) to show the update state. For more information, I suggest you read the documentation, both for React Native and Flutter. There are also more powerful ways to manage the state, for example for React Native: Redux, Mobx, Apollo, etc. while for Flutter: again Redux, BLoC, Scoped Model, etc. A list of different state management possibilities for Flutter can be found on fluttersamples.com website.\nBefore ending this journey into the User Interfaces, I need to tell you that this style of building UIs has a name: Declarative. In the mobile world we are all used to define UIs in an imperative style, i.e. if we want to update an element of the UI, for example, a TextView, we ask the view owner an instance of that element and then we update it based on the new state. With the declarative style, we define the current UI state (e.g. a loading state, an error state, etc.) and the framework manages the state changes. This pattern has lots of benefits (but this is not the right place to talk about it - maybe in a future blog post) and is borrowed from the web world, from frameworks like React and Vue.js. Next, it started to appear in the mobile world with React Native and then Flutter and finally, it captured the attention of the “native world” with Jetpack Compose and Swift UI. And I think that Declarative patterns are the future.\nAnd for today is enough. After this journey into User Interfaces, in the next episode, we’ll dive under the hood of these frameworks.\n","wordCount":"1155","inLanguage":"en","datePublished":"2020-01-07T08:00:00Z","dateModified":"2020-01-07T08:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-2-ui/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Flutter or React Native, a cross-platform dilemma - How to build User Interfaces - (Part 2)</h1><div class=post-meta style=margin-top:16px><span title="2020-01-07 08:00:00 +0000 UTC">7 January 2020</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>Welcome to the second part of this comparison about React Native and Flutter. In the first episode, we have introduced the two frameworks with some history and with a comparison between the languages that these two frameworks use.</p><p>If you have lost the first episode, I suggest you read it before moving on.</p><blockquote><p><a href=http://marcogomiero.com/posts/2019/rn-flutter-dilemma-1-intro/>Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)</a></p></blockquote><p>In this article, I will explain how to build user interfaces in React Native and Flutter.
Disclaimer: This article will not cover all the deep aspects of the two frameworks, but I want to give you an overview to better understand the differences. For much deeper details, I suggest you look at the official documentation (<a href=https://facebook.github.io/react-native/>React Native</a> - <a href=https://flutter.dev/docs>Flutter</a>)</p><h2 id=react-native>React Native<a hidden class=anchor aria-hidden=true href=#react-native>#</a></h2><p>Let&rsquo;s jump immediately into some code (a simple <em>Hello World</em>).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-react data-lang=react><span style=color:#75715e>// React Native
</span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;
<span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>StyleSheet</span>, <span style=color:#a6e22e>Text</span>, <span style=color:#a6e22e>View</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react-native&#34;</span>;

<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>Component</span> {
  <span style=color:#a6e22e>render</span>() {
    <span style=color:#66d9ef>return</span> (
      &lt;<span style=color:#f92672>View</span> <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>styles</span>.<span style=color:#a6e22e>container</span>}&gt;
        &lt;<span style=color:#f92672>Text</span>&gt;<span style=color:#a6e22e>Hello</span> <span style=color:#a6e22e>world</span><span style=color:#f92672>!</span>&lt;/<span style=color:#f92672>Text</span>&gt;
      &lt;/<span style=color:#f92672>View</span>&gt;
    );
  }
}
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>styles</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>StyleSheet</span>.<span style=color:#a6e22e>create</span>({
  <span style=color:#a6e22e>container</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>flex</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>,
    <span style=color:#a6e22e>backgroundColor</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#fff&#34;</span>,
    <span style=color:#a6e22e>alignItems</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;center&#34;</span>,
    <span style=color:#a6e22e>justifyContent</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;center&#34;</span>
  }
});
</code></pre></div><p>The entry point of this Hello World is the <code>render</code> method. Inside this method, we declare all the <em>items</em> (these items have a precise name, but I&rsquo;ll reveal it in a moment) that has to be rendered on the screen. In this case, there is a <a href=https://facebook.github.io/react-native/docs/view><code>View</code></a> with inside a <a href=https://facebook.github.io/react-native/docs/text><code>Text</code></a>. These <em>items</em> are called <strong>Components</strong> and a <strong>Component</strong> is the basic building block that composes the UI. Of course, as showed in the example above, the <strong>Components</strong> can be nested together to build more complex components and UIs.</p><p>The <strong>Components</strong> are declared and stylized (the styling is done by using <em>CSS</em>) by using a <strong>D</strong>omain <strong>S</strong>pecific <strong>L</strong>anguage called <strong>JSX</strong>. This <strong>DSL</strong> is basically a (very simple) mixture of <em>Javascript</em> and <em>XML</em>. For more information about <strong>JSX</strong>, please refer to the <a href=https://reactjs.org/docs/glossary.html#jsx>documentation</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx>&lt;<span style=color:#f92672>Text</span>
    <span style=color:#a6e22e>ellipsizeMode</span><span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;tail&#34;</span>}
    <span style=color:#a6e22e>numberOfLines</span><span style=color:#f92672>=</span>{<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>numberOfLines</span> <span style=color:#f92672>||</span> <span style=color:#ae81ff>100</span>}
    <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span>{{<span style=color:#a6e22e>fontSize</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>14</span>}}
&gt;
  <span style=color:#e6db74>&#34;Hello World&#34;</span>
&lt;/<span style=color:#f92672>Text</span>&gt;
</code></pre></div><p>The React team has already developed lots of Components that we can use (there is a list of the available Components in the <a href=https://facebook.github.io/react-native/docs/components-and-apis.html>documentation</a>) but we can also download and use Components developed by third-party developers. Every Component can be used in a standalone way or it can be combined with other ones to create a more complex one.</p><figure><img loading=lazy src=/img/flutter-rn/components.png alt=image><figcaption><p>Components catalogue.</p></figcaption></figure><h2 id=flutter>Flutter<a hidden class=anchor aria-hidden=true href=#flutter>#</a></h2><p>And now, let&rsquo;s move to Flutter. As before, we start with a simple Hello World.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=color:#75715e>// Flutter
</span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:flutter/material.dart&#39;</span>;

<span style=color:#66d9ef>void</span> main() <span style=color:#f92672>=&gt;</span> runApp(MyApp());

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyApp</span> <span style=color:#66d9ef>extends</span> StatelessWidget {
  <span style=color:#960050;background-color:#1e0010>@</span>override
  Widget build(BuildContext context) {
    <span style=color:#66d9ef>return</span> MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text(<span style=color:#e6db74>&#34;Flutter Demo Home Page&#34;</span>),
        ),
        body: Center(
          child: Text(<span style=color:#e6db74>&#34;Hello World&#34;</span>),
        ),
      ),
    );
  }
}
</code></pre></div><p>In Flutter, the equivalent of Components are <strong>Widgets</strong> and in the example above, for example instead of <code>View</code> and <code>Text</code> we have <a href=https://api.flutter.dev/flutter/widgets/Center-class.html><code>Center</code></a> and <a href=https://api.flutter.dev/flutter/widgets/Text-class.html><code>Text</code></a>. Flutter takes inspiration from React and the main idea is that the UI is built out of widgets. In fact, in Flutter everything is a widget: for example, the structural elements of the application ( buttons, menu, dialogs, etc ), the stylistic elements ( opacity, transformations, etc ) and also the aspect of the layout ( margins, paddings, alignments, etc ) are widgets. And even the application itself is a widget. In fact, the entire Hello World application that is defined before is a widget (<code>MyApp</code>) and more precisely a <code>Stateless</code> widget. In Flutter, you can use a <a href=https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html><code>Stateless</code></a> or a <a href=https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html><code>Stateful</code></a>widget depending if you have to manage the state of the application.</p><p>The entry point of the widget is the <code>build</code> method, that we have override every time we define a new widget. As you can see in the example above, we have declared a bunch of widgets: the <code>MaterialApp</code> widget where we can declare some theme customization, the <code>Scaffold</code> widget that provides the main structure of an application and finally the &ldquo;real content&rdquo; of our application, i.e. the <code>Center</code> widget with a <code>Text</code> widget as children.</p><p>As the components in React Native, the widgets can be nested together to create to build more complex widgets and UIs. The Flutter team has already developed lots of widgets that we can use (there is a list of the available widgets in the <a href=https://flutter.dev/docs/development/ui/widgets>documentation</a>) but we can also download and use widgets developed by third-party developers.</p><figure><img loading=lazy src=/img/flutter-rn/widgets.png alt=image><figcaption><p>Widgets catalogue.</p></figcaption></figure><h2 id=recap>Recap<a hidden class=anchor aria-hidden=true href=#recap>#</a></h2><p>So, in Flutter we remain in the Dart context to define User Interfaces, while in React Native we have to learn a <strong>DSL</strong> (but is very simple). In both frameworks, we can modularize the UI by mixing simple &ldquo;blocks&rdquo;. And this modularization is highly suggested to avoid a mess codebase and a lot of nested widgets/components in your code.</p><p>Alongside with the modularization of the UI, you should also add state management in your application. In this way, you can separate the presentation logic from the business logic, you can sync data between different components/widget, you can have a more testable code, etc. This topic will not be covered in this series of articles, but I want to give you some quick tips/suggestions. Both in Rect Native and Flutter, there is a &ldquo;naive&rdquo; way to manage the state provided by the framework. In a few words, you can define a default state and then update it by calling a <code>setState</code> method. When this method is called the UI is redrawn (with of course some optimizations) to show the update state. For more information, I suggest you read the documentation, both for <a href=https://facebook.github.io/react-native/docs/state>React Native</a> and <a href=https://flutter.dev/docs/development/ui/interactive>Flutter</a>.
There are also more powerful ways to manage the state, for example for React Native: <a href=https://github.com/reduxjs/redux>Redux</a>, <a href=https://github.com/mobxjs/mobx>Mobx</a>, <a href=https://www.apollographql.com/docs/react/integrations/react-native/>Apollo</a>, etc. while for Flutter: again Redux, BLoC, Scoped Model, etc. A list of different state management possibilities for Flutter can be found on <a href=http://fluttersamples.com/>fluttersamples.com</a> website.</p><p>Before ending this journey into the User Interfaces, I need to tell you that this style of building UIs has a name: <strong>Declarative</strong>. In the mobile world we are all used to define UIs in an imperative style, i.e. if we want to update an element of the UI, for example, a TextView, we ask the view owner an instance of that element and then we update it based on the new state. With the declarative style, we define the current UI state (e.g. a loading state, an error state, etc.) and the framework manages the state changes. This pattern has lots of benefits (but this is not the right place to talk about it - maybe in a future blog post) and is borrowed from the web world, from frameworks like React and Vue.js. Next, it started to appear in the mobile world with React Native and then Flutter and finally, it captured the attention of the &ldquo;native world&rdquo; with Jetpack Compose and Swift UI. And I think that Declarative patterns are the future.</p><p>And for today is enough. After this journey into User Interfaces, in the next episode, we&rsquo;ll dive under the hood of these frameworks.</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.marcogomiero.com/posts/2020/rn-flutter-dilemma-3-under-hood/><span class=title>« Prev</span><br><span>Flutter or React Native, a cross-platform dilemma - How they work - (Part 3)</span></a>
<a class=next href=https://www.marcogomiero.com/posts/2019/rn-flutter-dilemma-1-intro/><span class=title>Next »</span><br><span>Flutter or React Native, a cross-platform dilemma - Introduction - (Part 1)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>