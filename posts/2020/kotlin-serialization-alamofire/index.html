<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform | Marco Gomiero</title><meta name=keywords content><meta name=description content="If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2020/kotlin-serialization-alamofire/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-90975904-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform"><meta property="og:description" content="If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2020/kotlin-serialization-alamofire/"><meta property="og:image" content="https://www.marcogomiero.com/img/profile.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-10T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/profile.webp"><meta name=twitter:title content="Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform"><meta name=twitter:description content="If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform","item":"https://www.marcogomiero.com/posts/2020/kotlin-serialization-alamofire/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform","name":"Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform","description":"If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much.","keywords":[],"articleBody":"      If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much.\nAnd this was the case for the project that I’m working on. We decided to start integrating KMP and we thought that the perfect target to start with is the DTOs. Because in this way we can define a single source of truth and share it on the backend and the mobile clients. But how to start using KMP in an existing project, is a topic for another article, so stay tuned!\nIn this article, I will show you how to implement a Kotlin Multiplatform Mobile application that performs a network call on the native side with Retrofit (on Android) and Alamofire (on iOs) but the DTOs are defined on KMP side as well as the information about deserialization. And for the deserialization, I will use (of course) the Kotlin Serialization library.\nAPI For this example I will use the Bored Api that returns this kind of response:\n{ \"activity\": \"Learn the NATO phonetic alphabet\", \"type\": \"education\", \"participants\": 1, \"price\": 0, \"link\": \"https://en.wikipedia.org/wiki/NATO_phonetic_alphabet\", \"key\": \"6706598\", \"accessibility\": 0 } And this response can be mapped to a simple data class:\n@Serializable data class Activity( val activity: String, val type: String, val participants: Int, val price: Double, val link: String, val key: String, val accessibility: Double ) And this data class is placed inside the shared KMP module.\nAndroid Now, let’s move to the Android side and I start with Android because things are simpler. In fact, you can use Retrofit and the Kotlin Serialization Converter. All you need to do is add the Converter Factory for the Kotlin Serialization.\nRetrofit.Builder() .baseUrl(\"https://www.boredapi.com/api/\") .addConverterFactory(Json.asConverterFactory(MediaType.get(\"application/json\"))) .build() .create(ActivityApiService::class.java) iOs On iOs the equivalent to Retrofit is Alamofire. Alamofire let you easily handle the deserialization of the responses (and of course also the serialization of the requests) with the Decodable protocol (and Encodable - or Codable to support both Encodable and Decodable at the same time). For more information about Codable, I suggest you to look at the official documentation. But unfortunately there is no Codable support on Kotlin/Native (maybe it will come with direct interoperability with Swift - Kotlin Roadmap).\nCustom Response Deserialization with Alamofire Fortunately, Alamofire gives the possibility to write a custom response serializer. The starting point is a struct that extends ResponseSerializer; this struct overrides the serialize method, which “does some magics” and returns the desired deserialized object, represented by the generic T.\nstruct CustomSerializer: ResponseSerializer { func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws - T { // TODO } } Before performing the object deserialization, a string representation of the response must be computed. To do that, I will use the StringResponseSerializer provided by Alamofire.\nlet jsonString = try StringResponseSerializer().serialize(request: request, response: response, data: data, error: error) And then, this string will be sent to a Kotlin helper function that performs the actual deserialization.\nval deserializedObject = JsonDecoder().decodeFromString(jsonString: “{}”) And at the end, the custom Alamofire deserializer will look something like this (with also a bit of error handling):\nimport Alamofire import shared struct CustomSerializer: ResponseSerializer { func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws - T { guard error == nil else { throw error! } guard let data = data, !data.isEmpty else { guard emptyResponseAllowed(forRequest: request, response: response) else { throw AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength) } guard let emptyResponseType = T.self as? EmptyResponse.Type, let emptyValue = emptyResponseType.emptyValue() as? T else { throw AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: \"\\(T.self)\")) } return emptyValue } do { let jsonString = try StringResponseSerializer().serialize(request: request, response: response, data: data, error: error) val deserializedObject = JsonDecoder().decodeFromString(jsonString: “{}”) return deserializedObject } catch { throw AFError.responseSerializationFailed(reason: .decodingFailed(error: error)) } } } And then, the ViewModel can make the network request using the custom serializer.\nAF.request(\"https://www.boredapi.com/api/activity\") .response(responseSerializer: CustomSerializer()) { response in if let activity = response.value { DispatchQueue.main.async { self.showLoading = false self.activityName = activity.activity } } } Deserialization on Kotlin/Native Now let’s move back to KMP, and let’s implement the decodeFromString function mentioned above.\nThe first thing that popped into my mind is to use an inline reified function that works with generics (for more info about inline functions and reified parameters, give a look to the Kotlin documentation).\nobject JsonDecoder { @Throws(Exception::class) inline fun reified T decodeFromString(jsonString: String): T { return Json.decodeFromString(jsonString) } } But unfortunately, this approach does not work because Swift doesn’t have inline functions support.\n{ KotlinException = \"kotlin.IllegalStateException: unsupported call of reified inlined function `com.prof18.sharedserialization.shared.JsonDecoder.decodeFromString`\"; KotlinExceptionOrigin = \"\"; NSLocalizedDescription = \"unsupported call of reified inlined function com.prof18.sharedserialization.shared.JsonDecoder.decodeFromString`\"; } So, after a bit of exploring of the Kotlin Serialization documentation and sources, I’ve discovered that there is the possibility to get the serializer of a KClass (KClass.serializer()) and then pass it to the decodeFromString function.\nobject JsonDecoder { @InternalSerializationApi fun decodeFromString(jsonString: String, objCClass: ObjCClass): Any { val kClazz = getOriginalKotlinClass(objCClass)!! val serializer = kClazz.serializer() return Json.decodeFromString(serializer, jsonString) } } This approach works! But unfortunately, the KClass.serializer() is an internal API. And (as stated in the documentation) it doesn’t work with generic classes, lists, custom serializers, etc (I’ve opened an issue on GitHub just to be sure).\nSo, given the limitations of using an internal API, I’ve decided to change (again!) approach. Since it is hard to create generic deserialization, it is better to specify the deserialization information for every DTO. To do that, I have defined an abstract class with an abstract deserialize method that every DTOs has to implement.\nabstract class BaseResponseDTO { @Throws(Exception::class) abstract fun deserialize(jsonString: String): BaseResponseDTO } So, the Activity class defined above need to override the deserialize method.\n@Serializable data class Activity( ... ) : BaseResponseDTO() { override fun deserialize(jsonString: String): Activity { val activity: Activity = Json.decodeFromString(jsonString) activity.freeze() return activity } } Now, some modifications must be made to the custom Alamofire deserializer. First of all, the accepted generic type is not T only, but T that inherits from BaseResponseDTO\nstruct CustomSerializer: ResponseSerializer { func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws - T { ... } } In this way, we can retrieve the serializer from the abstract class, deserialize the object and return it.\nlet deserializedObject = try T().deserialize(jsonString: jsonString) as! T And finally, this works!\nHere’s the full code of the updated serializer.\nimport Alamofire import shared struct CustomSerializer: ResponseSerializer { func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws - T { guard error == nil else { throw error! } guard let data = data, !data.isEmpty else { guard emptyResponseAllowed(forRequest: request, response: response) else { throw AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength) } guard let emptyResponseType = T.self as? EmptyResponse.Type, let emptyValue = emptyResponseType.emptyValue() as? T else { throw AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: \"\\(T.self)\")) } return emptyValue } do { let jsonString = try StringResponseSerializer().serialize(request: request, response: response, data: data, error: error) let deserializedObject = try T().deserialize(jsonString: jsonString) as! T deserializedObject.makeFrozen() return deserializedObject } catch { throw AFError.responseSerializationFailed(reason: .decodingFailed(error: error)) } } } If you want to see all in action, I’ve published a little sample on my GitHub.\nIn the end, the result is a bit more boilerplate than what I’ve expected but not so much. I think that the benefits of having the DTOs defined in one place for both the clients and the backend are way higher than the “burden” of writing a bunch of lines of code for every DTOs.\n","wordCount":"1286","inLanguage":"en","datePublished":"2020-12-10T00:00:00Z","dateModified":"2020-12-10T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2020/kotlin-serialization-alamofire/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform</h1><div class=post-meta style=margin-top:16px><span title="2020-12-10 00:00:00 +0000 UTC">10 December 2020</span>&nbsp;·&nbsp;7 min</div></header><div class=post-content><div id=banner style=overflow:hidden;justify-content:space-around><div style=display:inline-block;margin-right:10px><a href=https://androidweekly.net/issues/issue-444><img style=margin:0 src=https://androidweekly.net/issues/issue-444/badge></a></div><div style=display:inline-block><a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=fc5413f3eb"><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23221-%237874b4></a></div></div><p>If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with <a href=https://kotlinlang.org/docs/mobile/use-ktor-for-networking.html>Ktor</a>. But if you don’t want to share the entire network layer but maybe only the DTOs?
There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much.</p><p>And this was the case for the project that I’m working on. We decided to start integrating KMP and we thought that the perfect target to start with is the DTOs. Because in this way we can define a single source of truth and share it on the backend and the mobile clients. But how to start using KMP in an existing project, is a topic for another article, so stay tuned!</p><p>In this article, I will show you how to implement a Kotlin Multiplatform Mobile application that performs a network call on the native side with Retrofit (on Android) and Alamofire (on iOs) but the DTOs are defined on KMP side as well as the information about deserialization. And for the deserialization, I will use (of course) the <a href=https://github.com/Kotlin/kotlinx.serialization>Kotlin Serialization library</a>.</p><h2 id=api>API<a hidden class=anchor aria-hidden=true href=#api>#</a></h2><p>For this example I will use the <a href=https://www.boredapi.com/>Bored Api</a> that returns this kind of response:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;activity&#34;</span>: <span style=color:#e6db74>&#34;Learn the NATO phonetic alphabet&#34;</span>,
  <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;education&#34;</span>,
  <span style=color:#f92672>&#34;participants&#34;</span>: <span style=color:#ae81ff>1</span>,
  <span style=color:#f92672>&#34;price&#34;</span>: <span style=color:#ae81ff>0</span>,
  <span style=color:#f92672>&#34;link&#34;</span>: <span style=color:#e6db74>&#34;https://en.wikipedia.org/wiki/NATO_phonetic_alphabet&#34;</span>,
  <span style=color:#f92672>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;6706598&#34;</span>,
  <span style=color:#f92672>&#34;accessibility&#34;</span>: <span style=color:#ae81ff>0</span>
}
</code></pre></div><p>And this response can be mapped to a simple data class:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@Serializable</span>
<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Activity</span>(
    <span style=color:#66d9ef>val</span> activity: String,
    <span style=color:#66d9ef>val</span> type: String,
    <span style=color:#66d9ef>val</span> participants: Int,
    <span style=color:#66d9ef>val</span> price: Double,
    <span style=color:#66d9ef>val</span> link: String,
    <span style=color:#66d9ef>val</span> key: String,
    <span style=color:#66d9ef>val</span> accessibility: Double
)
</code></pre></div><p>And this data class is placed inside the shared KMP module.</p><h2 id=android>Android<a hidden class=anchor aria-hidden=true href=#android>#</a></h2><p>Now, let’s move to the Android side and I start with Android because things are simpler. In fact, you can use <a href=https://github.com/square/retrofit>Retrofit</a> and the <a href=https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter>Kotlin Serialization Converter</a>. All you need to do is add the <code>Converter Factory</code> for the Kotlin Serialization.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>Retrofit.Builder()
    .baseUrl(<span style=color:#e6db74>&#34;https://www.boredapi.com/api/&#34;</span>)
    .addConverterFactory(Json.asConverterFactory(MediaType.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#34;application/json&#34;</span>)))
    .build()
    .create(ActivityApiService<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java)
</code></pre></div><h2 id=ios>iOs<a hidden class=anchor aria-hidden=true href=#ios>#</a></h2><p>On iOs the equivalent to Retrofit is <a href=https://github.com/Alamofire/Alamofire>Alamofire</a>. Alamofire let you easily handle the deserialization of the responses (and of course also the serialization of the requests) with the <code>Decodable</code> protocol (and <code>Encodable</code> - or <code>Codable</code> to support both <code>Encodable</code> and <code>Decodable</code> at the same time). For more information about <code>Codable</code>, I suggest you to look at the <a href=https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types>official documentation</a>.
But unfortunately there is <a href=https://github.com/JetBrains/kotlin-native/issues/2978>no Codable support on Kotlin/Native</a> (maybe it will come with direct interoperability with Swift - <a href=https://kotlinlang.org/roadmap.html>Kotlin Roadmap</a>).</p><h3 id=custom-response-deserialization-with-alamofire>Custom Response Deserialization with Alamofire<a hidden class=anchor aria-hidden=true href=#custom-response-deserialization-with-alamofire>#</a></h3><p>Fortunately, Alamofire gives the possibility to write <a href=https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#creating-a-custom-response-serializer>a custom response serializer</a>. The starting point is a <code>struct</code> that extends <code>ResponseSerializer</code>; this <code>struct</code> overrides the <code>serialize</code> method, which “does some magics” and returns the desired deserialized object, represented by the generic <code>T</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSerializer</span>&lt;T&gt;: ResponseSerializer {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#66d9ef>throws</span> -&gt; T {
        <span style=color:#75715e>// TODO</span>
    }
}
</code></pre></div><p>Before performing the object deserialization, a string representation of the response must be computed. To do that, I will use the <code>StringResponseSerializer</code> provided by Alamofire.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> jsonString = <span style=color:#66d9ef>try</span> StringResponseSerializer().serialize(request: request, response: response, data: data, error: error)
</code></pre></div><p>And then, this string will be sent to a Kotlin helper function that performs the actual deserialization.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> deserializedObject = JsonDecoder().decodeFromString(jsonString: <span style=color:#960050;background-color:#1e0010>“</span>{}<span style=color:#960050;background-color:#1e0010>”</span>)
</code></pre></div><p>And at the end, the custom Alamofire deserializer will look something like this (with also a bit of error handling):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Alamofire</span>
<span style=color:#66d9ef>import</span> <span style=color:#a6e22e>shared</span>

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSerializer</span>&lt;T&gt;: ResponseSerializer {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#66d9ef>throws</span> -&gt; T {
        
        <span style=color:#66d9ef>guard</span> error == <span style=color:#66d9ef>nil</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>throw</span> error! }
        
        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> data = data, <span style=color:#f92672>!</span>data.isEmpty <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>guard</span> emptyResponseAllowed(forRequest: request, response: response) <span style=color:#66d9ef>else</span> {
                <span style=color:#66d9ef>throw</span> AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
            }
            
            <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> emptyResponseType = T.<span style=color:#66d9ef>self</span> <span style=color:#66d9ef>as</span>? EmptyResponse.<span style=color:#66d9ef>Type</span>, <span style=color:#66d9ef>let</span> emptyValue = emptyResponseType.emptyValue() <span style=color:#66d9ef>as</span>? T <span style=color:#66d9ef>else</span> {
                <span style=color:#66d9ef>throw</span> AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>T.<span style=color:#66d9ef>self</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>))
            }
            <span style=color:#66d9ef>return</span> emptyValue
        }
        
        <span style=color:#66d9ef>do</span> {
            <span style=color:#66d9ef>let</span> jsonString = <span style=color:#66d9ef>try</span> StringResponseSerializer().serialize(request: request, response: response, data: data, error: error)
            val deserializedObject = JsonDecoder().decodeFromString(jsonString: <span style=color:#960050;background-color:#1e0010>“</span>{}<span style=color:#960050;background-color:#1e0010>”</span>)
            <span style=color:#66d9ef>return</span> deserializedObject
            
        } <span style=color:#66d9ef>catch</span> {
            <span style=color:#66d9ef>throw</span> AFError.responseSerializationFailed(reason: .decodingFailed(error: error))
        }
    }
}
</code></pre></div><p>And then, the ViewModel can make the network request using the custom serializer.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>AF.request(<span style=color:#e6db74>&#34;https://www.boredapi.com/api/activity&#34;</span>)
    .response(responseSerializer: CustomSerializer&lt;Activity&gt;()) { response <span style=color:#66d9ef>in</span>
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> activity = response.value {
        DispatchQueue.main.async {
            <span style=color:#66d9ef>self</span>.showLoading = <span style=color:#66d9ef>false</span>
            <span style=color:#66d9ef>self</span>.activityName = activity.activity
        }
    }
}
</code></pre></div><h3 id=deserialization-on-kotlinnative>Deserialization on Kotlin/Native<a hidden class=anchor aria-hidden=true href=#deserialization-on-kotlinnative>#</a></h3><p>Now let’s move back to KMP, and let’s implement the <code>decodeFromString</code> function mentioned above.</p><p>The first thing that popped into my mind is to use an <code>inline reified</code> function that works with generics (for more info about inline functions and reified parameters, give a look to the <a href=https://kotlinlang.org/docs/reference/inline-functions.html>Kotlin documentation</a>).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>JsonDecoder</span> {
    <span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
    <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#66d9ef>reified</span> <span style=color:#a6e22e>T</span>&gt; <span style=color:#a6e22e>decodeFromString</span>(jsonString: String): T {
        <span style=color:#66d9ef>return</span> Json.decodeFromString(jsonString)
    }
}
</code></pre></div><p>But unfortunately, this approach does not work because Swift doesn’t have <code>inline</code> functions support.</p><pre><code>{
    KotlinException = &quot;kotlin.IllegalStateException: unsupported call of reified inlined function `com.prof18.sharedserialization.shared.JsonDecoder.decodeFromString`&quot;;
    KotlinExceptionOrigin = &quot;&quot;;
    NSLocalizedDescription = &quot;unsupported call of reified inlined function  com.prof18.sharedserialization.shared.JsonDecoder.decodeFromString`&quot;;
}
</code></pre><p>So, after a bit of exploring of the Kotlin Serialization documentation and sources, I’ve discovered that there is the possibility to get the serializer of a <code>KClass</code> (<code>KClass&lt;T>.serializer()</code>) and then pass it to the <code>decodeFromString</code> function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>JsonDecoder</span> {
    <span style=color:#a6e22e>@InternalSerializationApi</span>
    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>decodeFromString</span>(jsonString: String, objCClass: ObjCClass): Any {
        <span style=color:#66d9ef>val</span> kClazz = getOriginalKotlinClass(objCClass)<span style=color:#f92672>!!</span>
        <span style=color:#66d9ef>val</span> serializer = kClazz.serializer()
        <span style=color:#66d9ef>return</span> Json.decodeFromString(serializer, jsonString)
    }
}
</code></pre></div><p>This approach works! But unfortunately, the <code>KClass&lt;T>.serializer()</code> is an internal API. And (as stated <a href=https://github.com/Kotlin/kotlinx.serialization/blob/d24399eb388b0f45b7d55902d4563ded404dcf83/core/commonMain/src/kotlinx/serialization/Serializers.kt#L130>in the documentation</a>) it doesn&rsquo;t work with generic classes, lists, custom serializers, etc (I’ve opened an <a href=https://github.com/Kotlin/kotlinx.serialization/issues/1210>issue on GitHub</a> just to be sure).</p><p>So, given the limitations of using an internal API, I’ve decided to change (again!) approach. Since it is hard to create generic deserialization, it is better to specify the deserialization information for every DTO. To do that, I have defined an abstract class with an abstract deserialize method that every DTOs has to implement.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseResponseDTO</span> {
    <span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>deserialize</span>(jsonString: String): BaseResponseDTO   
}
</code></pre></div><p>So, the <code>Activity</code> class defined above need to override the <code>deserialize</code> method.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@Serializable</span>
<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Activity</span>(
  <span style=color:#f92672>..</span>.
) : BaseResponseDTO() {

    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>deserialize</span>(jsonString: String): Activity {
        <span style=color:#66d9ef>val</span> activity: Activity = Json.decodeFromString(jsonString)
        activity.freeze()        
        <span style=color:#66d9ef>return</span> activity
    }
}
</code></pre></div><p>Now, some modifications must be made to the custom Alamofire deserializer. First of all, the accepted generic type is not <code>T</code> only, but <code>T</code> that inherits from <code>BaseResponseDTO</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSerializer</span>&lt;T: BaseResponseDTO&gt;: ResponseSerializer {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#66d9ef>throws</span> -&gt; T {
        ...    
    }
}
</code></pre></div><p>In this way, we can retrieve the serializer from the abstract class, deserialize the object and return it.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> deserializedObject = <span style=color:#66d9ef>try</span> T().deserialize(jsonString: jsonString) <span style=color:#66d9ef>as</span>! T
</code></pre></div><p>And finally, this works!</p><p>Here’s the full code of the updated serializer.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Alamofire</span>
<span style=color:#66d9ef>import</span> <span style=color:#a6e22e>shared</span>

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomSerializer</span>&lt;T: BaseResponseDTO&gt;: ResponseSerializer {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#66d9ef>throws</span> -&gt; T {
        
        <span style=color:#66d9ef>guard</span> error == <span style=color:#66d9ef>nil</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>throw</span> error! }
        
        <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> data = data, <span style=color:#f92672>!</span>data.isEmpty <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>guard</span> emptyResponseAllowed(forRequest: request, response: response) <span style=color:#66d9ef>else</span> {
                <span style=color:#66d9ef>throw</span> AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
            }
            
            <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> emptyResponseType = T.<span style=color:#66d9ef>self</span> <span style=color:#66d9ef>as</span>? EmptyResponse.<span style=color:#66d9ef>Type</span>, <span style=color:#66d9ef>let</span> emptyValue = emptyResponseType.emptyValue() <span style=color:#66d9ef>as</span>? T <span style=color:#66d9ef>else</span> {
                <span style=color:#66d9ef>throw</span> AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>T.<span style=color:#66d9ef>self</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>))
            }
            <span style=color:#66d9ef>return</span> emptyValue
        }
        
        <span style=color:#66d9ef>do</span> {
            <span style=color:#66d9ef>let</span> jsonString = <span style=color:#66d9ef>try</span> StringResponseSerializer().serialize(request: request, response: response, data: data, error: error)
            <span style=color:#66d9ef>let</span> deserializedObject = <span style=color:#66d9ef>try</span> T().deserialize(jsonString: jsonString) <span style=color:#66d9ef>as</span>! T
            deserializedObject.makeFrozen()
            <span style=color:#66d9ef>return</span> deserializedObject
        } <span style=color:#66d9ef>catch</span> {
            <span style=color:#66d9ef>throw</span> AFError.responseSerializationFailed(reason: .decodingFailed(error: error))
        }
    }
}
</code></pre></div><p>If you want to see all in action, I’ve published a little sample <a href=https://github.com/prof18/shared-deserialization>on my GitHub</a>.</p><p>In the end, the result is a bit more boilerplate than what I’ve expected but not so much. I think that the benefits of having the DTOs defined in one place for both the clients and the backend are way higher than the “burden” of writing a bunch of lines of code for every DTOs.</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.marcogomiero.com/posts/2021/running-blog-ipad/><span class=title>« Prev</span><br><span>Running a blog with iPad</span></a>
<a class=next href=https://www.marcogomiero.com/posts/2020/kmm-shared-app-architecture/><span class=title>Next »</span><br><span>Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>