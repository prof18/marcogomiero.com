<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much."><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:title" content="Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform"><meta property="og:description" content="If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2020/kotlin-serialization-alamofire/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-10T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform"><meta name=twitter:description content="If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with Ktor. But if you don’t want to share the entire network layer but maybe only the DTOs? There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much."><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><script src=https://www.marcogomiero.com/js/feather.min.js></script>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.26c5bf79ef760a8f4feb8fc7be32ec86fc1f1da292b42c9fcc37879d4f774e3f.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write</span></a>
<a href=/talks/><span>Speak</span></a>
<a href=/projects/><span>Build</span></a>
<a href=/about-me/><span>About</span></a>
| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Using Retrofit and Alamofire with Kotlin Serialization on Kotlin Multiplatform</h1><div class=post-meta><span title='2020-12-10 00:00:00 +0000 UTC'>10 December 2020</span></div></div><section class=body><span class=raw-html><div class=post-award-container><a href=https://androidweekly.net/issues/issue-444><img src=https://androidweekly.net/issues/issue-444/badge></a>
<a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=fc5413f3eb"><img src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23221-%237874b4></a></div></span><p>If you are starting a project with Kotlin Multiplatform and you want to share the network layer, the best way to go is definitely with <a href=https://kotlinlang.org/docs/mobile/use-ktor-for-networking.html>Ktor</a>. But if you don’t want to share the entire network layer but maybe only the DTOs?
There could be many reasons for wanting this. Maybe you are starting to integrate Kotlin Multiplatform (I’ll call it KMP in the rest of the article) into an existing project and the work for sharing the entire network layer is simply too much.</p><p>And this was the case for the project that I’m working on. We decided to start integrating KMP and we thought that the perfect target to start with is the DTOs. Because in this way we can define a single source of truth and share it on the backend and the mobile clients. But how to start using KMP in an existing project, is a topic for another article, so stay tuned!</p><p>In this article, I will show you how to implement a Kotlin Multiplatform Mobile application that performs a network call on the native side with Retrofit (on Android) and Alamofire (on iOs) but the DTOs are defined on KMP side as well as the information about deserialization. And for the deserialization, I will use (of course) the <a href=https://github.com/Kotlin/kotlinx.serialization>Kotlin Serialization library</a>.</p><h2 id=api>API</h2><p>For this example I will use the <a href=https://www.boredapi.com/>Bored Api</a> that returns this kind of response:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;activity&#34;</span>: <span style=color:#5af78e>&#34;Learn the NATO phonetic alphabet&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;type&#34;</span>: <span style=color:#5af78e>&#34;education&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;participants&#34;</span>: <span style=color:#ff9f43>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;price&#34;</span>: <span style=color:#ff9f43>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;link&#34;</span>: <span style=color:#5af78e>&#34;https://en.wikipedia.org/wiki/NATO_phonetic_alphabet&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;key&#34;</span>: <span style=color:#5af78e>&#34;6706598&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>&#34;accessibility&#34;</span>: <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And this response can be mapped to a simple data class:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Serializable</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>Activity</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> activity: String,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> type: String,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> participants: Int,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> price: Double,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> link: String,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> key: String,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> accessibility: Double
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>And this data class is placed inside the shared KMP module.</p><h2 id=android>Android</h2><p>Now, let’s move to the Android side and I start with Android because things are simpler. In fact, you can use <a href=https://github.com/square/retrofit>Retrofit</a> and the <a href=https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter>Kotlin Serialization Converter</a>. All you need to do is add the <code>Converter Factory</code> for the Kotlin Serialization.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>Retrofit.Builder()
</span></span><span style=display:flex><span>    .baseUrl(<span style=color:#5af78e>&#34;https://www.boredapi.com/api/&#34;</span>)
</span></span><span style=display:flex><span>    .addConverterFactory(Json.asConverterFactory(MediaType.<span style=color:#ff6ac1>get</span>(<span style=color:#5af78e>&#34;application/json&#34;</span>)))
</span></span><span style=display:flex><span>    .build()
</span></span><span style=display:flex><span>    .create(ActivityApiService<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>.java)
</span></span></code></pre></div><h2 id=ios>iOs</h2><p>On iOs the equivalent to Retrofit is <a href=https://github.com/Alamofire/Alamofire>Alamofire</a>. Alamofire let you easily handle the deserialization of the responses (and of course also the serialization of the requests) with the <code>Decodable</code> protocol (and <code>Encodable</code> - or <code>Codable</code> to support both <code>Encodable</code> and <code>Decodable</code> at the same time). For more information about <code>Codable</code>, I suggest you to look at the <a href=https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types>official documentation</a>.
But unfortunately there is <a href=https://github.com/JetBrains/kotlin-native/issues/2978>no Codable support on Kotlin/Native</a> (maybe it will come with direct interoperability with Swift - <a href=https://kotlinlang.org/roadmap.html>Kotlin Roadmap</a>).</p><h3 id=custom-response-deserialization-with-alamofire>Custom Response Deserialization with Alamofire</h3><p>Fortunately, Alamofire gives the possibility to write <a href=https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#creating-a-custom-response-serializer>a custom response serializer</a>. The starting point is a <code>struct</code> that extends <code>ResponseSerializer</code>; this <code>struct</code> overrides the <code>serialize</code> method, which “does some magics” and returns the desired deserialized object, represented by the generic <code>T</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>struct</span> <span style=color:#f3f99d>CustomSerializer</span>&lt;T&gt;: ResponseSerializer {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#ff6ac1>throws</span> -&gt; T {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// TODO</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Before performing the object deserialization, a string representation of the response must be computed. To do that, I will use the <code>StringResponseSerializer</code> provided by Alamofire.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>let</span> <span style=color:#ff5c57>jsonString</span> = <span style=color:#ff6ac1>try</span> StringResponseSerializer().serialize(request: request, response: response, data: data, error: error)
</span></span></code></pre></div><p>And then, this string will be sent to a Kotlin helper function that performs the actual deserialization.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> deserializedObject = JsonDecoder().decodeFromString(jsonString: <span style=color:#ff5c57>“</span>{}<span style=color:#ff5c57>”</span>)
</span></span></code></pre></div><p>And at the end, the custom Alamofire deserializer will look something like this (with also a bit of error handling):</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>Alamofire</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>shared</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>struct</span> <span style=color:#f3f99d>CustomSerializer</span>&lt;T&gt;: ResponseSerializer {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#ff6ac1>throws</span> -&gt; T {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>guard</span> error == <span style=color:#ff6ac1>nil</span> <span style=color:#ff6ac1>else</span> { <span style=color:#ff6ac1>throw</span> error! }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>guard</span> <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>data</span> = data, <span style=color:#ff6ac1>!</span>data.isEmpty <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>guard</span> emptyResponseAllowed(forRequest: request, response: response) <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>throw</span> AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>guard</span> <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>emptyResponseType</span> = T.<span style=color:#ff6ac1>self</span> <span style=color:#ff6ac1>as</span>? EmptyResponse.<span style=color:#ff6ac1>Type</span>, <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>emptyValue</span> = emptyResponseType.emptyValue() <span style=color:#ff6ac1>as</span>? T <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>throw</span> AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>\(</span>T.<span style=color:#ff6ac1>self</span><span style=color:#5af78e>)</span><span style=color:#5af78e>&#34;</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>return</span> emptyValue
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>do</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>jsonString</span> = <span style=color:#ff6ac1>try</span> StringResponseSerializer().serialize(request: request, response: response, data: data, error: error)
</span></span><span style=display:flex><span>            val deserializedObject = JsonDecoder().decodeFromString(jsonString: <span style=color:#ff5c57>“</span>{}<span style=color:#ff5c57>”</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>return</span> deserializedObject
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        } <span style=color:#ff6ac1>catch</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>throw</span> AFError.responseSerializationFailed(reason: .decodingFailed(error: error))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then, the ViewModel can make the network request using the custom serializer.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>AF.request(<span style=color:#5af78e>&#34;https://www.boredapi.com/api/activity&#34;</span>)
</span></span><span style=display:flex><span>    .response(responseSerializer: CustomSerializer&lt;Activity&gt;()) { response <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>activity</span> = response.value {
</span></span><span style=display:flex><span>        DispatchQueue.main.async {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>self</span>.showLoading = <span style=color:#ff6ac1>false</span>
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>self</span>.activityName = activity.activity
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=deserialization-on-kotlinnative>Deserialization on Kotlin/Native</h3><p>Now let’s move back to KMP, and let’s implement the <code>decodeFromString</code> function mentioned above.</p><p>The first thing that popped into my mind is to use an <code>inline reified</code> function that works with generics (for more info about inline functions and reified parameters, give a look to the <a href=https://kotlinlang.org/docs/reference/inline-functions.html>Kotlin documentation</a>).</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>JsonDecoder</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@Throws</span>(Exception<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>inline</span> <span style=color:#ff6ac1>fun</span> &lt;<span style=color:#ff6ac1>reified</span> <span style=color:#f3f99d>T</span>&gt; <span style=color:#57c7ff>decodeFromString</span>(jsonString: String): T {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> Json.decodeFromString(jsonString)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But unfortunately, this approach does not work because Swift doesn’t have <code>inline</code> functions support.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>{
</span></span><span style=display:flex><span>    KotlinException = &#34;kotlin.IllegalStateException: unsupported call of reified inlined function `com.prof18.sharedserialization.shared.JsonDecoder.decodeFromString`&#34;;
</span></span><span style=display:flex><span>    KotlinExceptionOrigin = &#34;&#34;;
</span></span><span style=display:flex><span>    NSLocalizedDescription = &#34;unsupported call of reified inlined function  com.prof18.sharedserialization.shared.JsonDecoder.decodeFromString`&#34;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So, after a bit of exploring of the Kotlin Serialization documentation and sources, I’ve discovered that there is the possibility to get the serializer of a <code>KClass</code> (<code>KClass&lt;T>.serializer()</code>) and then pass it to the <code>decodeFromString</code> function.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>JsonDecoder</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@InternalSerializationApi</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>decodeFromString</span>(jsonString: String, objCClass: ObjCClass): Any {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> kClazz = getOriginalKotlinClass(objCClass)<span style=color:#ff6ac1>!!</span>
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> serializer = kClazz.serializer()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> Json.decodeFromString(serializer, jsonString)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This approach works! But unfortunately, the <code>KClass&lt;T>.serializer()</code> is an internal API. And (as stated <a href=https://github.com/Kotlin/kotlinx.serialization/blob/d24399eb388b0f45b7d55902d4563ded404dcf83/core/commonMain/src/kotlinx/serialization/Serializers.kt#L130>in the documentation</a>) it doesn&rsquo;t work with generic classes, lists, custom serializers, etc (I’ve opened an <a href=https://github.com/Kotlin/kotlinx.serialization/issues/1210>issue on GitHub</a> just to be sure).</p><p>So, given the limitations of using an internal API, I’ve decided to change (again!) approach. Since it is hard to create generic deserialization, it is better to specify the deserialization information for every DTO. To do that, I have defined an abstract class with an abstract deserialize method that every DTOs has to implement.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>BaseResponseDTO</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@Throws</span>(Exception<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>deserialize</span>(jsonString: String): BaseResponseDTO   
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So, the <code>Activity</code> class defined above need to override the <code>deserialize</code> method.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Serializable</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>Activity</span>(
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>..</span>.
</span></span><span style=display:flex><span>) : BaseResponseDTO() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>deserialize</span>(jsonString: String): Activity {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> activity: Activity = Json.decodeFromString(jsonString)
</span></span><span style=display:flex><span>        activity.freeze()        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> activity
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Update: If you are using the new memory model (enabled by default from Koltin 1.7.20), you don&rsquo;t need <code>activity.freeze()</code></p></blockquote><p>Now, some modifications must be made to the custom Alamofire deserializer. First of all, the accepted generic type is not <code>T</code> only, but <code>T</code> that inherits from <code>BaseResponseDTO</code></p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>struct</span> <span style=color:#f3f99d>CustomSerializer</span>&lt;T: BaseResponseDTO&gt;: ResponseSerializer {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#ff6ac1>throws</span> -&gt; T {
</span></span><span style=display:flex><span>        ...    
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this way, we can retrieve the serializer from the abstract class, deserialize the object and return it.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>let</span> <span style=color:#ff5c57>deserializedObject</span> = <span style=color:#ff6ac1>try</span> T().deserialize(jsonString: jsonString) <span style=color:#ff6ac1>as</span>! T
</span></span></code></pre></div><p>And finally, this works!</p><p>Here’s the full code of the updated serializer.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>Alamofire</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>shared</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>struct</span> <span style=color:#f3f99d>CustomSerializer</span>&lt;T: BaseResponseDTO&gt;: ResponseSerializer {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>serialize</span>(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) <span style=color:#ff6ac1>throws</span> -&gt; T {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>guard</span> error == <span style=color:#ff6ac1>nil</span> <span style=color:#ff6ac1>else</span> { <span style=color:#ff6ac1>throw</span> error! }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>guard</span> <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>data</span> = data, <span style=color:#ff6ac1>!</span>data.isEmpty <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>guard</span> emptyResponseAllowed(forRequest: request, response: response) <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>throw</span> AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>guard</span> <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>emptyResponseType</span> = T.<span style=color:#ff6ac1>self</span> <span style=color:#ff6ac1>as</span>? EmptyResponse.<span style=color:#ff6ac1>Type</span>, <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>emptyValue</span> = emptyResponseType.emptyValue() <span style=color:#ff6ac1>as</span>? T <span style=color:#ff6ac1>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>throw</span> AFError.responseSerializationFailed(reason: .invalidEmptyResponse(type: <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>\(</span>T.<span style=color:#ff6ac1>self</span><span style=color:#5af78e>)</span><span style=color:#5af78e>&#34;</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>return</span> emptyValue
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>do</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>jsonString</span> = <span style=color:#ff6ac1>try</span> StringResponseSerializer().serialize(request: request, response: response, data: data, error: error)
</span></span><span style=display:flex><span>            <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>deserializedObject</span> = <span style=color:#ff6ac1>try</span> T().deserialize(jsonString: jsonString) <span style=color:#ff6ac1>as</span>! T
</span></span><span style=display:flex><span>            deserializedObject.makeFrozen()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>return</span> deserializedObject
</span></span><span style=display:flex><span>        } <span style=color:#ff6ac1>catch</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>throw</span> AFError.responseSerializationFailed(reason: .decodingFailed(error: error))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Update: If you are using the new memory model (enabled by default from Koltin 1.7.20), you don&rsquo;t need <code>deserializedObject.makeFrozen()</code></p></blockquote><p>If you want to see all in action, I’ve published a little sample <a href=https://github.com/prof18/shared-deserialization>on my GitHub</a>.</p><p>In the end, the result is a bit more boilerplate than what I’ve expected but not so much. I think that the benefits of having the DTOs defined in one place for both the clients and the backend are way higher than the “burden” of writing a bunch of lines of code for every DTOs.</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-69FZ1TLE7E","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>