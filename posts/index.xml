<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - Marco Gomiero</title><link>https://www.marcogomiero.com/posts/</link><description>All Posts | Marco Gomiero</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 30 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.marcogomiero.com/posts/" rel="self" type="application/rss+xml"/><item><title>Building an XCFramework on Kotlin Multiplatform from Kotlin 1.5.30</title><link>https://www.marcogomiero.com/posts/2021/kmp-xcframework-official-support/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/kmp-xcframework-official-support/</guid><description>A few days ago, Kotlin 1.5.30 has been released. One of the features contained in the release is the official support for XCFrameworks on Kotlin Multiplatform.
XCFramework is a binary that can contain multiple platform-specific variants (even for iOS and macOS at the same time). It has been introduced by Apple during the WWDC 2019 as a replacement for FatFrameworks.
Before Kotlin 1.5.30, an XCFramework could be created only by running the xcrun command that will pack the frameworks for every different required platform into an XCFramework.</description></item><item><title>How to build an XCFramework on Kotlin Multiplatform</title><link>https://www.marcogomiero.com/posts/2021/build-xcframework-kmp/</link><pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/build-xcframework-kmp/</guid><description>When you start integrating Kotlin Multiplatform (I’ll call it KMP in the rest of the article) in an existing project you most likely don’t have a mono-repo structure (and making a refactor to achieve this kind of architecture will not be easy). An example of architecture is the following, with a repository for every platform.
To understand how to integrate KMP into existing code, give a look at my previous article: “Introducing Kotlin Multiplatform in an existing project”</description></item><item><title>Connect to Open VPN during Gitlab Pipeline</title><link>https://www.marcogomiero.com/posts/2021/gitlab-pipeline-vpn/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/gitlab-pipeline-vpn/</guid><description>Gitlab CI/CD offers the possibility to create a pipeline, which runs when something changes in the repository. A pipeline consists of one or more stages that run in order and in these stages, for example, it is possible to build the project, run the tests, create the artifacts, etc. For more information about Gitlab CI/CD, I suggest you look over the documentation.
These out-of-the-box solutions really simplify the work to be done to have a CI up and running.</description></item><item><title>How to persist Ktor logs</title><link>https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/ktor-logging-on-disk/</guid><description>SERIES: Building a backend with Ktor Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs Logs are a vital part of software development. They can be used for debugging, to track specific events during the lifecycle of the product, or to discover unexpected events.
Usually, logs are printed in the system output, so they must be saved somewhere to be accessed and read sometime in the future.</description></item><item><title>Structuring a Ktor project</title><link>https://www.marcogomiero.com/posts/2021/ktor-project-structure/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/ktor-project-structure/</guid><description>SERIES: Building a backend with Ktor Part 1: Structuring a Ktor project Part 2: How to persist Ktor logs It’s been a few months since I’ve started working with Ktor to build the backend of Revelop. We decided to go with Ktor because it is a lightweight framework, easy to use and with a gentle learning curve even for a mobile developer.</description></item><item><title>My audio &amp; video setup after 4 years of remote working</title><link>https://www.marcogomiero.com/posts/2021/audio-video-setup/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/audio-video-setup/</guid><description>I’ve been working remotely for a while and during these years I kept improving my work setup. During the last year, I’ve also increased the overall video and audio quality and now I’m pretty confident I’ve ended up with something worth sharing.
A little note before moving on. Some gears I will share are cheap and others are expensive but I think that every product is one of the best that can be found in its price range.</description></item><item><title>Introducing KMP FatFramework Cocoa, a Gradle plugin for iOS FatFramework</title><link>https://www.marcogomiero.com/posts/2021/kmp-fatframework-cocoa-release/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/kmp-fatframework-cocoa-release/</guid><description>Today I want to share KMP FatFramework Cocoa, a Gradle plugin for Kotlin Multiplatform projects that generate a FatFramework for iOS targets and manages the publishing process in a CocoaPod Repository.
The plugin is born from a set of unbundled Gradle tasks that I wrote to manage the building and the publishing process of Kotlin Multiplatform libraries for iOS that we use at Uniwhere and Revelop. The libraries are published in a FatFramework that contains the code for every required architecture (real devices use the Arm64 architecture, while the simulator uses the host computer architecture which in most of the cases is X64).</description></item><item><title>Introducing Kotlin Multiplatform in an existing project</title><link>https://www.marcogomiero.com/posts/2021/kmp-existing-project/</link><pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/kmp-existing-project/</guid><description>After discovering a new interesting technology or framework, you will probably start asking yourself how to integrate it into an existing project. That’s because, the possibility to start with a blank canvas is rare (not impossible, but rare).
This is also the case for Kotlin Multiplatform (I’ll call it KMP in the rest of the article).
When starting a new blank KMP project it is easier to have a mono-repo structure like this:</description></item><item><title>Migrating old artifacts from JCenter to MavenCentral</title><link>https://www.marcogomiero.com/posts/2021/move-libray-jcenter-to-maven/</link><pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/move-libray-jcenter-to-maven/</guid><description>As you may have heard, JCenter is shutting down in May 2021.
Into the Sunset on May 1st: Bintray, JCenter, GoCenter, and ChartCenter
https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/
So, if you are using JCenter as the repository for your libraries (as me), it’s time to migrate.
In this article, I will not go through the publishing process of a library to MavenCentral, because there are already plenty of resources available. For example, I followed the one written by Márton Braun.</description></item><item><title>Running a blog with iPad</title><link>https://www.marcogomiero.com/posts/2021/running-blog-ipad/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><author>Author</author><guid>https://www.marcogomiero.com/posts/2021/running-blog-ipad/</guid><description><![CDATA[It’s been a few years since I started writing this blog, and I quite like sharing my thoughts and experiences. After a short while spent on Medium, I decided I wanted to be the sole owner of my content, so I started experimenting with different solutions and ideas. After I finally landed on the &ldquo;perfect&rdquo; tech architecture (I know, I’m lying. There’s no perfect solution and Future Me will most likely refactor and (over)re-engineer the current solution), I started to seek the &ldquo;perfect&rdquo; writing setup.]]></description></item></channel></rss>