<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Organize your Views: SwiftUI edition | Marco Gomiero</title><meta name=keywords content><meta name=description content="One of the pros of SwiftUI, and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the application uses.
With SwiftUI, it is not necessary anymore to bridge the UI definitions from somewhere else, resulting in a decrease of context switching between two different environments (Storyboards and Swift code, for example)
But “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2023/organize-view-swiftui-edition/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><meta property="og:title" content="Organize your Views: SwiftUI edition"><meta property="og:description" content="One of the pros of SwiftUI, and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the application uses.
With SwiftUI, it is not necessary anymore to bridge the UI definitions from somewhere else, resulting in a decrease of context switching between two different environments (Storyboards and Swift code, for example)
But “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2023/organize-view-swiftui-edition/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-23T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Organize your Views: SwiftUI edition"><meta name=twitter:description content="One of the pros of SwiftUI, and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the application uses.
With SwiftUI, it is not necessary anymore to bridge the UI definitions from somewhere else, resulting in a decrease of context switching between two different environments (Storyboards and Swift code, for example)
But “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Organize your Views: SwiftUI edition","item":"https://www.marcogomiero.com/posts/2023/organize-view-swiftui-edition/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Organize your Views: SwiftUI edition","name":"Organize your Views: SwiftUI edition","description":"One of the pros of SwiftUI, and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the application uses.\nWith SwiftUI, it is not necessary anymore to bridge the UI definitions from somewhere else, resulting in a decrease of context switching between two different environments (Storyboards and Swift code, for example)\nBut “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization.","keywords":[],"articleBody":"One of the pros of SwiftUI, and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the application uses.\nWith SwiftUI, it is not necessary anymore to bridge the UI definitions from somewhere else, resulting in a decrease of context switching between two different environments (Storyboards and Swift code, for example)\nBut “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization. Long files, large structs, and stateful UI components that hinder reusability are examples that can lead to a messed codebase.\nIn this article, I will show how I organized the codebase of MoneyFlow, a money management app written with Kotlin Multiplatform, Jetpack Compose, and Swift UI.\nI wrote a similar article that covers the same topic for Jetpack Compose, the declarative UI framework for Android: “Organize your Views: Jetpack Compose edition”\nScreens Code Structure To easily reach the entry point of a screen, I’ve decided to embrace the following structure. Every screen has a single Swift file containing the screen’s View Struct, and the screen’s preview.\nFor example, for the MoneyFlow Home Screen, there is a HomeScreen.swift file that contains HomeScreen, and HomeScreen_Previews .\n// HomeScreen.swift struct HomeScreen: View { var body: some View { ... } } struct HomeScreen_Previews: PreviewProvider { static var previews: some View { HomeScreen() } } The screen’s struct should just be an entry point and should not contain the entire screen’s code to avoid growing the length of the class too much. Every piece of UI can be split into smaller (maybe even reusable) components.\nTo improve testability and increase reusability, the screen’s struct (and in general, all SwiftUI views) should be stateless. To achieve stateless views, the state needs to be hoisted.\nState hoisting is a pattern of moving state to a view’s caller. Instead of passing a state variable to a function or even a reference to the ViewModel, only the current values to display and callbacks to react on events are passed.\nstruct HomeScreenContent: View { @Binding var appErrorData: SnackbarData @Binding var screenErrorData: SnackbarData @Binding var homeModel: HomeModel let onAppear : () -\u003e Void let deleteTransaction: (Int64) -\u003e Void @State private var showAddTransaction = false var body: some View { ... } } This way, a view can be reused or tested in different scenarios without any external dependencies.\nThe connection with the ViewModel and with external dependencies is made in another View, only responsible for the connection.\nstruct HomeScreen: View { @EnvironmentObject var appState: AppState @StateObject var viewModel: HomeViewModel = HomeViewModel() var body: some View { HomeScreenContent( appErrorData: $appState.snackbarData, screenErrorData: $viewModel.snackbarData, homeModel: $viewModel.homeModel, onAppear: { viewModel.startObserving() }, deleteTransaction: { transactionId in viewModel.deleteTransaction(transactionId: transactionId) } ) } } To ensure that state hoisting is done correctly without any dependency, a rule of thumb is to write views’s previews. That’s because a Preview, for example, won’t easily work with external dependencies.\nstruct HomeScreen_Previews: PreviewProvider { static var previews: some View { HomeScreenContent( appErrorData: .constant(SnackbarData.init()), screenErrorData: .constant(SnackbarData.init()), homeModel: .constant( HomeModel.HomeState( balanceRecap: BalanceRecap(totalBalance: 100, monthlyIncome: 150, monthlyExpenses: 50), latestTransactions: [ MoneyTransaction( id: 1, title: \"Transaction\", icon: CategoryIcon.icAddressBook, amount: 50, type: TransactionTypeUI.expense, milliseconds: 123456, formattedDate: \"20/10/21\" ) ] ) ), onAppear: {}, deleteTransaction: {_ in } ) HomeScreenContent( appErrorData: .constant(SnackbarData.init()), screenErrorData: .constant(SnackbarData.init()), homeModel: .constant(HomeModel.Loading()) , onAppear: {}, deleteTransaction: {_ in } ) HomeScreenContent( appErrorData: .constant( SnackbarData( title: \"An error occoured\", subtitle: \"Error code 1012\", showBanner: true ) ), screenErrorData: .constant(SnackbarData.init()), homeModel: .constant( HomeModel.Error( uiErrorMessage: UIErrorMessage( message: \"Error!\", nerdMessage: \"Error code: 101\" ) ) ) , onAppear: {}, deleteTransaction: {_ in } ) } } And that’s all. With this approach, the readability and maintainability of the project really increased, especially when opening it after a few months of inactivity.\nYou can find all the code mentioned in the article on GitHub.\n","wordCount":"635","inLanguage":"en","datePublished":"2023-03-23T00:00:00Z","dateModified":"2023-03-23T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2023/organize-view-swiftui-edition/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Organize your Views: SwiftUI edition</h1><div class=post-meta style=margin-top:16px><span title='2023-03-23 00:00:00 +0000 UTC'>23 March 2023</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>One of the pros of SwiftUI, and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the application uses.</p><p>With SwiftUI, it is not necessary anymore to bridge the UI definitions from somewhere else, resulting in a decrease of context switching between two different environments (Storyboards and Swift code, for example)</p><p>But “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization. Long files, large structs, and stateful UI components that hinder reusability are examples that can lead to a messed codebase.</p><p>In this article, I will show how I organized the codebase of <a href=https://github.com/prof18/MoneyFlow>MoneyFlow</a>, a money management app written with Kotlin Multiplatform, Jetpack Compose, and Swift UI.</p><blockquote><p>I wrote a similar article that covers the same topic for Jetpack Compose, the declarative UI framework for Android: <a href=posts/2023/organize-view-compose-edition>“Organize your Views: Jetpack Compose edition”</a></p></blockquote><h2 id=screens-code-structure>Screens Code Structure<a hidden class=anchor aria-hidden=true href=#screens-code-structure>#</a></h2><p>To easily reach the entry point of a screen, I’ve decided to embrace the following structure.
Every screen has a single Swift file containing the screen’s View Struct, and the screen’s preview.</p><p>For example, for the MoneyFlow Home Screen, there is a <code>HomeScreen.swift</code> file that contains <code>HomeScreen</code>, and <code>HomeScreen_Previews </code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// HomeScreen.swift</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HomeScreen</span>: View {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HomeScreen_Previews</span>: PreviewProvider {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>var</span> previews: some View {
</span></span><span style=display:flex><span>        HomeScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}        
</span></span></code></pre></div><p>The screen’s struct should just be an entry point and should not contain the entire screen’s code to avoid growing the length of the class too much. Every piece of UI can be split into smaller (maybe even reusable) components.</p><p>To improve testability and increase reusability, the screen’s struct (and in general, all SwiftUI views) should be stateless. To achieve stateless views, the state needs to be hoisted.</p><p>State hoisting is a pattern of moving state to a view&rsquo;s caller. Instead of passing a state variable to a function or even a reference to the ViewModel, only the current values to display and callbacks to react on events are passed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HomeScreenContent</span>: View {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Binding <span style=color:#66d9ef>var</span> appErrorData: SnackbarData
</span></span><span style=display:flex><span>    @Binding <span style=color:#66d9ef>var</span> screenErrorData: SnackbarData
</span></span><span style=display:flex><span>    @Binding <span style=color:#66d9ef>var</span> homeModel: HomeModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> onAppear  : () -&gt; Void
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> deleteTransaction: (Int64) -&gt; Void
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @State <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> showAddTransaction = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>	   ...
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, a view can be reused or tested in different scenarios without any external dependencies.</p><p>The connection with the ViewModel and with external dependencies is made in another View, only responsible for the connection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HomeScreen</span>: View {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @EnvironmentObject <span style=color:#66d9ef>var</span> appState: AppState
</span></span><span style=display:flex><span>    @StateObject <span style=color:#66d9ef>var</span> viewModel: HomeViewModel = HomeViewModel()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        HomeScreenContent(
</span></span><span style=display:flex><span>            appErrorData: <span style=color:#960050;background-color:#1e0010>$</span>appState.snackbarData,
</span></span><span style=display:flex><span>            screenErrorData: <span style=color:#960050;background-color:#1e0010>$</span>viewModel.snackbarData,
</span></span><span style=display:flex><span>            homeModel: <span style=color:#960050;background-color:#1e0010>$</span>viewModel.homeModel,
</span></span><span style=display:flex><span>            onAppear: { viewModel.startObserving() },
</span></span><span style=display:flex><span>            deleteTransaction: { transactionId <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                viewModel.deleteTransaction(transactionId: transactionId)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To ensure that state hoisting is done correctly without any dependency, a rule of thumb is to write views’s previews. That’s because a Preview, for example, won’t easily work with external dependencies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HomeScreen_Previews</span>: PreviewProvider {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>var</span> previews: some View {
</span></span><span style=display:flex><span>        HomeScreenContent(
</span></span><span style=display:flex><span>            appErrorData: .constant(SnackbarData.<span style=color:#66d9ef>init</span>()),
</span></span><span style=display:flex><span>            screenErrorData: .constant(SnackbarData.<span style=color:#66d9ef>init</span>()),
</span></span><span style=display:flex><span>            homeModel: .constant(
</span></span><span style=display:flex><span>                HomeModel.HomeState(
</span></span><span style=display:flex><span>                    balanceRecap: BalanceRecap(totalBalance: <span style=color:#ae81ff>100</span>, monthlyIncome: <span style=color:#ae81ff>150</span>, monthlyExpenses: <span style=color:#ae81ff>50</span>),
</span></span><span style=display:flex><span>                    latestTransactions: [
</span></span><span style=display:flex><span>                        MoneyTransaction(
</span></span><span style=display:flex><span>                            id: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                            title: <span style=color:#e6db74>&#34;Transaction&#34;</span>,
</span></span><span style=display:flex><span>                            icon: CategoryIcon.icAddressBook,
</span></span><span style=display:flex><span>                            amount: <span style=color:#ae81ff>50</span>,
</span></span><span style=display:flex><span>                            type: TransactionTypeUI.expense,
</span></span><span style=display:flex><span>                            milliseconds: <span style=color:#ae81ff>123456</span>,
</span></span><span style=display:flex><span>                            formattedDate: <span style=color:#e6db74>&#34;20/10/21&#34;</span>
</span></span><span style=display:flex><span>                        )
</span></span><span style=display:flex><span>                    ]
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            onAppear: {},
</span></span><span style=display:flex><span>            deleteTransaction: {<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HomeScreenContent(
</span></span><span style=display:flex><span>            appErrorData: .constant(SnackbarData.<span style=color:#66d9ef>init</span>()),
</span></span><span style=display:flex><span>            screenErrorData: .constant(SnackbarData.<span style=color:#66d9ef>init</span>()),
</span></span><span style=display:flex><span>            homeModel: .constant(HomeModel.Loading()) ,
</span></span><span style=display:flex><span>            onAppear: {},
</span></span><span style=display:flex><span>            deleteTransaction: {<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HomeScreenContent(
</span></span><span style=display:flex><span>            appErrorData: .constant(
</span></span><span style=display:flex><span>                SnackbarData(
</span></span><span style=display:flex><span>                    title: <span style=color:#e6db74>&#34;An error occoured&#34;</span>,
</span></span><span style=display:flex><span>                    subtitle: <span style=color:#e6db74>&#34;Error code 1012&#34;</span>,
</span></span><span style=display:flex><span>                    showBanner: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            screenErrorData: .constant(SnackbarData.<span style=color:#66d9ef>init</span>()),
</span></span><span style=display:flex><span>            homeModel: .constant(
</span></span><span style=display:flex><span>                HomeModel.Error(
</span></span><span style=display:flex><span>                    uiErrorMessage: UIErrorMessage(
</span></span><span style=display:flex><span>                        message: <span style=color:#e6db74>&#34;Error!&#34;</span>,
</span></span><span style=display:flex><span>                        nerdMessage: <span style=color:#e6db74>&#34;Error code: 101&#34;</span>
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            ) ,
</span></span><span style=display:flex><span>            onAppear: {},
</span></span><span style=display:flex><span>            deleteTransaction: {<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span> }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that’s all. With this approach, the readability and maintainability of the project really increased, especially when opening it after a few months of inactivity.</p><p>You can find all the code mentioned in the article on <a href=https://github.com/prof18/MoneyFlow>GitHub</a>.</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>