<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Organize your Views: Jetpack Compose edition - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.
With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code)."><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:url" content="https://www.marcogomiero.com/posts/2023/organize-view-compose-edition/"><meta property="og:site_name" content="Marco Gomiero"><meta property="og:title" content="Organize your Views: Jetpack Compose edition"><meta property="og:description" content="One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.
With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-15T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Organize your Views: Jetpack Compose edition"><meta name=twitter:description content="One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.
With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code)."><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E")}</script><script src=https://www.marcogomiero.com//js/feather.min.js></script><link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.26c5bf79ef760a8f4feb8fc7be32ec86fc1f1da292b42c9fcc37879d4f774e3f.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com/><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write
</span></a><a href=/talks/><span>Speak
</span></a><a href=/projects/><span>Build
</span></a><a href=/about-me/><span>About
</span></a>| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com//js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Organize your Views: Jetpack Compose edition</h1><div class=post-meta>&lt;span title='2023-03-15 00:00:00 +0000 UTC'>15 March 2023&lt;/span></div></div><section class=body><span class=raw-html><div class=post-award-container><a href=https://androidweekly.net/issues/issue-562><img src=https://androidweekly.net/issues/issue-562/badge>
</a><a href=https://jetc.dev/issues/157.html><img src="https://img.shields.io/badge/As_Seen_In-jetc.dev_Newsletter_Issue_%23157-blue?logo=Jetpack+Compose&amp;logoColor=white"></a></div></span><p>One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.</p><p>With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous <code>findViewById</code>), resulting in less context switching between two different environments (XML and Kotlin code).</p><p>But “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization. Long files, large composable functions, and stateful UI components that hinder reusability are examples that can lead to a messy codebase.</p><p>In this article, I will show how I organized the codebase of <a href=https://github.com/prof18/MoneyFlow>MoneyFlow</a>, a money management app written with Kotlin Multiplatform, Jetpack Compose, and Swift UI.</p><blockquote><p>I wrote a similar article that covers the same topic for SwiftUI, the declarative UI framework for iOS: <a href=/posts/2023/organize-view-swiftui-edition>“Organize your Views: SwiftUI edition”</a></p></blockquote><h2 id=jetpack-navigation-and-god-classes>Jetpack Navigation and “god classes”</h2><p><a href=https://developer.android.com/jetpack/compose/navigation>Jetpack Compose Navigation</a> is the navigation solution for Compose provided by Google. With that, it is possible to create a “central” navigation graph, and then navigation between different screens can be triggered by using URIs.</p><p>The navigation graph can be created by defining a <code>NavHost</code> containing each route. A route is defined by a string (the URI of that route) and a composable function (the UI that the user will see).</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>NavHost(navController = navController, startDestination = <span style=color:#5af78e>&#34;profile&#34;</span>) {
</span></span><span style=display:flex><span>    composable(<span style=color:#5af78e>&#34;profile&#34;</span>) { Profile(<span style=color:#78787e>/*...*/</span>) }
</span></span><span style=display:flex><span>    composable(<span style=color:#5af78e>&#34;friendslist&#34;</span>) { FriendsList(<span style=color:#78787e>/*...*/</span>) }
</span></span><span style=display:flex><span>    <span style=color:#78787e>/*...*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>From <a href=https://developer.android.com/jetpack/compose/navigation#create-navhost>https://developer.android.com/jetpack/compose/navigation#create-navhost</a></p></blockquote><p>With this approach, the class that contains the <code>NavHost</code> will start to grow a lot.
For example, here’s a snippet of an old version of MoneyFlow (N.B. Don’t copy this code, it’s old and without proper and clean state hoisting):</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>NavHost(navController, startDestination = <span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>HomeScreen</span>.route) { 
</span></span><span style=display:flex><span>    composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>HomeScreen</span>.route) {
</span></span><span style=display:flex><span>        HomeScreen(navController, paddingValues)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>AddTransactionScreen</span>.route) {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Get back the category
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#ff6ac1>val</span> category = <span style=color:#ff6ac1>it</span>.savedStateHandle
</span></span><span style=display:flex><span>            .getLiveData&lt;CategoryUIData&gt;( <span style=color:#f3f99d>NavigationArguments</span>.<span style=color:#f3f99d>Category</span>.key)
</span></span><span style=display:flex><span>            .observeAsState()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        AddTransactionScreen(
</span></span><span style=display:flex><span>            categoryName = category.<span style=color:#ff6ac1>value</span><span style=color:#ff6ac1>?.</span>name,
</span></span><span style=display:flex><span>            categoryId = category.<span style=color:#ff6ac1>value</span><span style=color:#ff6ac1>?.</span>id,
</span></span><span style=display:flex><span>            categoryIcon = category.<span style=color:#ff6ac1>value</span><span style=color:#ff6ac1>?.</span>icon,
</span></span><span style=display:flex><span>            navigateUp = { navController.popBackStack() },
</span></span><span style=display:flex><span>            navigateToCategoryList = {
</span></span><span style=display:flex><span>                navController.navigate(<span style=color:#5af78e>&#34;</span><span style=color:#5af78e>${Screen.CategoriesScreen.route}</span><span style=color:#5af78e>/true&#34;</span>)
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    composable(
</span></span><span style=display:flex><span>        route = <span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>CategoriesScreen</span>.route + <span style=color:#5af78e>&#34;/{</span><span style=color:#5af78e>${ NavigationArguments.FromAddTransaction.key}</span><span style=color:#5af78e>}&#34;</span>,
</span></span><span style=display:flex><span>        arguments = listOf(navArgument( <span style=color:#f3f99d>NavigationArguments</span>.<span style=color:#f3f99d>FromAddTransaction</span>.key) {
</span></span><span style=display:flex><span>            type = <span style=color:#f3f99d>NavType</span>.BoolType
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    ) { backStackEntry <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>        CategoriesScreen(
</span></span><span style=display:flex><span>            navigateUp = { navController.popBackStack() },
</span></span><span style=display:flex><span>            sendCategoryBack = { navArguments, categoryData <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>                navController.previousBackStackEntry<span style=color:#ff6ac1>?.</span>savedStateHandle<span style=color:#ff6ac1>?.</span><span style=color:#ff6ac1>set</span>(
</span></span><span style=display:flex><span>                    navArguments.key,
</span></span><span style=display:flex><span>                    categoryData
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            isFromAddTransaction = backStackEntry.arguments<span style=color:#ff6ac1>?.</span>getBoolean(
</span></span><span style=display:flex><span>                <span style=color:#f3f99d>NavigationArguments</span>.<span style=color:#f3f99d>FromAddTransaction</span>.key
</span></span><span style=display:flex><span>            ) <span style=color:#ff6ac1>?:</span> <span style=color:#ff6ac1>false</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>RecapScreen</span>.route) {
</span></span><span style=display:flex><span>	    RecapScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>BudgetScreen</span>.route) {
</span></span><span style=display:flex><span>		BudgetScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>SettingsScreen</span>.route) {
</span></span><span style=display:flex><span>        SettingsScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If the application keeps growing with more and more screens, this snippet of code will become harder and harder to read, understand and maintain.</p><h2 id=a-slim-navhost>A slim NavHost</h2><p>On the mission to tackle this issue, I found an interesting approach described in <a href=https://twitter.com/lachlantmckee>Lachlan McKee</a>’s article: <a href=https://medium.com/bumble-tech/scalable-jetpack-compose-navigation-9c0659f7c912>Scalable Jetpack Compose Navigation</a>, and I decided to follow a similar approach.</p><p>Creating the composable for a screen is delegated to a factory that can be defined outside the <code>NavHost</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>interface</span> <span style=color:#f3f99d>ComposeNavigationFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The factory can even be defined in a feature module, leaving all the implementation details hidden.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeScreenFactory</span>() : ComposeNavigationFactory {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController) {
</span></span><span style=display:flex><span>        navGraphBuilder.composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>HomeScreen</span>.route) {
</span></span><span style=display:flex><span>            HomeScreen()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, the <code>NavHost</code> will become cleaner.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>NavHost(navController, startDestination = <span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>HomeScreen</span>.route) {
</span></span><span style=display:flex><span>    HomeScreenFactory().create(<span style=color:#ff6ac1>this</span>, navController)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=screens-code-structure>Screens Code Structure</h2><p>To easily reach the entry point of a screen, I’ve decided to embrace the following structure.
Every screen has a single Kotlin file containing the screen’s factory, the screen’s composable function, and the screen’s preview.</p><p>For example, for the MoneyFlow Home Screen, there is a <code>HomeScreen.kt</code> file that contains <code>HomeScreenFactory</code>, <code>HomeScreen</code>, and <code>HomeScreenPreview</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// HomeScreen.kt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeScreenFactory</span>(<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> paddingValues: PaddingValues) : ComposeNavigationFactory {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController) {
</span></span><span style=display:flex><span>        navGraphBuilder.composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>HomeScreen</span>.route) {
</span></span><span style=display:flex><span>            HomeScreen(
</span></span><span style=display:flex><span>                paddingValues = paddingValues,
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>HomeScreen</span>(
</span></span><span style=display:flex><span>    paddingValues: PaddingValues = PaddingValues(<span style=color:#ff9f43>0.</span>dp),
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>. 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Preview</span>(name = <span style=color:#5af78e>&#34;HomeScreenError Light&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Preview</span>(name = <span style=color:#5af78e>&#34;HomeScreenError Night&#34;</span>, uiMode = <span style=color:#f3f99d>Configuration</span>.UI_MODE_NIGHT_YES)
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>HomeScreenPreview</span>() {
</span></span><span style=display:flex><span>    MoneyFlowTheme {
</span></span><span style=display:flex><span>        Surface {
</span></span><span style=display:flex><span>            HomeScreen()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The screen’s composable function should just be an entry point and should not contain the entire screen’s code to avoid growing the length of the function too much. Every piece of UI can be split into smaller (maybe even reusable) components.</p><p>To improve testability and increase reusability, the screen’s composable function (and in general, all the composable functions) should be stateless. To achieve stateless functions, the state needs to be hoisted.</p><p>State hoisting is a pattern of moving state to a composable&rsquo;s caller. Instead of passing a state variable to a function or even a reference to the ViewModel, only the current values to display and callbacks to react on events are passed.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>HomeScreen</span>(
</span></span><span style=display:flex><span>    paddingValues: PaddingValues = PaddingValues(<span style=color:#ff9f43>0.</span>dp),
</span></span><span style=display:flex><span>    homeModel: HomeModel,
</span></span><span style=display:flex><span>    deleteTransaction: (Long) <span style=color:#ff6ac1>-&gt;</span> Unit = {},
</span></span><span style=display:flex><span>    hideSensitiveDataState: Boolean,
</span></span><span style=display:flex><span>    changeSensitiveDataVisibility: (Boolean) <span style=color:#ff6ac1>-&gt;</span> Unit = {},
</span></span><span style=display:flex><span>    navigateToAddTransaction: () <span style=color:#ff6ac1>-&gt;</span> Unit = {},
</span></span><span style=display:flex><span>    navigateToAllTransactions: () <span style=color:#ff6ac1>-&gt;</span> Unit,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>..</span>. 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, a compossable function can be reused or tested in different scenarios without any external dependencies.</p><p>The connection with the ViewModel and with the navigation logic instead is made inside the screen factory,</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeScreenFactory</span>(<span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> paddingValues: PaddingValues) : ComposeNavigationFactory {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController) {
</span></span><span style=display:flex><span>        navGraphBuilder.composable(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>HomeScreen</span>.route) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> homeViewModel = getViewModel&lt;HomeViewModel&gt;()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> homeModelState: HomeModel <span style=color:#ff6ac1>by</span> homeViewModel.homeState.collectAsState()
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> hideSensitiveDataState: Boolean <span style=color:#ff6ac1>by</span> homeViewModel.hideSensitiveDataState.collectAsState()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HomeScreen(
</span></span><span style=display:flex><span>                paddingValues = paddingValues,
</span></span><span style=display:flex><span>                homeModel = homeModelState,
</span></span><span style=display:flex><span>                deleteTransaction = { transactionId <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>                    homeViewModel.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                hideSensitiveDataState = hideSensitiveDataState,
</span></span><span style=display:flex><span>                changeSensitiveDataVisibility = { visibility <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>                    homeViewModel.changeSensitiveDataVisibility(
</span></span><span style=display:flex><span>                        visibility
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                navigateToAllTransactions = { 
</span></span><span style=display:flex><span>                navController.navigate(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>AllTransactionsScreen</span>.route) 
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                navigateToAddTransaction = {
</span></span><span style=display:flex><span>                navController.navigate(<span style=color:#f3f99d>Screen</span>.<span style=color:#f3f99d>AddTransactionScreen</span>.route)
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To ensure that state hoisting is done correctly without any dependencies, a rule of thumb is to write composable’s previews. That’s because a Preview, for example, won’t easily work with a dependency on a ViewModel (it would work by writing a Fake ViewModel, but it will require more additional work).</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Preview</span>(name = <span style=color:#5af78e>&#34;HomeScreenError Light&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Preview</span>(name = <span style=color:#5af78e>&#34;HomeScreenError Night&#34;</span>, uiMode = <span style=color:#f3f99d>Configuration</span>.UI_MODE_NIGHT_YES)
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>HomeScreenErrorPreview</span>() {
</span></span><span style=display:flex><span>    MoneyFlowTheme {
</span></span><span style=display:flex><span>        Surface {
</span></span><span style=display:flex><span>            HomeScreen(
</span></span><span style=display:flex><span>                homeModel = <span style=color:#f3f99d>HomeModel</span>.Error(
</span></span><span style=display:flex><span>                    UIErrorMessage(
</span></span><span style=display:flex><span>                        <span style=color:#5af78e>&#34;An error occurred&#34;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#5af78e>&#34;Error code 101&#34;</span>,
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                hideSensitiveDataState = <span style=color:#ff6ac1>true</span>,
</span></span><span style=display:flex><span>                navigateToAllTransactions = {}
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For more information about state and state hoisting, you can look at the Android documentation:</p><ul><li><a href=https://developer.android.com/jetpack/compose/state>State and Jetpack Compose</a></li><li><a href=https://developer.android.com/jetpack/compose/state-hoisting>Where to hoist state</a></li></ul><p>And that’s all. With this approach, the readability and maintainability of the project really increased, especially when opening it after a few months of inactivity.</p><p>You can find all the code mentioned in the article on <a href=https://github.com/prof18/MoneyFlow>GitHub</a>.</p><p style=font-size:12px>// Thanks to <a href=https://twitter.com/stewemetal>István</a> for helping me review the post</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://bsky.app/profile/marcogomiero.com target=_blank>Bluesky</a>, <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.marcogomiero.com/>Marco Gomiero</a></span></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E")}</script></div></body></html>