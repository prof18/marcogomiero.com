<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Organize your Views: Jetpack Compose edition | Marco Gomiero</title><meta name=keywords content><meta name=description content="One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.
With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code)."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2023/organize-view-compose-edition/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><meta property="og:title" content="Organize your Views: Jetpack Compose edition"><meta property="og:description" content="One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.
With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2023/organize-view-compose-edition/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-15T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-15T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Organize your Views: Jetpack Compose edition"><meta name=twitter:description content="One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.
With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Organize your Views: Jetpack Compose edition","item":"https://www.marcogomiero.com/posts/2023/organize-view-compose-edition/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Organize your Views: Jetpack Compose edition","name":"Organize your Views: Jetpack Compose edition","description":"One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.\nWith Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code).","keywords":[],"articleBody":" One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.\nWith Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous findViewById), resulting in less context switching between two different environments (XML and Kotlin code).\nBut “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization. Long files, large composable functions, and stateful UI components that hinder reusability are examples that can lead to a messy codebase.\nIn this article, I will show how I organized the codebase of MoneyFlow, a money management app written with Kotlin Multiplatform, Jetpack Compose, and Swift UI.\nI wrote a similar article that covers the same topic for SwiftUI, the declarative UI framework for iOS: “Organize your Views: SwiftUI edition”\nJetpack Navigation and “god classes” Jetpack Compose Navigation is the navigation solution for Compose provided by Google. With that, it is possible to create a “central” navigation graph, and then navigation between different screens can be triggered by using URIs.\nThe navigation graph can be created by defining a NavHost containing each route. A route is defined by a string (the URI of that route) and a composable function (the UI that the user will see).\nNavHost(navController = navController, startDestination = \"profile\") { composable(\"profile\") { Profile(/*...*/) } composable(\"friendslist\") { FriendsList(/*...*/) } /*...*/ } From https://developer.android.com/jetpack/compose/navigation#create-navhost\nWith this approach, the class that contains the NavHost will start to grow a lot. For example, here’s a snippet of an old version of MoneyFlow (N.B. Don’t copy this code, it’s old and without proper and clean state hoisting):\nNavHost(navController, startDestination = Screen.HomeScreen.route) { composable(Screen.HomeScreen.route) { HomeScreen(navController, paddingValues) } composable(Screen.AddTransactionScreen.route) { // Get back the category val category = it.savedStateHandle .getLiveData( NavigationArguments.Category.key) .observeAsState() AddTransactionScreen( categoryName = category.value?.name, categoryId = category.value?.id, categoryIcon = category.value?.icon, navigateUp = { navController.popBackStack() }, navigateToCategoryList = { navController.navigate(\"${Screen.CategoriesScreen.route}/true\") }, ) } composable( route = Screen.CategoriesScreen.route + \"/{${ NavigationArguments.FromAddTransaction.key}}\", arguments = listOf(navArgument( NavigationArguments.FromAddTransaction.key) { type = NavType.BoolType }) ) { backStackEntry -\u003e CategoriesScreen( navigateUp = { navController.popBackStack() }, sendCategoryBack = { navArguments, categoryData -\u003e navController.previousBackStackEntry?.savedStateHandle?.set( navArguments.key, categoryData ) }, isFromAddTransaction = backStackEntry.arguments?.getBoolean( NavigationArguments.FromAddTransaction.key ) ?: false, ) } composable(Screen.RecapScreen.route) { RecapScreen() } composable(Screen.BudgetScreen.route) { BudgetScreen() } composable(Screen.SettingsScreen.route) { SettingsScreen() } } If the application keeps growing with more and more screens, this snippet of code will become harder and harder to read, understand and maintain.\nA slim NavHost On the mission to tackle this issue, I found an interesting approach described in Lachlan McKee’s article: Scalable Jetpack Compose Navigation, and I decided to follow a similar approach.\nCreating the composable for a screen is delegated to a factory that can be defined outside the NavHost.\ninternal interface ComposeNavigationFactory { fun create(navGraphBuilder: NavGraphBuilder, navController: NavController) } The factory can even be defined in a feature module, leaving all the implementation details hidden.\nclass HomeScreenFactory() : ComposeNavigationFactory { override fun create(navGraphBuilder: NavGraphBuilder, navController: NavController) { navGraphBuilder.composable(Screen.HomeScreen.route) { HomeScreen() } } } This way, the NavHost will become cleaner.\nNavHost(navController, startDestination = Screen.HomeScreen.route) { HomeScreenFactory().create(this, navController) } Screens Code Structure To easily reach the entry point of a screen, I’ve decided to embrace the following structure. Every screen has a single Kotlin file containing the screen’s factory, the screen’s composable function, and the screen’s preview.\nFor example, for the MoneyFlow Home Screen, there is a HomeScreen.kt file that contains HomeScreenFactory, HomeScreen, and HomeScreenPreview.\n// HomeScreen.kt internal class HomeScreenFactory(private val paddingValues: PaddingValues) : ComposeNavigationFactory { override fun create(navGraphBuilder: NavGraphBuilder, navController: NavController) { navGraphBuilder.composable(Screen.HomeScreen.route) { HomeScreen( paddingValues = paddingValues, ) } } } @Composable internal fun HomeScreen( paddingValues: PaddingValues = PaddingValues(0.dp), ) { ... } @Preview(name = \"HomeScreenError Light\") @Preview(name = \"HomeScreenError Night\", uiMode = Configuration.UI_MODE_NIGHT_YES) @Composable private fun HomeScreenPreview() { MoneyFlowTheme { Surface { HomeScreen() } } } The screen’s composable function should just be an entry point and should not contain the entire screen’s code to avoid growing the length of the function too much. Every piece of UI can be split into smaller (maybe even reusable) components.\nTo improve testability and increase reusability, the screen’s composable function (and in general, all the composable functions) should be stateless. To achieve stateless functions, the state needs to be hoisted.\nState hoisting is a pattern of moving state to a composable’s caller. Instead of passing a state variable to a function or even a reference to the ViewModel, only the current values to display and callbacks to react on events are passed.\n@Composable internal fun HomeScreen( paddingValues: PaddingValues = PaddingValues(0.dp), homeModel: HomeModel, deleteTransaction: (Long) -\u003e Unit = {}, hideSensitiveDataState: Boolean, changeSensitiveDataVisibility: (Boolean) -\u003e Unit = {}, navigateToAddTransaction: () -\u003e Unit = {}, navigateToAllTransactions: () -\u003e Unit, ) { ... } This way, a compossable function can be reused or tested in different scenarios without any external dependencies.\nThe connection with the ViewModel and with the navigation logic instead is made inside the screen factory,\ninternal class HomeScreenFactory(private val paddingValues: PaddingValues) : ComposeNavigationFactory { override fun create(navGraphBuilder: NavGraphBuilder, navController: NavController) { navGraphBuilder.composable(Screen.HomeScreen.route) { val homeViewModel = getViewModel() val homeModelState: HomeModel by homeViewModel.homeState.collectAsState() val hideSensitiveDataState: Boolean by homeViewModel.hideSensitiveDataState.collectAsState() HomeScreen( paddingValues = paddingValues, homeModel = homeModelState, deleteTransaction = { transactionId -\u003e homeViewModel.deleteTransaction(transactionId) }, hideSensitiveDataState = hideSensitiveDataState, changeSensitiveDataVisibility = { visibility -\u003e homeViewModel.changeSensitiveDataVisibility( visibility ) }, navigateToAllTransactions = { navController.navigate(Screen.AllTransactionsScreen.route) }, navigateToAddTransaction = { navController.navigate(Screen.AddTransactionScreen.route) }, ) } } } To ensure that state hoisting is done correctly without any dependencies, a rule of thumb is to write composable’s previews. That’s because a Preview, for example, won’t easily work with a dependency on a ViewModel (it would work by writing a Fake ViewModel, but it will require more additional work).\n@Preview(name = \"HomeScreenError Light\") @Preview(name = \"HomeScreenError Night\", uiMode = Configuration.UI_MODE_NIGHT_YES) @Composable private fun HomeScreenErrorPreview() { MoneyFlowTheme { Surface { HomeScreen( homeModel = HomeModel.Error( UIErrorMessage( \"An error occurred\", \"Error code 101\", ) ), hideSensitiveDataState = true, navigateToAllTransactions = {} ) } } } For more information about state and state hoisting, you can look at the Android documentation:\nState and Jetpack Compose Where to hoist state And that’s all. With this approach, the readability and maintainability of the project really increased, especially when opening it after a few months of inactivity.\nYou can find all the code mentioned in the article on GitHub.\n// Thanks to István for helping me review the post ","wordCount":"1080","inLanguage":"en","datePublished":"2023-03-15T00:00:00Z","dateModified":"2023-03-15T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2023/organize-view-compose-edition/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Organize your Views: Jetpack Compose edition</h1><div class=post-meta style=margin-top:16px><span title='2023-03-15 00:00:00 +0000 UTC'>15 March 2023</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><div id=banner style=overflow:hidden;justify-content:space-around;margin-bottom:10px><div style=display:inline-block;margin-right:10px><a href=https://androidweekly.net/issues/issue-562><img style=margin:0 src=https://androidweekly.net/issues/issue-562/badge></a></div><div style=display:inline-block;margin-right:10px><a href=https://jetc.dev/issues/157.html><img style=margin:0 src="https://img.shields.io/badge/As_Seen_In-jetc.dev_Newsletter_Issue_%23157-blue?logo=Jetpack+Compose&logoColor=white"></a></div></div><p>One of the pros of Jetpack Compose (in the rest of the article, I will just call it Compose, for brevity), and generally of declarative UI frameworks, is the capability of defining the UI with the same programming language the rest of the application uses.</p><p>With Compose, it is not necessary anymore to bridge the UI definitions from XML (e.g. with the [in]famous <code>findViewById</code>), resulting in less context switching between two different environments (XML and Kotlin code).</p><p>But “with great power comes great responsibility”, and a codebase can quickly become a nightmare without some structure and organization. Long files, large composable functions, and stateful UI components that hinder reusability are examples that can lead to a messy codebase.</p><p>In this article, I will show how I organized the codebase of <a href=https://github.com/prof18/MoneyFlow>MoneyFlow</a>, a money management app written with Kotlin Multiplatform, Jetpack Compose, and Swift UI.</p><blockquote><p>I wrote a similar article that covers the same topic for SwiftUI, the declarative UI framework for iOS: <a href=/posts/2023/organize-view-swiftui-edition>“Organize your Views: SwiftUI edition”</a></p></blockquote><h2 id=jetpack-navigation-and-god-classes>Jetpack Navigation and “god classes”<a hidden class=anchor aria-hidden=true href=#jetpack-navigation-and-god-classes>#</a></h2><p><a href=https://developer.android.com/jetpack/compose/navigation>Jetpack Compose Navigation</a> is the navigation solution for Compose provided by Google. With that, it is possible to create a “central” navigation graph, and then navigation between different screens can be triggered by using URIs.</p><p>The navigation graph can be created by defining a <code>NavHost</code> containing each route. A route is defined by a string (the URI of that route) and a composable function (the UI that the user will see).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>NavHost(navController = navController, startDestination = <span style=color:#e6db74>&#34;profile&#34;</span>) {
</span></span><span style=display:flex><span>    composable(<span style=color:#e6db74>&#34;profile&#34;</span>) { Profile(<span style=color:#75715e>/*...*/</span>) }
</span></span><span style=display:flex><span>    composable(<span style=color:#e6db74>&#34;friendslist&#34;</span>) { FriendsList(<span style=color:#75715e>/*...*/</span>) }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*...*/</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>From <a href=https://developer.android.com/jetpack/compose/navigation#create-navhost>https://developer.android.com/jetpack/compose/navigation#create-navhost</a></p></blockquote><p>With this approach, the class that contains the <code>NavHost</code> will start to grow a lot.
For example, here’s a snippet of an old version of MoneyFlow (N.B. Don’t copy this code, it’s old and without proper and clean state hoisting):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>NavHost(navController, startDestination = Screen.HomeScreen.route) { 
</span></span><span style=display:flex><span>    composable(Screen.HomeScreen.route) {
</span></span><span style=display:flex><span>        HomeScreen(navController, paddingValues)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    composable(Screen.AddTransactionScreen.route) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Get back the category
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>val</span> category = <span style=color:#66d9ef>it</span>.savedStateHandle
</span></span><span style=display:flex><span>            .getLiveData&lt;CategoryUIData&gt;( NavigationArguments.Category.key)
</span></span><span style=display:flex><span>            .observeAsState()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        AddTransactionScreen(
</span></span><span style=display:flex><span>            categoryName = category.<span style=color:#66d9ef>value</span><span style=color:#f92672>?.</span>name,
</span></span><span style=display:flex><span>            categoryId = category.<span style=color:#66d9ef>value</span><span style=color:#f92672>?.</span>id,
</span></span><span style=display:flex><span>            categoryIcon = category.<span style=color:#66d9ef>value</span><span style=color:#f92672>?.</span>icon,
</span></span><span style=display:flex><span>            navigateUp = { navController.popBackStack() },
</span></span><span style=display:flex><span>            navigateToCategoryList = {
</span></span><span style=display:flex><span>                navController.navigate(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${Screen.CategoriesScreen.route}</span><span style=color:#e6db74>/true&#34;</span>)
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    composable(
</span></span><span style=display:flex><span>        route = Screen.CategoriesScreen.route + <span style=color:#e6db74>&#34;/{</span><span style=color:#e6db74>${ NavigationArguments.FromAddTransaction.key}</span><span style=color:#e6db74>}&#34;</span>,
</span></span><span style=display:flex><span>        arguments = listOf(navArgument( NavigationArguments.FromAddTransaction.key) {
</span></span><span style=display:flex><span>            type = NavType.BoolType
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    ) { backStackEntry <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        CategoriesScreen(
</span></span><span style=display:flex><span>            navigateUp = { navController.popBackStack() },
</span></span><span style=display:flex><span>            sendCategoryBack = { navArguments, categoryData <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                navController.previousBackStackEntry<span style=color:#f92672>?.</span>savedStateHandle<span style=color:#f92672>?.</span><span style=color:#66d9ef>set</span>(
</span></span><span style=display:flex><span>                    navArguments.key,
</span></span><span style=display:flex><span>                    categoryData
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            isFromAddTransaction = backStackEntry.arguments<span style=color:#f92672>?.</span>getBoolean(
</span></span><span style=display:flex><span>                NavigationArguments.FromAddTransaction.key
</span></span><span style=display:flex><span>            ) <span style=color:#f92672>?:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	composable(Screen.RecapScreen.route) {
</span></span><span style=display:flex><span>	    RecapScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	composable(Screen.BudgetScreen.route) {
</span></span><span style=display:flex><span>		BudgetScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    composable(Screen.SettingsScreen.route) {
</span></span><span style=display:flex><span>        SettingsScreen()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If the application keeps growing with more and more screens, this snippet of code will become harder and harder to read, understand and maintain.</p><h2 id=a-slim-navhost>A slim NavHost<a hidden class=anchor aria-hidden=true href=#a-slim-navhost>#</a></h2><p>On the mission to tackle this issue, I found an interesting approach described in <a href=https://twitter.com/lachlantmckee>Lachlan McKee</a>’s article: <a href=https://medium.com/bumble-tech/scalable-jetpack-compose-navigation-9c0659f7c912>Scalable Jetpack Compose Navigation</a>, and I decided to follow a similar approach.</p><p>Creating the composable for a screen is delegated to a factory that can be defined outside the <code>NavHost</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ComposeNavigationFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The factory can even be defined in a feature module, leaving all the implementation details hidden.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeScreenFactory</span>() : ComposeNavigationFactory {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController) {
</span></span><span style=display:flex><span>        navGraphBuilder.composable(Screen.HomeScreen.route) {
</span></span><span style=display:flex><span>            HomeScreen()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, the <code>NavHost</code> will become cleaner.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>NavHost(navController, startDestination = Screen.HomeScreen.route) {
</span></span><span style=display:flex><span>    HomeScreenFactory().create(<span style=color:#66d9ef>this</span>, navController)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=screens-code-structure>Screens Code Structure<a hidden class=anchor aria-hidden=true href=#screens-code-structure>#</a></h2><p>To easily reach the entry point of a screen, I’ve decided to embrace the following structure.
Every screen has a single Kotlin file containing the screen’s factory, the screen’s composable function, and the screen’s preview.</p><p>For example, for the MoneyFlow Home Screen, there is a <code>HomeScreen.kt</code> file that contains <code>HomeScreenFactory</code>, <code>HomeScreen</code>, and <code>HomeScreenPreview</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// HomeScreen.kt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeScreenFactory</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> paddingValues: PaddingValues) : ComposeNavigationFactory {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController) {
</span></span><span style=display:flex><span>        navGraphBuilder.composable(Screen.HomeScreen.route) {
</span></span><span style=display:flex><span>            HomeScreen(
</span></span><span style=display:flex><span>                paddingValues = paddingValues,
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>HomeScreen</span>(
</span></span><span style=display:flex><span>    paddingValues: PaddingValues = PaddingValues(<span style=color:#ae81ff>0.</span>dp),
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>. 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Preview</span>(name = <span style=color:#e6db74>&#34;HomeScreenError Light&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Preview</span>(name = <span style=color:#e6db74>&#34;HomeScreenError Night&#34;</span>, uiMode = Configuration.UI_MODE_NIGHT_YES)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>HomeScreenPreview</span>() {
</span></span><span style=display:flex><span>    MoneyFlowTheme {
</span></span><span style=display:flex><span>        Surface {
</span></span><span style=display:flex><span>            HomeScreen()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The screen’s composable function should just be an entry point and should not contain the entire screen’s code to avoid growing the length of the function too much. Every piece of UI can be split into smaller (maybe even reusable) components.</p><p>To improve testability and increase reusability, the screen’s composable function (and in general, all the composable functions) should be stateless. To achieve stateless functions, the state needs to be hoisted.</p><p>State hoisting is a pattern of moving state to a composable&rsquo;s caller. Instead of passing a state variable to a function or even a reference to the ViewModel, only the current values to display and callbacks to react on events are passed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>HomeScreen</span>(
</span></span><span style=display:flex><span>    paddingValues: PaddingValues = PaddingValues(<span style=color:#ae81ff>0.</span>dp),
</span></span><span style=display:flex><span>    homeModel: HomeModel,
</span></span><span style=display:flex><span>    deleteTransaction: (Long) <span style=color:#f92672>-&gt;</span> Unit = {},
</span></span><span style=display:flex><span>    hideSensitiveDataState: Boolean,
</span></span><span style=display:flex><span>    changeSensitiveDataVisibility: (Boolean) <span style=color:#f92672>-&gt;</span> Unit = {},
</span></span><span style=display:flex><span>    navigateToAddTransaction: () <span style=color:#f92672>-&gt;</span> Unit = {},
</span></span><span style=display:flex><span>    navigateToAllTransactions: () <span style=color:#f92672>-&gt;</span> Unit,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>. 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, a compossable function can be reused or tested in different scenarios without any external dependencies.</p><p>The connection with the ViewModel and with the navigation logic instead is made inside the screen factory,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeScreenFactory</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> paddingValues: PaddingValues) : ComposeNavigationFactory {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>create</span>(navGraphBuilder: NavGraphBuilder, navController: NavController) {
</span></span><span style=display:flex><span>        navGraphBuilder.composable(Screen.HomeScreen.route) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> homeViewModel = getViewModel&lt;HomeViewModel&gt;()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> homeModelState: HomeModel <span style=color:#66d9ef>by</span> homeViewModel.homeState.collectAsState()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> hideSensitiveDataState: Boolean <span style=color:#66d9ef>by</span> homeViewModel.hideSensitiveDataState.collectAsState()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HomeScreen(
</span></span><span style=display:flex><span>                paddingValues = paddingValues,
</span></span><span style=display:flex><span>                homeModel = homeModelState,
</span></span><span style=display:flex><span>                deleteTransaction = { transactionId <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                    homeViewModel.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                hideSensitiveDataState = hideSensitiveDataState,
</span></span><span style=display:flex><span>                changeSensitiveDataVisibility = { visibility <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                    homeViewModel.changeSensitiveDataVisibility(
</span></span><span style=display:flex><span>                        visibility
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                navigateToAllTransactions = { 
</span></span><span style=display:flex><span>                navController.navigate(Screen.AllTransactionsScreen.route) 
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                navigateToAddTransaction = {
</span></span><span style=display:flex><span>                navController.navigate(Screen.AddTransactionScreen.route)
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To ensure that state hoisting is done correctly without any dependencies, a rule of thumb is to write composable’s previews. That’s because a Preview, for example, won’t easily work with a dependency on a ViewModel (it would work by writing a Fake ViewModel, but it will require more additional work).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Preview</span>(name = <span style=color:#e6db74>&#34;HomeScreenError Light&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Preview</span>(name = <span style=color:#e6db74>&#34;HomeScreenError Night&#34;</span>, uiMode = Configuration.UI_MODE_NIGHT_YES)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>HomeScreenErrorPreview</span>() {
</span></span><span style=display:flex><span>    MoneyFlowTheme {
</span></span><span style=display:flex><span>        Surface {
</span></span><span style=display:flex><span>            HomeScreen(
</span></span><span style=display:flex><span>                homeModel = HomeModel.Error(
</span></span><span style=display:flex><span>                    UIErrorMessage(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;An error occurred&#34;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Error code 101&#34;</span>,
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                hideSensitiveDataState = <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                navigateToAllTransactions = {}
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For more information about state and state hoisting, you can look at the Android documentation:</p><ul><li><a href=https://developer.android.com/jetpack/compose/state>State and Jetpack Compose</a></li><li><a href=https://developer.android.com/jetpack/compose/state-hoisting>Where to hoist state</a></li></ul><p>And that’s all. With this approach, the readability and maintainability of the project really increased, especially when opening it after a few months of inactivity.</p><p>You can find all the code mentioned in the article on <a href=https://github.com/prof18/MoneyFlow>GitHub</a>.</p><p style=font-size:12px>// Thanks to <a href=https://twitter.com/stewemetal>István</a> for helping me review the post</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>