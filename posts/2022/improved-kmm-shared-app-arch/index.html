<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.
This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.
Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:title" content="Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta property="og:description" content="A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.
This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.
Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2022/improved-kmm-shared-app-arch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-26T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-26T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta name=twitter:description content="A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.
This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.
Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><script src=https://www.marcogomiero.com/js/feather.min.js></script>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.2d1f13dc82ea2d94683809543a326af8a9a1f3a6c000f7b7af5d8f02a2e6ec25.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write</span></a>
<a href=/talks/><span>Speak</span></a>
<a href=/projects/><span>Build</span></a>
<a href=/about-me/><span>About</span></a>
| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app</h1><div class=post-meta><span title='2022-06-26 00:00:00 +0000 UTC'>26 June 2022</span></div></div><section class=body><span class=raw-html><div class=post-award-container><a href=https://androidweekly.net/issues/issue-525><img src=https://androidweekly.net/issues/issue-525/badge></a>
<a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=68710ad80a"><img src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23309-%237874b4></a>
<a href=https://jetc.dev/issues/123.html><img src="https://img.shields.io/badge/As_Seen_In-jetc.dev_Newsletter_Issue_%23123-blue?logo=Jetpack+Compose&logoColor=white"></a></div></span><p>A couple of years ago I started working on a pet project to manage personal finances, named <a href=https://github.com/prof18/MoneyFlow>MoneyFlow</a>.</p><figure><a href=/img/impr-kmm-arch/money-flow-dark.png><img src=/img/impr-kmm-arch/money-flow-dark.png></a></figure><p>This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.</p><blockquote><p><a href=https://www.marcogomiero.com/posts/2020/kmm-shared-app-architecture/>Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app</a></p></blockquote><p>To know more about the complete journey, please refer to the article mentioned above, but the outcome was a <strong>MVVM</strong> architecture with native ViewModels and a “shared middleware actor”, the UseCase, that prepares and serves the data for the UI.</p><p><strong>Shared UseCase</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeUseCaseImpl</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> moneyRepository: MoneyRepository,
</span></span><span style=display:flex><span>    <span style=color:#78787e>// That&#39;s only for iOS
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> viewUpdate: ((HomeModel) <span style=color:#ff6ac1>-&gt;</span> Unit)? = <span style=color:#ff6ac1>null</span>,
</span></span><span style=display:flex><span>): HomeUseCase {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Used only on iOS
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> coroutineScope: CoroutineScope = MainScope()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> homeModel = MutableStateFlow&lt;HomeModel&gt;(HomeModel.Loading)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>observeHomeModel</span>(): StateFlow&lt;HomeModel&gt; = homeModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>computeData</span>() {
</span></span><span style=display:flex><span>        coroutineScope.launch {
</span></span><span style=display:flex><span>            computeHomeDataSuspendable()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>computeHomeDataSuspendable</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> latestTransactionFlow = moneyRepository.getLatestTransactions()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> balanceRecapFlow = moneyRepository.getBalanceRecap()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        latestTransactionFlow.combine(balanceRecapFlow) { transactions: List&lt;Transaction&gt;, balanceRecap: BalanceRecap <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>            HomeModel.HomeState(
</span></span><span style=display:flex><span>                balanceRecap = balanceRecap,
</span></span><span style=display:flex><span>                latestTransactions = transactions
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }.<span style=color:#ff6ac1>catch</span> { cause: Throwable <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> error = HomeModel.Error(<span style=color:#5af78e>&#34;Something wrong&#34;</span>)
</span></span><span style=display:flex><span>            homeModel.<span style=color:#ff6ac1>value</span> = error
</span></span><span style=display:flex><span>            viewUpdate<span style=color:#ff6ac1>?.</span>invoke(error)
</span></span><span style=display:flex><span>        }.collect {
</span></span><span style=display:flex><span>            homeModel.<span style=color:#ff6ac1>value</span> = <span style=color:#ff6ac1>it</span>
</span></span><span style=display:flex><span>            viewUpdate<span style=color:#ff6ac1>?.</span>invoke(<span style=color:#ff6ac1>it</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>// iOS   only
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>onDestroy</span>() {
</span></span><span style=display:flex><span>        coroutineScope.cancel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Android ViewModel:</strong></p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeViewModel</span>(
</span></span><span style=display:flex><span>   <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> useCase: HomeUseCase
</span></span><span style=display:flex><span>) : ViewModel() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> _homeLiveData = MutableLiveData&lt;HomeModel&gt;()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> homeLiveData: LiveData&lt;HomeModel&gt;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>get</span>() = _homeLiveData
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>init</span> {
</span></span><span style=display:flex><span>        observeHomeModel()
</span></span><span style=display:flex><span>        viewModelScope.launch {
</span></span><span style=display:flex><span>            useCase.computeHomeDataSuspendable()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>observeHomeModel</span>() {
</span></span><span style=display:flex><span>        viewModelScope.launch {
</span></span><span style=display:flex><span>            useCase.observeHomeModel().collect {
</span></span><span style=display:flex><span>                _homeLiveData.postValue(<span style=color:#ff6ac1>it</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>iOS ViewModel</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>shared</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>class</span> <span style=color:#f3f99d>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @Published <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>homeModel</span>: HomeModel = HomeModel.Loading()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>lazy</span> <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>useCase</span> = HomeUseCaseImpl(moneyRepository: MoneyRepositoryFake(), viewUpdate: { [<span style=color:#ff6ac1>weak</span> <span style=color:#ff6ac1>self</span>] model <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>self</span>?.homeModel = model
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>startObserving</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>self</span>.useCase.computeData()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>stopObserving</span>() {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>self</span>.useCase.onDestroy()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I’m still convinced that this approach is a good compromise for sharing code as much as possible. In this way, all data handling and preparation will live in a shared UseCase. The ViewModels then can be native and use all the native tools provided by the platform, for example, the <em>Android Jetpack ViewModel</em> and <em>Combine/SwiftUI</em> utilities.</p><p>However, this solution can be improved.
First, there are duplicated methods to provide a suspendable and a no-suspendable version of a function. The fact that there are duplicated versions of the same function in the same class is something that can lead to confusion on the consumer side.</p><p>Secondly, the model returned by those functions is exposed in different ways: with a (State)Flow that will be used from Android and with a nullable callback injected in the constructor. This callback will be NOT <em>null</em> only on iOS and it will be invoked when the Flow coming from the repository is collected. Having a nullable field in the constructor based on the platform is another thing that I don’t like.</p><p>One of the reasons to have duplicated functions was the impossibility to use and collect a Flow on Swift. But with some glue code, this is not impossible.</p><h2 id=consuming-kotlin-flow-on-swift>Consuming Kotlin Flow on Swift</h2><p>With some wrapping code, it is possible to consume Kotlin Flow on Swift.</p><p>To consume Kotlin Flow on Swift, I took inspiration from <a href=https://mobile.twitter.com/RussHWolf>Russell Wolf</a>‘s article: <a href=https://dev.to/touchlab/kotlin-coroutines-and-swift-revisited-j5h>Kotlin Coroutines and Swift, revisited</a></p><p>This strategy requires some Kotlin and Swift wrapping code. The Kotlin code will live in the <code>iOSMain</code> sourceSets and the Swift code will live in the iOS app. In the end, the Flow will be transformed into a <a href=https://developer.apple.com/documentation/combine/publisher><code>Combine Publisher</code></a> that can be observed from iOS ViewModels.</p><p><strong>Kotlin Wrapper Code</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>FlowWrapper</span>&lt;T : Any&gt;(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> scope: CoroutineScope,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> flow: Flow&lt;T&gt;
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>subscribe</span>(
</span></span><span style=display:flex><span>        onEvent: (T) <span style=color:#ff6ac1>-&gt;</span> Unit,
</span></span><span style=display:flex><span>        onError: (Throwable) <span style=color:#ff6ac1>-&gt;</span> Unit,
</span></span><span style=display:flex><span>        onComplete: () <span style=color:#ff6ac1>-&gt;</span> Unit
</span></span><span style=display:flex><span>    ): Job =
</span></span><span style=display:flex><span>        flow
</span></span><span style=display:flex><span>            .onEach { onEvent(<span style=color:#ff6ac1>it</span>.freeze()) }
</span></span><span style=display:flex><span>            .<span style=color:#ff6ac1>catch</span> { onError(<span style=color:#ff6ac1>it</span>.freeze()) }
</span></span><span style=display:flex><span>            .onCompletion { onComplete() }
</span></span><span style=display:flex><span>            .launchIn(scope)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>iOS Wrapper Code</strong>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>Combine</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>import</span> <span style=color:#f3f99d>shared</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>func</span> <span style=color:#57c7ff>createPublisher</span>&lt;T&gt;(<span style=color:#ff6ac1>_</span> flowAdapter: FlowWrapper&lt;T&gt;) -&gt; AnyPublisher&lt;T, KotlinError&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>subject</span> = PassthroughSubject&lt;T, KotlinError&gt;()
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>job</span> = flowAdapter.subscribe { (item) <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>        subject.send(item)
</span></span><span style=display:flex><span>    } onError: { (error) <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>       subject.send(completion: .failure(KotlinError(error)))
</span></span><span style=display:flex><span>    } onComplete: {
</span></span><span style=display:flex><span>        subject.send(completion: .finished)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> subject.handleEvents(receiveCancel: {
</span></span><span style=display:flex><span>        job.cancel(cause: <span style=color:#ff6ac1>nil</span>)
</span></span><span style=display:flex><span>    }).eraseToAnyPublisher()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>class</span> <span style=color:#f3f99d>PublishedFlow</span>&lt;T&gt; : ObservableObject {
</span></span><span style=display:flex><span>    @Published
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>output</span>: T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>init</span>&lt;E&gt;(<span style=color:#ff6ac1>_</span> publisher: AnyPublisher&lt;T, E&gt;, defaultValue: T) {
</span></span><span style=display:flex><span>        output = defaultValue
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        publisher
</span></span><span style=display:flex><span>            .replaceError(with: defaultValue)
</span></span><span style=display:flex><span>            .compactMap { <span style=color:#ff5c57>$0</span> }
</span></span><span style=display:flex><span>            .receive(on: DispatchQueue.main)
</span></span><span style=display:flex><span>            .assign(to: <span style=color:#ff6ac1>&amp;</span><span style=color:#ff5c57>$</span>output)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>class</span> <span style=color:#f3f99d>KotlinError</span>: LocalizedError {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>throwable</span>: KotlinThrowable
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>init</span>(<span style=color:#ff6ac1>_</span> throwable: KotlinThrowable) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>self</span>.throwable = throwable
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>errorDescription</span>: <span style=color:#ff5c57>String</span>? {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>get</span> { throwable.message }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=improved-usecase>Improved UseCase</h2><p>The improved UseCase will have only a single method that returns a Flow. In the example below, I’ve also added a suspendable method, <code>deleteTransaction</code> to showcase how to handle methods that perform an action and return a result.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeUseCase</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> moneyRepository: MoneyRepository,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> settingsRepository: SettingsRepository,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> errorMapper: MoneyFlowErrorMapper,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>observeHomeModel</span>(): Flow&lt;HomeModel&gt; =
</span></span><span style=display:flex><span>        moneyRepository.getMoneySummary().map {
</span></span><span style=display:flex><span>            HomeModel.HomeState(
</span></span><span style=display:flex><span>                balanceRecap = <span style=color:#ff6ac1>it</span>.balanceRecap,
</span></span><span style=display:flex><span>                latestTransactions = <span style=color:#ff6ac1>it</span>.latestTransactions
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>deleteTransaction</span>(transactionId: Long): MoneyFlowResult&lt;Unit&gt; {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> <span style=color:#ff6ac1>try</span> {
</span></span><span style=display:flex><span>            moneyRepository.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>            MoneyFlowResult.Success(Unit)
</span></span><span style=display:flex><span>        } <span style=color:#ff6ac1>catch</span> (throwable: Throwable) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> error = MoneyFlowError.DeleteTransaction(throwable)
</span></span><span style=display:flex><span>            throwable.logError(error)
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> errorMessage = errorMapper.getUIErrorMessage(error)
</span></span><span style=display:flex><span>            MoneyFlowResult.Error(errorMessage)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To transform a <code>Flow</code> and handle coroutine cancellation, I’ve decided to create another UseCase but only specific to iOS. This class is placed in the <code>iOSMain</code> sourceSet. This class receives in the constructor a reference of the shared UseCase and re-exposes the methods to be able to transform a <code>Flow</code> and handle coroutine scoping.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeUseCaseIos</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> homeUseCase: HomeUseCase
</span></span><span style=display:flex><span>) : BaseUseCaseIos() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>getMoneySummary</span>(): FlowWrapper&lt;HomeModel&gt; =
</span></span><span style=display:flex><span>        FlowWrapper(scope, homeUseCase.observeHomeModel())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>deleteTransaction</span>(transactionId: Long, onError: (UIErrorMessage) <span style=color:#ff6ac1>-&gt;</span> Unit) {
</span></span><span style=display:flex><span>        scope.launch {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> result = homeUseCase.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>            result.doOnError { onError(<span style=color:#ff6ac1>it</span>) }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Coroutine scoping is handled in a <code>BaseUseCaseIos</code> class, that creates a scope and exposes a function to cancel the scope.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>BaseUseCaseIos</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> dispatcher: CoroutineDispatcher = Dispatchers.Default
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>val</span> scope = CoroutineScope(SupervisorJob() + dispatcher)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>onDestroy</span>() {
</span></span><span style=display:flex><span>        scope.cancel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Flow</code> can be “transformed” by creating a new <code>FlowWrapper</code> class with the <code>Flow</code> instance and the coroutine scope.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>getMoneySummary</span>(): FlowWrapper&lt;HomeModel&gt; =
</span></span><span style=display:flex><span>        FlowWrapper(scope, homeUseCase.observeHomeModel())
</span></span></code></pre></div><p>The “perform action and return a result” method instead, launches a coroutine in the scope and returns the result in a callback provided as a parameter.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>deleteTransaction</span>(transactionId: Long, onError: (UIErrorMessage) <span style=color:#ff6ac1>-&gt;</span> Unit) {
</span></span><span style=display:flex><span>        scope.launch {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> result = homeUseCase.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>            result.doOnError { onError(<span style=color:#ff6ac1>it</span>) }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>In this specific case, I’ve put only an <code>onError</code> callback because the UI will react only in case of an error.</p><h2 id=android-viewmodel>Android ViewModel</h2><p>The Android ViewModel will regularly use the UseCase with the <code>viewModelScope</code> coroutine scope provided by the Jetpack ViewModel like in a regular Android project.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>HomeViewModel</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>var</span> useCase: HomeUseCase,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> errorMapper: MoneyFlowErrorMapper,
</span></span><span style=display:flex><span>) : ViewModel() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>var</span> homeModel: HomeModel <span style=color:#ff6ac1>by</span> mutableStateOf(HomeModel.Loading)
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>set</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>init</span> {
</span></span><span style=display:flex><span>        observeHomeModel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>observeHomeModel</span>() {
</span></span><span style=display:flex><span>        viewModelScope.launch {
</span></span><span style=display:flex><span>            useCase.observeHomeModel()
</span></span><span style=display:flex><span>                .<span style=color:#ff6ac1>catch</span> { throwable: Throwable <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff6ac1>val</span> error = MoneyFlowError.GetCategories(throwable)
</span></span><span style=display:flex><span>                    throwable.logError(error)
</span></span><span style=display:flex><span>                    <span style=color:#ff6ac1>val</span> errorMessage = errorMapper.getUIErrorMessage(error)
</span></span><span style=display:flex><span>                    emit(HomeModel.Error(errorMessage))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                .collect {
</span></span><span style=display:flex><span>                    homeModel = <span style=color:#ff6ac1>it</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ios-viewmodel>iOS ViewModel</h2><p>On iOS instead, the ViewModel is an <a href=https://developer.apple.com/documentation/combine/observableobject><code>ObservableObject</code></a>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>class</span> <span style=color:#f3f99d>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To make SwiftUI react to state changes, it is necessary to create a <a href=https://developer.apple.com/documentation/combine/published><code>@Published</code></a> variable that will receive the data from the <code>FlowWrapper</code> exposed from the UseCase.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>class</span> <span style=color:#f3f99d>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	@Published <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>homeModel</span>: HomeModel = HomeModel.Loading()
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>}    
</span></span></code></pre></div><p>The <code>FlowWrapper</code> now, needs to be transformed to a <a href=https://developer.apple.com/documentation/combine/publisher><code>Publisher</code></a>, like explained <a href=#consuming-kotlin-flow-on-swift>in the section above</a>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>createPublisher(homeUseCase().getMoneySummary())
</span></span><span style=display:flex><span>    .eraseToAnyPublisher()
</span></span><span style=display:flex><span>    .receive(on: DispatchQueue.global(qos: .userInitiated))
</span></span></code></pre></div><p>When new data or an error is coming from the <code>Flow</code>, the <code>@Published</code> variable will be updated with the new content. The <code>sink</code> operator is like <code>collect</code> on <code>Flow</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.sink(
</span></span><span style=display:flex><span>    receiveCompletion: { completion in
</span></span><span style=display:flex><span>        if case let .failure(error) = completion {
</span></span><span style=display:flex><span>            let moneyFlowError = MoneyFlowError.GetMoneySummary(throwable:  error.throwable)
</span></span><span style=display:flex><span>            error.throwable.logError(
</span></span><span style=display:flex><span>                moneyFlowError: moneyFlowError,
</span></span><span style=display:flex><span>                message: &#34;Got error while transforming Flow to Publisher&#34;
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            let uiErrorMessage = DI.getErrorMapper().getUIErrorMessage(error: moneyFlowError)
</span></span><span style=display:flex><span>            self.homeModel = HomeModel.Error(uiErrorMessage: uiErrorMessage)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    receiveValue: { genericResponse in
</span></span><span style=display:flex><span>        onMainThread {
</span></span><span style=display:flex><span>            self.homeModel = genericResponse
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>When the <code>ViewModel</code> will be destroyed, then the coroutine scope will be canceled.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>deinit</span> {
</span></span><span style=display:flex><span>    homeUseCase().onDestroy()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As a reference, here’s the entire <code>iOS ViewModel</code>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff5c57>class</span> <span style=color:#f3f99d>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Published <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>homeModel</span>: HomeModel = HomeModel.Loading()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#ff5c57>var</span> <span style=color:#ff5c57>subscriptions</span> = Set&lt;AnyCancellable&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>homeUseCase</span>() -&gt; HomeUseCaseIos {
</span></span><span style=display:flex><span>        DI.getHomeUseCase()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>startObserving</span>() {
</span></span><span style=display:flex><span>        createPublisher(homeUseCase().getMoneySummary())
</span></span><span style=display:flex><span>            .eraseToAnyPublisher()
</span></span><span style=display:flex><span>            .receive(on: DispatchQueue.global(qos: .userInitiated))
</span></span><span style=display:flex><span>            .sink(
</span></span><span style=display:flex><span>                receiveCompletion: { completion <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff6ac1>if</span> <span style=color:#ff6ac1>case</span> <span style=color:#ff5c57>let</span> .failure(error) = completion {
</span></span><span style=display:flex><span>                        <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>moneyFlowError</span> = MoneyFlowError.GetMoneySummary(throwable:  error.throwable)
</span></span><span style=display:flex><span>                        error.throwable.logError(
</span></span><span style=display:flex><span>                            moneyFlowError: moneyFlowError,
</span></span><span style=display:flex><span>                            message: <span style=color:#5af78e>&#34;Got error while transforming Flow to Publisher&#34;</span>
</span></span><span style=display:flex><span>                        )
</span></span><span style=display:flex><span>                        <span style=color:#ff5c57>let</span> <span style=color:#ff5c57>uiErrorMessage</span> = DI.getErrorMapper().getUIErrorMessage(error: moneyFlowError)
</span></span><span style=display:flex><span>                        <span style=color:#ff6ac1>self</span>.homeModel = HomeModel.Error(uiErrorMessage: uiErrorMessage)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                receiveValue: { genericResponse <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>                    onMainThread {
</span></span><span style=display:flex><span>                        <span style=color:#ff6ac1>self</span>.homeModel = genericResponse
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            .store(<span style=color:#ff6ac1>in</span>: &amp;<span style=color:#ff6ac1>self</span>.subscriptions)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>func</span> <span style=color:#57c7ff>deleteTransaction</span>(transactionId: <span style=color:#ff5c57>Int64</span>) {
</span></span><span style=display:flex><span>        homeUseCase().deleteTransaction(
</span></span><span style=display:flex><span>            transactionId: transactionId,
</span></span><span style=display:flex><span>            onError: { error <span style=color:#ff6ac1>in</span>
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>self</span>.snackbarData = error.toSnackbarData()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>deinit</span> {
</span></span><span style=display:flex><span>        homeUseCase().onDestroy()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusions>Conclusions</h2><p>With the improvements covered above, the UseCase became more flexible and readable than before. Even though there is an amount of code duplication, I think that it’s a good compromise.
Some duplication is necessary to bridge the gap between different platforms and with this solution, the majority of the business logic is shared and a “slim” ViewModel will be used to fulfill different needs of different platforms.</p><p>Another approach can be using <a href=https://github.com/rickclephas/KMP-NativeCoroutines>KMP-NativeCoroutines</a>, a library that will make it easier to use Kotlin Coroutines from Swift code in KMP apps. I will try it out in the future or in another project.</p><p>You can find the code mentioned in the article on <a href=https://github.com/prof18/MoneyFlow>GitHub</a>.</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-69FZ1TLE7E","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>