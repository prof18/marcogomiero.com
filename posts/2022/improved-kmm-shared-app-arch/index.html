<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app | Marco Gomiero</title><meta name=keywords content><meta name=description content="A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.
This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.
Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2022/improved-kmm-shared-app-arch/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E",{anonymize_ip:!1})}</script><meta property="og:title" content="Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta property="og:description" content="A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.
This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.
Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2022/improved-kmm-shared-app-arch/"><meta property="og:image" content="https://www.marcogomiero.com/img/impr-kmm-arch/money-flow-dark.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-26T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-26T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.marcogomiero.com/img/impr-kmm-arch/money-flow-dark.png"><meta name=twitter:title content="Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><meta name=twitter:description content="A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.
This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.
Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app","item":"https://www.marcogomiero.com/posts/2022/improved-kmm-shared-app-arch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app","name":"Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app","description":"A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.\nThis project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.\nChoosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app","keywords":[],"articleBody":" A couple of years ago I started working on a pet project to manage personal finances, named MoneyFlow.\nThis project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.\nChoosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app\nTo know more about the complete journey, please refer to the article mentioned above, but the outcome was a MVVM architecture with native ViewModels and a “shared middleware actor”, the UseCase, that prepares and serves the data for the UI.\nShared UseCase:\nclass HomeUseCaseImpl( private val moneyRepository: MoneyRepository, // That's only for iOS private val viewUpdate: ((HomeModel) -\u003e Unit)? = null, ): HomeUseCase { // Used only on iOS private val coroutineScope: CoroutineScope = MainScope() private val homeModel = MutableStateFlow(HomeModel.Loading) override fun observeHomeModel(): StateFlow = homeModel override fun computeData() { coroutineScope.launch { computeHomeDataSuspendable() } } override suspend fun computeHomeDataSuspendable() { val latestTransactionFlow = moneyRepository.getLatestTransactions() val balanceRecapFlow = moneyRepository.getBalanceRecap() latestTransactionFlow.combine(balanceRecapFlow) { transactions: List, balanceRecap: BalanceRecap -\u003e HomeModel.HomeState( balanceRecap = balanceRecap, latestTransactions = transactions ) }.catch { cause: Throwable -\u003e val error = HomeModel.Error(\"Something wrong\") homeModel.value = error viewUpdate?.invoke(error) }.collect { homeModel.value = it viewUpdate?.invoke(it) } } // iOS only fun onDestroy() { coroutineScope.cancel() } } Android ViewModel:\nclass HomeViewModel( private val useCase: HomeUseCase ) : ViewModel() { private val _homeLiveData = MutableLiveData() val homeLiveData: LiveData get() = _homeLiveData init { observeHomeModel() viewModelScope.launch { useCase.computeHomeDataSuspendable() } } private fun observeHomeModel() { viewModelScope.launch { useCase.observeHomeModel().collect { _homeLiveData.postValue(it) } } } } iOS ViewModel:\nimport shared class HomeViewModel: ObservableObject { @Published var homeModel: HomeModel = HomeModel.Loading() lazy var useCase = HomeUseCaseImpl(moneyRepository: MoneyRepositoryFake(), viewUpdate: { [weak self] model in self?.homeModel = model }) func startObserving() { self.useCase.computeData() } func stopObserving() { self.useCase.onDestroy() } } I’m still convinced that this approach is a good compromise for sharing code as much as possible. In this way, all data handling and preparation will live in a shared UseCase. The ViewModels then can be native and use all the native tools provided by the platform, for example, the Android Jetpack ViewModel and Combine/SwiftUI utilities.\nHowever, this solution can be improved. First, there are duplicated methods to provide a suspendable and a no-suspendable version of a function. The fact that there are duplicated versions of the same function in the same class is something that can lead to confusion on the consumer side.\nSecondly, the model returned by those functions is exposed in different ways: with a (State)Flow that will be used from Android and with a nullable callback injected in the constructor. This callback will be NOT null only on iOS and it will be invoked when the Flow coming from the repository is collected. Having a nullable field in the constructor based on the platform is another thing that I don’t like.\nOne of the reasons to have duplicated functions was the impossibility to use and collect a Flow on Swift. But with some glue code, this is not impossible.\nConsuming Kotlin Flow on Swift With some wrapping code, it is possible to consume Kotlin Flow on Swift.\nTo consume Kotlin Flow on Swift, I took inspiration from Russell Wolf‘s article: Kotlin Coroutines and Swift, revisited\nThis strategy requires some Kotlin and Swift wrapping code. The Kotlin code will live in the iOSMain sourceSets and the Swift code will live in the iOS app. In the end, the Flow will be transformed into a Combine Publisher that can be observed from iOS ViewModels.\nKotlin Wrapper Code:\nclass FlowWrapper( private val scope: CoroutineScope, private val flow: Flow ) { fun subscribe( onEvent: (T) -\u003e Unit, onError: (Throwable) -\u003e Unit, onComplete: () -\u003e Unit ): Job = flow .onEach { onEvent(it.freeze()) } .catch { onError(it.freeze()) } .onCompletion { onComplete() } .launchIn(scope) } iOS Wrapper Code:\nimport Combine import shared func createPublisher(_ flowAdapter: FlowWrapper) -\u003e AnyPublisher { let subject = PassthroughSubject() let job = flowAdapter.subscribe { (item) in subject.send(item) } onError: { (error) in subject.send(completion: .failure(KotlinError(error))) } onComplete: { subject.send(completion: .finished) } return subject.handleEvents(receiveCancel: { job.cancel(cause: nil) }).eraseToAnyPublisher() } class PublishedFlow : ObservableObject { @Published var output: T init(_ publisher: AnyPublisher, defaultValue: T) { output = defaultValue publisher .replaceError(with: defaultValue) .compactMap { $0 } .receive(on: DispatchQueue.main) .assign(to: \u0026$output) } } class KotlinError: LocalizedError { let throwable: KotlinThrowable init(_ throwable: KotlinThrowable) { self.throwable = throwable } var errorDescription: String? { get { throwable.message } } } Improved UseCase The improved UseCase will have only a single method that returns a Flow. In the example below, I’ve also added a suspendable method, deleteTransaction to showcase how to handle methods that perform an action and return a result.\nclass HomeUseCase( private val moneyRepository: MoneyRepository, private val settingsRepository: SettingsRepository, private val errorMapper: MoneyFlowErrorMapper, ) { fun observeHomeModel(): Flow = moneyRepository.getMoneySummary().map { HomeModel.HomeState( balanceRecap = it.balanceRecap, latestTransactions = it.latestTransactions ) } suspend fun deleteTransaction(transactionId: Long): MoneyFlowResult { return try { moneyRepository.deleteTransaction(transactionId) MoneyFlowResult.Success(Unit) } catch (throwable: Throwable) { val error = MoneyFlowError.DeleteTransaction(throwable) throwable.logError(error) val errorMessage = errorMapper.getUIErrorMessage(error) MoneyFlowResult.Error(errorMessage) } } } To transform a Flow and handle coroutine cancellation, I’ve decided to create another UseCase but only specific to iOS. This class is placed in the iOSMain sourceSet. This class receives in the constructor a reference of the shared UseCase and re-exposes the methods to be able to transform a Flow and handle coroutine scoping.\nclass HomeUseCaseIos( private val homeUseCase: HomeUseCase ) : BaseUseCaseIos() { fun getMoneySummary(): FlowWrapper = FlowWrapper(scope, homeUseCase.observeHomeModel()) fun deleteTransaction(transactionId: Long, onError: (UIErrorMessage) -\u003e Unit) { scope.launch { val result = homeUseCase.deleteTransaction(transactionId) result.doOnError { onError(it) } } } } Coroutine scoping is handled in a BaseUseCaseIos class, that creates a scope and exposes a function to cancel the scope.\nabstract class BaseUseCaseIos { private val dispatcher: CoroutineDispatcher = Dispatchers.Default internal val scope = CoroutineScope(SupervisorJob() + dispatcher) fun onDestroy() { scope.cancel() } } The Flow can be “transformed” by creating a new FlowWrapper class with the Flow instance and the coroutine scope.\nfun getMoneySummary(): FlowWrapper = FlowWrapper(scope, homeUseCase.observeHomeModel()) The “perform action and return a result” method instead, launches a coroutine in the scope and returns the result in a callback provided as a parameter.\nfun deleteTransaction(transactionId: Long, onError: (UIErrorMessage) -\u003e Unit) { scope.launch { val result = homeUseCase.deleteTransaction(transactionId) result.doOnError { onError(it) } } } In this specific case, I’ve put only an onError callback because the UI will react only in case of an error.\nAndroid ViewModel The Android ViewModel will regularly use the UseCase with the viewModelScope coroutine scope provided by the Jetpack ViewModel like in a regular Android project.\ninternal class HomeViewModel( private var useCase: HomeUseCase, private val errorMapper: MoneyFlowErrorMapper, ) : ViewModel() { var homeModel: HomeModel by mutableStateOf(HomeModel.Loading) private set init { observeHomeModel() } private fun observeHomeModel() { viewModelScope.launch { useCase.observeHomeModel() .catch { throwable: Throwable -\u003e val error = MoneyFlowError.GetCategories(throwable) throwable.logError(error) val errorMessage = errorMapper.getUIErrorMessage(error) emit(HomeModel.Error(errorMessage)) } .collect { homeModel = it } } } } iOS ViewModel On iOS instead, the ViewModel is an ObservableObject.\nclass HomeViewModel: ObservableObject { ... } To make SwiftUI react to state changes, it is necessary to create a @Published variable that will receive the data from the FlowWrapper exposed from the UseCase.\nclass HomeViewModel: ObservableObject { @Published var homeModel: HomeModel = HomeModel.Loading() } The FlowWrapper now, needs to be transformed to a Publisher, like explained in the section above.\ncreatePublisher(homeUseCase().getMoneySummary()) .eraseToAnyPublisher() .receive(on: DispatchQueue.global(qos: .userInitiated)) When new data or an error is coming from the Flow, the @Published variable will be updated with the new content. The sink operator is like collect on Flow.\n.sink( receiveCompletion: { completion in if case let .failure(error) = completion { let moneyFlowError = MoneyFlowError.GetMoneySummary(throwable: error.throwable) error.throwable.logError( moneyFlowError: moneyFlowError, message: \"Got error while transforming Flow to Publisher\" ) let uiErrorMessage = DI.getErrorMapper().getUIErrorMessage(error: moneyFlowError) self.homeModel = HomeModel.Error(uiErrorMessage: uiErrorMessage) } }, receiveValue: { genericResponse in onMainThread { self.homeModel = genericResponse } } ) When the ViewModel will be destroyed, then the coroutine scope will be canceled.\ndeinit { homeUseCase().onDestroy() } As a reference, here’s the entire iOS ViewModel:\nclass HomeViewModel: ObservableObject { @Published var homeModel: HomeModel = HomeModel.Loading() private var subscriptions = Set() private func homeUseCase() -\u003e HomeUseCaseIos { DI.getHomeUseCase() } func startObserving() { createPublisher(homeUseCase().getMoneySummary()) .eraseToAnyPublisher() .receive(on: DispatchQueue.global(qos: .userInitiated)) .sink( receiveCompletion: { completion in if case let .failure(error) = completion { let moneyFlowError = MoneyFlowError.GetMoneySummary(throwable: error.throwable) error.throwable.logError( moneyFlowError: moneyFlowError, message: \"Got error while transforming Flow to Publisher\" ) let uiErrorMessage = DI.getErrorMapper().getUIErrorMessage(error: moneyFlowError) self.homeModel = HomeModel.Error(uiErrorMessage: uiErrorMessage) } }, receiveValue: { genericResponse in onMainThread { self.homeModel = genericResponse } } ) .store(in: \u0026self.subscriptions) } func deleteTransaction(transactionId: Int64) { homeUseCase().deleteTransaction( transactionId: transactionId, onError: { error in self.snackbarData = error.toSnackbarData() } ) } deinit { homeUseCase().onDestroy() } } Conclusions With the improvements covered above, the UseCase became more flexible and readable than before. Even though there is an amount of code duplication, I think that it’s a good compromise. Some duplication is necessary to bridge the gap between different platforms and with this solution, the majority of the business logic is shared and a “slim” ViewModel will be used to fulfill different needs of different platforms.\nAnother approach can be using KMP-NativeCoroutines, a library that will make it easier to use Kotlin Coroutines from Swift code in KMP apps. I will try it out in the future or in another project.\nYou can find the code mentioned in the article on GitHub.\n","wordCount":"1561","inLanguage":"en","image":"https://www.marcogomiero.com/img/impr-kmm-arch/money-flow-dark.png","datePublished":"2022-06-26T00:00:00Z","dateModified":"2022-06-26T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2022/improved-kmm-shared-app-arch/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Improving shared architecture for a Kotlin Multiplatform, Jetpack Compose and SwiftUI app</h1><div class=post-meta style=margin-top:16px><span title='2022-06-26 00:00:00 +0000 UTC'>26 June 2022</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><div id=banner style=overflow:hidden;justify-content:space-around><div style=display:inline-block;margin-right:10px><a href=https://androidweekly.net/issues/issue-525><img style=margin:0 src=https://androidweekly.net/issues/issue-525/badge></a></div><div style=display:inline-block;margin-right:10px><a href="https://us12.campaign-archive.com/?u=f39692e245b94f7fb693b6d82&id=68710ad80a"><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20kotlinweekly.net-Issue%20%23309-%237874b4></a></div><div style=display:inline-block><a href=https://jetc.dev/issues/123.html><img style=margin:0 src=https://img.shields.io/badge/Featured%20in%20jetc.dev-Issue%20%23123-343a40></a></div></div><p>A couple of years ago I started working on a pet project to manage personal finances, named <a href=https://github.com/prof18/MoneyFlow>MoneyFlow</a>.</p><figure><a href=/img/impr-kmm-arch/money-flow-dark.png><img loading=lazy src=/img/impr-kmm-arch/money-flow-dark.png></a></figure><p>This project soon became a personal playground for a Kotlin Multiplatform mobile app and in a previous article, I journaled all the steps that lead me to a satisfying (at least for that time) shared app architecture.</p><blockquote><p><a href=https://www.marcogomiero.com/posts/2020/kmm-shared-app-architecture/>Choosing the right architecture for a [new] Kotlin Multiplatform, Jetpack Compose and SwiftUI app</a></p></blockquote><p>To know more about the complete journey, please refer to the article mentioned above, but the outcome was a <strong>MVVM</strong> architecture with native ViewModels and a “shared middleware actor”, the UseCase, that prepares and serves the data for the UI.</p><p><strong>Shared UseCase</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeUseCaseImpl</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> moneyRepository: MoneyRepository,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// That&#39;s only for iOS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> viewUpdate: ((HomeModel) <span style=color:#f92672>-&gt;</span> Unit)? = <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>): HomeUseCase {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Used only on iOS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> coroutineScope: CoroutineScope = MainScope()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> homeModel = MutableStateFlow&lt;HomeModel&gt;(HomeModel.Loading)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>observeHomeModel</span>(): StateFlow&lt;HomeModel&gt; = homeModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>computeData</span>() {
</span></span><span style=display:flex><span>        coroutineScope.launch {
</span></span><span style=display:flex><span>            computeHomeDataSuspendable()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>computeHomeDataSuspendable</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> latestTransactionFlow = moneyRepository.getLatestTransactions()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> balanceRecapFlow = moneyRepository.getBalanceRecap()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        latestTransactionFlow.combine(balanceRecapFlow) { transactions: List&lt;Transaction&gt;, balanceRecap: BalanceRecap <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            HomeModel.HomeState(
</span></span><span style=display:flex><span>                balanceRecap = balanceRecap,
</span></span><span style=display:flex><span>                latestTransactions = transactions
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }.<span style=color:#66d9ef>catch</span> { cause: Throwable <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> error = HomeModel.Error(<span style=color:#e6db74>&#34;Something wrong&#34;</span>)
</span></span><span style=display:flex><span>            homeModel.<span style=color:#66d9ef>value</span> = error
</span></span><span style=display:flex><span>            viewUpdate<span style=color:#f92672>?.</span>invoke(error)
</span></span><span style=display:flex><span>        }.collect {
</span></span><span style=display:flex><span>            homeModel.<span style=color:#66d9ef>value</span> = <span style=color:#66d9ef>it</span>
</span></span><span style=display:flex><span>            viewUpdate<span style=color:#f92672>?.</span>invoke(<span style=color:#66d9ef>it</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iOS   only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onDestroy</span>() {
</span></span><span style=display:flex><span>        coroutineScope.cancel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Android ViewModel:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeViewModel</span>(
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> useCase: HomeUseCase
</span></span><span style=display:flex><span>) : ViewModel() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> _homeLiveData = MutableLiveData&lt;HomeModel&gt;()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> homeLiveData: LiveData&lt;HomeModel&gt;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>() = _homeLiveData
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        observeHomeModel()
</span></span><span style=display:flex><span>        viewModelScope.launch {
</span></span><span style=display:flex><span>            useCase.computeHomeDataSuspendable()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>observeHomeModel</span>() {
</span></span><span style=display:flex><span>        viewModelScope.launch {
</span></span><span style=display:flex><span>            useCase.observeHomeModel().collect {
</span></span><span style=display:flex><span>                _homeLiveData.postValue(<span style=color:#66d9ef>it</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>iOS ViewModel</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>shared</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @Published <span style=color:#66d9ef>var</span> homeModel: HomeModel = HomeModel.Loading()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> useCase = HomeUseCaseImpl(moneyRepository: MoneyRepositoryFake(), viewUpdate: { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] model <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>?.homeModel = model
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>startObserving</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.useCase.computeData()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stopObserving</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.useCase.onDestroy()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I’m still convinced that this approach is a good compromise for sharing code as much as possible. In this way, all data handling and preparation will live in a shared UseCase. The ViewModels then can be native and use all the native tools provided by the platform, for example, the <em>Android Jetpack ViewModel</em> and <em>Combine/SwiftUI</em> utilities.</p><p>However, this solution can be improved.
First, there are duplicated methods to provide a suspendable and a no-suspendable version of a function. The fact that there are duplicated versions of the same function in the same class is something that can lead to confusion on the consumer side.</p><p>Secondly, the model returned by those functions is exposed in different ways: with a (State)Flow that will be used from Android and with a nullable callback injected in the constructor. This callback will be NOT <em>null</em> only on iOS and it will be invoked when the Flow coming from the repository is collected. Having a nullable field in the constructor based on the platform is another thing that I don’t like.</p><p>One of the reasons to have duplicated functions was the impossibility to use and collect a Flow on Swift. But with some glue code, this is not impossible.</p><h2 id=consuming-kotlin-flow-on-swift>Consuming Kotlin Flow on Swift<a hidden class=anchor aria-hidden=true href=#consuming-kotlin-flow-on-swift>#</a></h2><p>With some wrapping code, it is possible to consume Kotlin Flow on Swift.</p><p>To consume Kotlin Flow on Swift, I took inspiration from <a href=https://mobile.twitter.com/RussHWolf>Russell Wolf</a>‘s article: <a href=https://dev.to/touchlab/kotlin-coroutines-and-swift-revisited-j5h>Kotlin Coroutines and Swift, revisited</a></p><p>This strategy requires some Kotlin and Swift wrapping code. The Kotlin code will live in the <code>iOSMain</code> sourceSets and the Swift code will live in the iOS app. In the end, the Flow will be transformed into a <a href=https://developer.apple.com/documentation/combine/publisher><code>Combine Publisher</code></a> that can be observed from iOS ViewModels.</p><p><strong>Kotlin Wrapper Code</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FlowWrapper</span>&lt;T : Any&gt;(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> scope: CoroutineScope,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> flow: Flow&lt;T&gt;
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>subscribe</span>(
</span></span><span style=display:flex><span>        onEvent: (T) <span style=color:#f92672>-&gt;</span> Unit,
</span></span><span style=display:flex><span>        onError: (Throwable) <span style=color:#f92672>-&gt;</span> Unit,
</span></span><span style=display:flex><span>        onComplete: () <span style=color:#f92672>-&gt;</span> Unit
</span></span><span style=display:flex><span>    ): Job =
</span></span><span style=display:flex><span>        flow
</span></span><span style=display:flex><span>            .onEach { onEvent(<span style=color:#66d9ef>it</span>.freeze()) }
</span></span><span style=display:flex><span>            .<span style=color:#66d9ef>catch</span> { onError(<span style=color:#66d9ef>it</span>.freeze()) }
</span></span><span style=display:flex><span>            .onCompletion { onComplete() }
</span></span><span style=display:flex><span>            .launchIn(scope)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>iOS Wrapper Code</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Combine</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>shared</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createPublisher</span>&lt;T&gt;(<span style=color:#66d9ef>_</span> flowAdapter: FlowWrapper&lt;T&gt;) -&gt; AnyPublisher&lt;T, KotlinError&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> subject = PassthroughSubject&lt;T, KotlinError&gt;()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> job = flowAdapter.subscribe { (item) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        subject.send(item)
</span></span><span style=display:flex><span>    } onError: { (error) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>       subject.send(completion: .failure(KotlinError(error)))
</span></span><span style=display:flex><span>    } onComplete: {
</span></span><span style=display:flex><span>        subject.send(completion: .finished)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> subject.handleEvents(receiveCancel: {
</span></span><span style=display:flex><span>        job.cancel(cause: <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    }).eraseToAnyPublisher()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PublishedFlow</span>&lt;T&gt; : ObservableObject {
</span></span><span style=display:flex><span>    @Published
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> output: T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>&lt;E&gt;(<span style=color:#66d9ef>_</span> publisher: AnyPublisher&lt;T, E&gt;, defaultValue: T) {
</span></span><span style=display:flex><span>        output = defaultValue
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        publisher
</span></span><span style=display:flex><span>            .replaceError(with: defaultValue)
</span></span><span style=display:flex><span>            .compactMap { $0 }
</span></span><span style=display:flex><span>            .receive(on: DispatchQueue.main)
</span></span><span style=display:flex><span>            .assign(to: <span style=color:#f92672>&amp;</span><span style=color:#960050;background-color:#1e0010>$</span>output)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KotlinError</span>: LocalizedError {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> throwable: KotlinThrowable
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(<span style=color:#66d9ef>_</span> throwable: KotlinThrowable) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.throwable = throwable
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> errorDescription: String? {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { throwable.message }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=improved-usecase>Improved UseCase<a hidden class=anchor aria-hidden=true href=#improved-usecase>#</a></h2><p>The improved UseCase will have only a single method that returns a Flow. In the example below, I’ve also added a suspendable method, <code>deleteTransaction</code> to showcase how to handle methods that perform an action and return a result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeUseCase</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> moneyRepository: MoneyRepository,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> settingsRepository: SettingsRepository,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> errorMapper: MoneyFlowErrorMapper,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>observeHomeModel</span>(): Flow&lt;HomeModel&gt; =
</span></span><span style=display:flex><span>        moneyRepository.getMoneySummary().map {
</span></span><span style=display:flex><span>            HomeModel.HomeState(
</span></span><span style=display:flex><span>                balanceRecap = <span style=color:#66d9ef>it</span>.balanceRecap,
</span></span><span style=display:flex><span>                latestTransactions = <span style=color:#66d9ef>it</span>.latestTransactions
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>deleteTransaction</span>(transactionId: Long): MoneyFlowResult&lt;Unit&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            moneyRepository.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>            MoneyFlowResult.Success(Unit)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (throwable: Throwable) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> error = MoneyFlowError.DeleteTransaction(throwable)
</span></span><span style=display:flex><span>            throwable.logError(error)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> errorMessage = errorMapper.getUIErrorMessage(error)
</span></span><span style=display:flex><span>            MoneyFlowResult.Error(errorMessage)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To transform a <code>Flow</code> and handle coroutine cancellation, I’ve decided to create another UseCase but only specific to iOS. This class is placed in the <code>iOSMain</code> sourceSet. This class receives in the constructor a reference of the shared UseCase and re-exposes the methods to be able to transform a <code>Flow</code> and handle coroutine scoping.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeUseCaseIos</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> homeUseCase: HomeUseCase
</span></span><span style=display:flex><span>) : BaseUseCaseIos() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getMoneySummary</span>(): FlowWrapper&lt;HomeModel&gt; =
</span></span><span style=display:flex><span>        FlowWrapper(scope, homeUseCase.observeHomeModel())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>deleteTransaction</span>(transactionId: Long, onError: (UIErrorMessage) <span style=color:#f92672>-&gt;</span> Unit) {
</span></span><span style=display:flex><span>        scope.launch {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> result = homeUseCase.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>            result.doOnError { onError(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Coroutine scoping is handled in a <code>BaseUseCaseIos</code> class, that creates a scope and exposes a function to cancel the scope.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseUseCaseIos</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> dispatcher: CoroutineDispatcher = Dispatchers.Default
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> scope = CoroutineScope(SupervisorJob() + dispatcher)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onDestroy</span>() {
</span></span><span style=display:flex><span>        scope.cancel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Flow</code> can be “transformed” by creating a new <code>FlowWrapper</code> class with the <code>Flow</code> instance and the coroutine scope.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getMoneySummary</span>(): FlowWrapper&lt;HomeModel&gt; =
</span></span><span style=display:flex><span>        FlowWrapper(scope, homeUseCase.observeHomeModel())
</span></span></code></pre></div><p>The “perform action and return a result” method instead, launches a coroutine in the scope and returns the result in a callback provided as a parameter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>deleteTransaction</span>(transactionId: Long, onError: (UIErrorMessage) <span style=color:#f92672>-&gt;</span> Unit) {
</span></span><span style=display:flex><span>        scope.launch {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> result = homeUseCase.deleteTransaction(transactionId)
</span></span><span style=display:flex><span>            result.doOnError { onError(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>In this specific case, I’ve put only an <code>onError</code> callback because the UI will react only in case of an error.</p><h2 id=android-viewmodel>Android ViewModel<a hidden class=anchor aria-hidden=true href=#android-viewmodel>#</a></h2><p>The Android ViewModel will regularly use the UseCase with the <code>viewModelScope</code> coroutine scope provided by the Jetpack ViewModel like in a regular Android project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeViewModel</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> useCase: HomeUseCase,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> errorMapper: MoneyFlowErrorMapper,
</span></span><span style=display:flex><span>) : ViewModel() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> homeModel: HomeModel <span style=color:#66d9ef>by</span> mutableStateOf(HomeModel.Loading)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span> {
</span></span><span style=display:flex><span>        observeHomeModel()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>observeHomeModel</span>() {
</span></span><span style=display:flex><span>        viewModelScope.launch {
</span></span><span style=display:flex><span>            useCase.observeHomeModel()
</span></span><span style=display:flex><span>                .<span style=color:#66d9ef>catch</span> { throwable: Throwable <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>val</span> error = MoneyFlowError.GetCategories(throwable)
</span></span><span style=display:flex><span>                    throwable.logError(error)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>val</span> errorMessage = errorMapper.getUIErrorMessage(error)
</span></span><span style=display:flex><span>                    emit(HomeModel.Error(errorMessage))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                .collect {
</span></span><span style=display:flex><span>                    homeModel = <span style=color:#66d9ef>it</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ios-viewmodel>iOS ViewModel<a hidden class=anchor aria-hidden=true href=#ios-viewmodel>#</a></h2><p>On iOS instead, the ViewModel is an <a href=https://developer.apple.com/documentation/combine/observableobject><code>ObservableObject</code></a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To make SwiftUI react to state changes, it is necessary to create a <a href=https://developer.apple.com/documentation/combine/published><code>@Published</code></a> variable that will receive the data from the <code>FlowWrapper</code> exposed from the UseCase.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	@Published <span style=color:#66d9ef>var</span> homeModel: HomeModel = HomeModel.Loading()
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>}    
</span></span></code></pre></div><p>The <code>FlowWrapper</code> now, needs to be transformed to a <a href=https://developer.apple.com/documentation/combine/publisher><code>Publisher</code></a>, like explained <a href=#consuming-kotlin-flow-on-swift>in the section above</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>createPublisher(homeUseCase().getMoneySummary())
</span></span><span style=display:flex><span>    .eraseToAnyPublisher()
</span></span><span style=display:flex><span>    .receive(on: DispatchQueue.global(qos: .userInitiated))
</span></span></code></pre></div><p>When new data or an error is coming from the <code>Flow</code>, the <code>@Published</code> variable will be updated with the new content. The <code>sink</code> operator is like <code>collect</code> on <code>Flow</code>.</p><pre tabindex=0><code>.sink(
    receiveCompletion: { completion in
        if case let .failure(error) = completion {
            let moneyFlowError = MoneyFlowError.GetMoneySummary(throwable:  error.throwable)
            error.throwable.logError(
                moneyFlowError: moneyFlowError,
                message: &#34;Got error while transforming Flow to Publisher&#34;
            )
            let uiErrorMessage = DI.getErrorMapper().getUIErrorMessage(error: moneyFlowError)
            self.homeModel = HomeModel.Error(uiErrorMessage: uiErrorMessage)
        }
    },
    receiveValue: { genericResponse in
        onMainThread {
            self.homeModel = genericResponse
        }
    }
)
</code></pre><p>When the <code>ViewModel</code> will be destroyed, then the coroutine scope will be canceled.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>deinit</span> {
</span></span><span style=display:flex><span>    homeUseCase().onDestroy()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As a reference, here’s the entire <code>iOS ViewModel</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HomeViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Published <span style=color:#66d9ef>var</span> homeModel: HomeModel = HomeModel.Loading()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> subscriptions = Set&lt;AnyCancellable&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>homeUseCase</span>() -&gt; HomeUseCaseIos {
</span></span><span style=display:flex><span>        DI.getHomeUseCase()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>startObserving</span>() {
</span></span><span style=display:flex><span>        createPublisher(homeUseCase().getMoneySummary())
</span></span><span style=display:flex><span>            .eraseToAnyPublisher()
</span></span><span style=display:flex><span>            .receive(on: DispatchQueue.global(qos: .userInitiated))
</span></span><span style=display:flex><span>            .sink(
</span></span><span style=display:flex><span>                receiveCompletion: { completion <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>let</span> .failure(error) = completion {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> moneyFlowError = MoneyFlowError.GetMoneySummary(throwable:  error.throwable)
</span></span><span style=display:flex><span>                        error.throwable.logError(
</span></span><span style=display:flex><span>                            moneyFlowError: moneyFlowError,
</span></span><span style=display:flex><span>                            message: <span style=color:#e6db74>&#34;Got error while transforming Flow to Publisher&#34;</span>
</span></span><span style=display:flex><span>                        )
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>let</span> uiErrorMessage = DI.getErrorMapper().getUIErrorMessage(error: moneyFlowError)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>self</span>.homeModel = HomeModel.Error(uiErrorMessage: uiErrorMessage)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                receiveValue: { genericResponse <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                    onMainThread {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>self</span>.homeModel = genericResponse
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            .store(<span style=color:#66d9ef>in</span>: &amp;<span style=color:#66d9ef>self</span>.subscriptions)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deleteTransaction</span>(transactionId: Int64) {
</span></span><span style=display:flex><span>        homeUseCase().deleteTransaction(
</span></span><span style=display:flex><span>            transactionId: transactionId,
</span></span><span style=display:flex><span>            onError: { error <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>self</span>.snackbarData = error.toSnackbarData()
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>deinit</span> {
</span></span><span style=display:flex><span>        homeUseCase().onDestroy()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>With the improvements covered above, the UseCase became more flexible and readable than before. Even though there is an amount of code duplication, I think that it’s a good compromise.
Some duplication is necessary to bridge the gap between different platforms and with this solution, the majority of the business logic is shared and a “slim” ViewModel will be used to fulfill different needs of different platforms.</p><p>Another approach can be using <a href=https://github.com/rickclephas/KMP-NativeCoroutines>KMP-NativeCoroutines</a>, a library that will make it easier to use Kotlin Coroutines from Swift code in KMP apps. I will try it out in the future or in another project.</p><p>You can find the code mentioned in the article on <a href=https://github.com/prof18/MoneyFlow>GitHub</a>.</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>