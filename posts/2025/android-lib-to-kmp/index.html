<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>From an Android to a Kotlin Multiplatform library - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="As Kotlin Multiplatform (KMP) continues to gain traction, more Android libraries are transitioning to support multiple platforms. However, this transition doesn’t always come for free; depending on the project, there could be different challenges.
Recently, I migrated an existing Android library (RSS-Parser, a library to parse RSS feeds). In this article, I will share my experience, cover all the challenges I faced during this journey, and describe the solutions I implemented to overcome them, from preserving git history to handling platform-specific dependencies and testing across different platforms."><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:url" content="https://www.marcogomiero.com/posts/2025/android-lib-to-kmp/"><meta property="og:site_name" content="Marco Gomiero"><meta property="og:title" content="From an Android to a Kotlin Multiplatform library"><meta property="og:description" content="As Kotlin Multiplatform (KMP) continues to gain traction, more Android libraries are transitioning to support multiple platforms. However, this transition doesn’t always come for free; depending on the project, there could be different challenges.
Recently, I migrated an existing Android library (RSS-Parser, a library to parse RSS feeds). In this article, I will share my experience, cover all the challenges I faced during this journey, and describe the solutions I implemented to overcome them, from preserving git history to handling platform-specific dependencies and testing across different platforms."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="From an Android to a Kotlin Multiplatform library"><meta name=twitter:description content="As Kotlin Multiplatform (KMP) continues to gain traction, more Android libraries are transitioning to support multiple platforms. However, this transition doesn’t always come for free; depending on the project, there could be different challenges.
Recently, I migrated an existing Android library (RSS-Parser, a library to parse RSS feeds). In this article, I will share my experience, cover all the challenges I faced during this journey, and describe the solutions I implemented to overcome them, from preserving git history to handling platform-specific dependencies and testing across different platforms."><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E")}</script><script src=https://www.marcogomiero.com//js/feather.min.js></script><link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.26c5bf79ef760a8f4feb8fc7be32ec86fc1f1da292b42c9fcc37879d4f774e3f.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com/><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write
</span></a><a href=/talks/><span>Speak
</span></a><a href=/projects/><span>Build
</span></a><a href=/about-me/><span>About
</span></a>| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com//js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>From an Android to a Kotlin Multiplatform library</h1><div class=post-meta>&lt;span title='2025-03-16 00:00:00 +0000 UTC'>16 March 2025&lt;/span></div></div><section class=body><p>As Kotlin Multiplatform (KMP) continues to gain traction, more Android libraries are transitioning to support multiple platforms. However, this transition doesn’t always come for free; depending on the project, there could be different challenges.</p><p>Recently, I migrated an existing Android library (<a href=https://github.com/prof18/RSS-Parser>RSS-Parser</a>, a library to parse RSS feeds). In this article, I will share my experience, cover all the challenges I faced during this journey, and describe the solutions I implemented to overcome them, from preserving git history to handling platform-specific dependencies and testing across different platforms.</p><h2 id=source-sets-and-git-history>Source Sets and git history</h2><p>The code structure is the first difference between an Android and a multiplatform project. KMP <a href=https://kotlinlang.org/docs/multiplatform-discover-project.html#source-sets>uses different source sets</a> to separate platform-specific code from shared code.</p><p>In a typical KMP project, you&rsquo;ll find, for example:</p><ul><li><code>commonMain</code>: Contains code shared across all platforms</li><li><code>androidMain</code>: Android-specific implementations</li><li><code>iosMain</code>: iOS-specific implementations</li><li><code>jvmMain</code>: JVM (desktop) specific implementations</li></ul><p>And so on for <a href=https://kotlinlang.org/docs/multiplatform-dsl-reference.html#targets>every supported platform</a>. Each platform has its corresponding test source set (e.g., <code>commonTest</code>, <code>androidTest</code>, etc.).</p><p>This structure allows the core logic to be written once in the common source set while providing platform-specific implementations where needed.</p><p>An Android library, instead, has everything inside a single source set, usually called <code>main</code>.</p><p>The first challenge is migrating to the multiplatform source sets without losing the git history and library contributors’ work. Simply creating a new project would mean losing all this valuable information. To avoid this, I tried different approaches and found the following one to be successful (successful for my use case; there might be different ways that I completely ignored).</p><ol><li>Create a new library project using the <a href=https://terrakok.github.io/kmp-web-wizard/>KMP Web Wizard</a> (so I don’t have to create the source sets manually)</li><li>Move the new source sets inside the existing library project</li><li>Duplicate and keep the old source set in the repo for reference</li><li>Move the existing code to the <code>androidMain</code> source set</li><li>Make the Android part work as before without sharing the code yet</li></ol><p>This approach allowed me to maintain the entire git history while transitioning to the new structure. The original Android code served as a reference point during the migration process, making it easier to ensure that functionality remained consistent without looking at the previous commits every time.</p><h2 id=handling-platform-specific-apis>Handling Platform-Specific APIs</h2><p>The original Android library relied heavily on platform-specific APIs that aren&rsquo;t available across all platforms, like OkHttp for retrieving the RSS feed (with the <code>CoroutineEngine.fetchXML</code> method) and <code>XmlPullParser</code> for parsing the feed (with the <code>CoroutineEngine.parseXML</code> method).</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>Parser</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>var</span> callFactory: <span style=color:#f3f99d>Call</span>.Factory,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> charset: Charset? = <span style=color:#ff6ac1>null</span>,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>getChannel</span>(url: String): Channel = withContext(coroutineContext) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> charsetString = charset.toString()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> xml = <span style=color:#f3f99d>CoroutineEngine</span>.fetchXML(url, callFactory)
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span><span style=color:#ff9f43>@withContext</span> <span style=color:#f3f99d>CoroutineEngine</span>.parseXML(xml, charset)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When dealing with platform-specific code, there are two primary approaches:</p><ol><li><strong>Interfaces</strong>: Define a common interface in shared code and implement it for each platform</li><li><strong>Expect/Actual</strong>: Declare expected classes/functions in common code and provide actual implementations for each platform. (<a href=https://kotlinlang.org/docs/multiplatform-expect-actual.html>Expect/Actual documentation</a>)</li></ol><h3 id=interfaces-vs-expectactual>Interfaces vs Expect/Actual</h3><p>While the Expect/Actual mechanism is powerful, using interfaces provides more flexibility. For example, with interfaces, it will be possible to provide a fake implementation, fully delegate the implementation to the platform code (for example, when using a Swift library) or having multiple implementations for a single platform.</p><p>In the case of RSS-Parser, I’ve created interfaces for fetching and parsing a feed.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>interface</span> <span style=color:#f3f99d>XmlFetcher</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>fetchXml</span>(url: String): ParserInput
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>interface</span> <span style=color:#f3f99d>XmlParser</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>parseXML</span>(input: ParserInput): RssChannel
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the interfaces are implemented for each platform:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// JVM implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>JvmXmlFetcher</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> callFactory: <span style=color:#f3f99d>Call</span>.Factory,
</span></span><span style=display:flex><span>): XmlFetcher {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>fetchXml</span>(url: String): ParserInput {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Use OkHttp for fetching
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// iOS implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>IosXmlFetcher</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> nsUrlSession: NSURLSession,
</span></span><span style=display:flex><span>): XmlFetcher {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>fetchXml</span>(url: String): ParserInput =
</span></span><span style=display:flex><span>        suspendCancellableCoroutine { continuation <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#78787e>// Use NSURLSession for fetching
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, for abstracting platform-specific types, like <code>InputStream</code> and <code>NSData</code>, the expect/actual mechanism is the way to go:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>expect</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>ParserInput</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// JVM/Android implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>ParserInput</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> inputStream: InputStream
</span></span><span style=display:flex><span>) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// iOS implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>ParserInput</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> data: NSData
</span></span><span style=display:flex><span>) 
</span></span></code></pre></div><h2 id=creating-platform-specific-constructors>Creating Platform-Specific Constructors</h2><p>I wanted to provide different types of constructors to make the library easy to use across platforms. In particular, the users of the library must be able to:</p><ul><li>Create an instance of the library by customizing the platform-specific dependencies (OkHttp, NSURLSession);</li><li>Create an instance with default values;</li><li>Create an instance in a KMP, Android, or JVM project.</li></ul><p>To achieve that, I’ve created a <code>Builder</code> (I know, it’s more of a <code>Factory</code> than a <code>Builder</code>, but I figured it out too late, and that would mean doing breaking changes) in the library&rsquo;s main class, which is located in the <code>common</code> source set.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>RssParser</span> <span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>constructor</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> xmlFetcher: XmlFetcher,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> xmlParser: XmlParser,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>interface</span> <span style=color:#f3f99d>Builder</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>build</span>(): RssParser
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For each platform, I created a specific builder:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Android builder
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>RssParserBuilder</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> callFactory: <span style=color:#f3f99d>Call</span>.Factory = OkHttpClient(),
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> charset: Charset? = <span style=color:#ff6ac1>null</span>,
</span></span><span style=display:flex><span>): <span style=color:#f3f99d>RssParser</span>.Builder {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>build</span>(): RssParser {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> RssParser(
</span></span><span style=display:flex><span>            xmlFetcher = JvmXmlFetcher(
</span></span><span style=display:flex><span>                callFactory = callFactory,
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            xmlParser = AndroidXmlParser(
</span></span><span style=display:flex><span>                charset = charset,
</span></span><span style=display:flex><span>                dispatcher = <span style=color:#f3f99d>Dispatchers</span>.IO,
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// JVM builder
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>RssParserBuilder</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> callFactory: <span style=color:#f3f99d>Call</span>.Factory = OkHttpClient(),
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> charset: Charset? = <span style=color:#ff6ac1>null</span>,
</span></span><span style=display:flex><span>): <span style=color:#f3f99d>RssParser</span>.Builder {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>build</span>(): RssParser {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> RssParser(
</span></span><span style=display:flex><span>            xmlFetcher = JvmXmlFetcher(
</span></span><span style=display:flex><span>                callFactory = callFactory,
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            xmlParser = JvmXmlParser(
</span></span><span style=display:flex><span>                charset = charset,
</span></span><span style=display:flex><span>                dispatcher = <span style=color:#f3f99d>Dispatchers</span>.IO,
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// iOS builder
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>RssParserBuilder</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> nsUrlSession: NSURLSession = <span style=color:#f3f99d>NSURLSession</span>.sharedSession,
</span></span><span style=display:flex><span>): <span style=color:#f3f99d>RssParser</span>.Builder {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>build</span>(): RssParser {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> RssParser(
</span></span><span style=display:flex><span>            xmlFetcher = IosXmlFetcher(
</span></span><span style=display:flex><span>                nsUrlSession = nsUrlSession,
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>            xmlParser = IosXmlParser(
</span></span><span style=display:flex><span>                dispatcher = <span style=color:#f3f99d>Dispatchers</span>.IO
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To create instances with default values, the <code>expect/actual</code> mechanism can be leveraged by defining a function in the common source set:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>expect</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>RssParser</span>(): RssParser
</span></span></code></pre></div><p>Then, for every platform, the actual implementation will just call the <code>Builder</code> with default values:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>RssParser</span>(): RssParser = RssParserBuilder().build()
</span></span></code></pre></div><p>Defining this function with a capital letter creates a syntax that feels like a constructor call to library users. This approach allows developers on each platform to use the library in an idiomatic way, with the option to customize platform-specific dependencies when needed.</p><figure><a href=/img/android-lib-to-kmp/constructor.png><img src=/img/android-lib-to-kmp/constructor.png></a></figure><h2 id=testing-on-multiple-platforms>Testing on multiple platforms</h2><p>While the library has different platform-specific implementations, my goal was to have a single set of tests that can be run on all the platforms that the library supports.</p><p>However, this goal presents some challenges when it comes to creating platform-specific test instances and accessing test resources (e.g. different XML files that I want to test against my library)</p><h3 id=platform-specific-test-instances>Platform-Specific Test Instances</h3><p>The <code>expect/actual</code> mechanism comes to the rescue when creating platform-specific instances for testing.</p><p>In the <code>commonTest</code> source set, an expect <code>Factory</code> can be defined</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>expect</span> <span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>XmlParserFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createXmlParser</span>(): XmlParser
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And it can be implemented in every platform testing source set:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// JVM implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>XmlParserFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createXmlParser</span>(): XmlParser = JvmXmlParser(dispatcher = UnconfinedTestDispatcher())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// Android implementation 
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>XmlParserFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createXmlParser</span>(): XmlParser = AndroidXmlParser(dispatcher = UnconfinedTestDispatcher())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// iOS implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>object</span> <span style=color:#f3f99d>XmlParserFactory</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createXmlParser</span>(): XmlParser = IosXmlParser(dispatcher = UnconfinedTestDispatcher())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This setup allows to write a single test that can be run on different platforms</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>XmlParserTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>channelTitle</span>_isCorrect() = runTest {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> parser = <span style=color:#f3f99d>XmlParserFactory</span>.createXmlParser()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> input = readFileFromResources(<span style=color:#5af78e>&#34;test-feed.xml&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> channel = parser.parseXML(input)
</span></span><span style=display:flex><span>        assertEquals(<span style=color:#5af78e>&#34;channel-title&#34;</span>, channel.title)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><figure><a href=/img/android-lib-to-kmp/test.png><img src=/img/android-lib-to-kmp/test.png></a></figure><h3 id=accessing-test-resources>Accessing Test Resources</h3><p>Accessing test resources across platforms is complicated because there is no <code>java.io.File</code> on Kotlin/Native and on iOS, the working directory is unrelated to the project directory.</p><p>To solve this, environmental variables can be leveraged to get the path where the test resources are placed.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// In build.gradle.kts
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>val</span> rootDir = <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>${rootProject.rootDir.path}</span><span style=color:#5af78e>/rssparser/src/commonTest/resources&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tasks.withType&lt;Test&gt;().configureEach {
</span></span><span style=display:flex><span>    environment(<span style=color:#5af78e>&#34;TEST_RESOURCES_ROOT&#34;</span>, rootDir)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tasks.withType&lt;KotlinNativeTest&gt;().configureEach {
</span></span><span style=display:flex><span>    environment(<span style=color:#5af78e>&#34;TEST_RESOURCES_ROOT&#34;</span>, rootDir)
</span></span><span style=display:flex><span>    <span style=color:#78787e>// This is necessary to have the variable propagated on iOS
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    environment(<span style=color:#5af78e>&#34;SIMCTL_CHILD_TEST_RESOURCES_ROOT&#34;</span>, rootDir)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Test resources can now be retrieved by creating a platform-specific helper</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>expect</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>readFileFromResources</span>(
</span></span><span style=display:flex><span>    resourceName: String
</span></span><span style=display:flex><span>): ParserInput
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// JVM implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>readFileFromResources</span>(
</span></span><span style=display:flex><span>    resourceName: String,
</span></span><span style=display:flex><span>): ParserInput {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> path = <span style=color:#f3f99d>System</span>.getenv(<span style=color:#5af78e>&#34;TEST_RESOURCES_ROOT&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> file = File(<span style=color:#5af78e>&#34;</span><span style=color:#5af78e>$path</span><span style=color:#5af78e>/</span><span style=color:#5af78e>$resourceName</span><span style=color:#5af78e>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> ParserInput(
</span></span><span style=display:flex><span>        inputStream = FileInputStream(<span style=color:#ff6ac1>file</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// iOS implementation
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>internal</span> <span style=color:#ff6ac1>actual</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>readFileFromResources</span>(
</span></span><span style=display:flex><span>    resourceName: String
</span></span><span style=display:flex><span>): ParserInput {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> s = getenv(<span style=color:#5af78e>&#34;TEST_RESOURCES_ROOT&#34;</span>)<span style=color:#ff6ac1>?.</span>toKString()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> path = <span style=color:#5af78e>&#34;</span><span style=color:#5af78e>$s</span><span style=color:#5af78e>/</span><span style=color:#5af78e>${resourceName}</span><span style=color:#5af78e>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> data = <span style=color:#f3f99d>NSData</span>.dataWithContentsOfFile(path)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> ParserInput(requireNotNull(<span style=color:#ff6ac1>data</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=publishing-the-library>Publishing the library</h2><p>Publishing a Kotlin Multiplatform library on Maven is relatively straightforward (assuming you already have a Maven publication) using the <a href=https://github.com/vanniktech/gradle-maven-publish-plugin>Gradle Maven Publish Plugin</a>. The same setup for Android worked for the KMP library without any changes.</p><h2 id=conclusions>Conclusions</h2><p>Migrating an Android library to Kotlin Multiplatform is rewarding, but it comes with some challenges. Here’s the takeaways after migrating RSS-Parser to Kotlin Multiplatform.</p><p><strong>Adapting to different platforms requires time and thought</strong>: each platform has its quirks and best practices, and understanding these differences leads to a better API design.</p><p><strong>Code organization can be challenging</strong>: maintaining the git history while restructuring the codebase requires careful planning.</p><p><strong>Prefer interfaces over expect/actual where possible</strong>: while expect/actual is a powerful feature, interfaces often provide more flexibility and maintainability.</p><p><strong>Testing across platforms requires extra consideration</strong>: ensuring tests run on all platforms involves handling platform-specific test dependencies and resource access. Environment variables and factory patterns can help address these challenges.</p><p><strong>Start small and expand gradually</strong>: begin by supporting a limited set of platforms and then expand as you become more comfortable with the multiplatform approach.</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://bsky.app/profile/marcogomiero.com target=_blank>Bluesky</a>, <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.marcogomiero.com/>Marco Gomiero</a></span></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E")}</script></div></body></html>