<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Accessing native macOS API in Compose Multiplatform. - Marco Gomiero</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Compose Multiplatform is an amazing framework for building desktop applications that run on the JVM (Java Virtual Machine) on multiple platforms (macOS, Windows, and Linux).
However, things get trickier if platform-specific APIs, like iCloud on macOS, are needed. These APIs are tied to their native platforms and aren’t designed to be easily shared across multiple targets. Integrating such APIs into a Compose Multiplatform (in this article, when I mention Compose Multiplatform, I’m referring to Compose Multiplatform Desktop apps that run on the JVM) project requires some additional setup and “creativity”."><meta property="og:image" content><meta name=google-site-verification content="7rDTNqn214SsZ9mmV8Ps5v2vqy8aXFWyoq08udChYCs"><meta property="og:title" content="Accessing native macOS API in Compose Multiplatform."><meta property="og:description" content="Compose Multiplatform is an amazing framework for building desktop applications that run on the JVM (Java Virtual Machine) on multiple platforms (macOS, Windows, and Linux).
However, things get trickier if platform-specific APIs, like iCloud on macOS, are needed. These APIs are tied to their native platforms and aren’t designed to be easily shared across multiple targets. Integrating such APIs into a Compose Multiplatform (in this article, when I mention Compose Multiplatform, I’m referring to Compose Multiplatform Desktop apps that run on the JVM) project requires some additional setup and “creativity”."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2025/compose-desktop-macos-api-jni/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-22T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-22T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary"><meta name=twitter:title content="Accessing native macOS API in Compose Multiplatform."><meta name=twitter:description content="Compose Multiplatform is an amazing framework for building desktop applications that run on the JVM (Java Virtual Machine) on multiple platforms (macOS, Windows, and Linux).
However, things get trickier if platform-specific APIs, like iCloud on macOS, are needed. These APIs are tied to their native platforms and aren’t designed to be easily shared across multiple targets. Integrating such APIs into a Compose Multiplatform (in this article, when I mention Compose Multiplatform, I’m referring to Compose Multiplatform Desktop apps that run on the JVM) project requires some additional setup and “creativity”."><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E")}</script><script src=https://www.marcogomiero.com/js/feather.min.js></script>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.marcogomiero.com/css/main.f2c7f60ec2d0155a784ade9b1b272143e1b8eb864a95bf75e606b49d8774389e.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://www.marcogomiero.com/css/dark.26c5bf79ef760a8f4feb8fc7be32ec86fc1f1da292b42c9fcc37879d4f774e3f.css disabled></head><body><div class=content><header><div class=main><a href=https://www.marcogomiero.com><h2>Marco Gomiero</h2></a></div><nav class=navbar><a href=/posts/><span>Write</span></a>
<a href=/talks/><span>Speak</span></a>
<a href=/projects/><span>Build</span></a>
<a href=/about-me/><span>About</span></a>
| <span class=dark-mode-toggle id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://www.marcogomiero.com/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Accessing native macOS API in Compose Multiplatform.</h1><div class=post-meta><span title='2025-09-22 00:00:00 +0000 UTC'>22 September 2025</span></div></div><section class=body><p>Compose Multiplatform is an amazing framework for building desktop applications that run on the JVM (Java Virtual Machine) on multiple platforms (macOS, Windows, and Linux).</p><p>However, things get trickier if platform-specific APIs, like iCloud on macOS, are needed. These APIs are tied to their native platforms and aren’t designed to be easily shared across multiple targets. Integrating such APIs into a Compose Multiplatform (in this article, when I mention Compose Multiplatform, I’m referring to Compose Multiplatform Desktop apps that run on the JVM) project requires some additional setup and “creativity”.</p><p>In this article, I’ll explain how to use native macOS API in a Compose Multiplatform desktop application. I will take a real-world example from my open-source RSS reader app <a href=https://feedflow.dev>FeedFlow</a>, where I implemented data synchronization with iCloud. For the purpose of this article, I will showcase a simplified implementation of iCloud, just to understand the process; a more detailed tutorial about iCloud <em>may</em> arrive in the future.</p><h2 id=the-plan>The plan</h2><blockquote><p>Writing Kotlin to generate binaries that can be called from Kotlin. <em>Weird and fascinating</em>.</p></blockquote><p>Accessing native macOS APIs from a JVM-based application requires creating a bridge between the Java environment and the native platform. This can be achieved by building a native dynamic library (<code>.dylib</code>) and accessing it from the Compose Multiplatform app through JNI (Java Native Interface; more information about JNI is available in the <a href=https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/intro.html>official documentation</a>).</p><p>At first, I tried writing the dynamic library in Objective-C, and technically, it worked.</p><figure><a href=/img/macos-api-jni/objc.png><img src=/img/macos-api-jni/objc.png></a></figure><p>However, as <a href=https://bsky.app/profile/kpgalligan.bsky.social/>Kevin Galligan</a> pointed out, writing Objective-C code these days isn’t the most pleasant developer experience.</p><blockquote class=bluesky-embed data-bluesky-uri=at://did:plc:bt43mld4df3u2xswjlr5ondx/app.bsky.feed.post/3lcgoc32zf22c data-bluesky-cid=bafyreicj4yusksrryspjdjlsrxywibko6xp3iquvglccvt5bqhc4kiza2u><p lang=en>I'll throw out the obvious, potentially terrible idea. If you have a lot of ObjC code, write that in Kotlin/Native and export a minimal API you need to call from JNI (which could just be C instead of ObjC?). Not to complicate your thinking (I like to avoid writing ObjC)</p>&mdash; <a href="https://bsky.app/profile/did:plc:bt43mld4df3u2xswjlr5ondx?ref_src=embed">Kevin Galligan (@kpgalligan.bsky.social)</a> <a href="https://bsky.app/profile/did:plc:bt43mld4df3u2xswjlr5ondx/post/3lcgoc32zf22c?ref_src=embed">2024-12-03T22:19:46.589Z</a></blockquote><script async src=https://embed.bsky.app/static/embed.js></script><p>Luckily, there’s a better solution: <a href=https://kotlinlang.org/docs/native-overview.html><strong>Kotlin/Native</strong></a>.</p><p>Kotlin/Native can target macOS directly and it provides Kotlin bindings for many native Apple frameworks, for example Foundation and UIKit. This makes it possible to interact with macOS APIs using Kotlin, without the need to write Objective-C. Then, these native functionalities can be exposed to the Compose Multiplatform app with a dynamic library.</p><p>The following sections will walk through the complete implementation process step-by-step.</p><h2 id=module-creation>Module creation</h2><p>The first step is creating a dedicated Gradle module for the library. While the main application targets the JVM, this module will directly target macOS using Kotlin/Native.</p><p>In the <code>build.gradle.kts</code> file, it’s necessary to define the library&rsquo;s name (in my case, a very thoughtful name: <code>ikloud</code>) and specify the macOS architecture to target. Since only Apple Silicon is required in my case, the target is set to <code>macosArm64</code>.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>kotlin {
</span></span><span style=display:flex><span>    macosArm64(<span style=color:#5af78e>&#34;ikloud&#34;</span>) {
</span></span><span style=display:flex><span>        binaries {
</span></span><span style=display:flex><span>            sharedLib {
</span></span><span style=display:flex><span>                baseName = <span style=color:#5af78e>&#34;ikloud&#34;</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kotlin/Native comes with the ability to consume <code>C</code> and <code>Objective-C</code> libraries using a tool called <code>cinterop</code>, that generates Kotlin bindings so the library&rsquo;s methods can be called in Kotlin. Built-in platform libraries like <code>Foundation</code> or <code>UIKit</code>, already have bindings available, while for others, such as JNI, a definition file must be provided to generate such bindings. More details can be found in the official <a href=https://kotlinlang.org/docs/multiplatform-configure-compilations.html#configure-interop-with-native-languages>documentation</a>.</p><p>The definition file, with extension <code>.def</code> is usually named the same way as the library which bindings need to be generated, in this case <code>jni.def</code>. The file should be placed under <code>src/nativeInterop/cinterop/</code> and it includes the header of the libray.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-def data-lang=def><span style=display:flex><span>headers <span style=color:#ff6ac1>=</span> jni.h
</span></span></code></pre></div><p>Gradle must then be configured to include the interop definition:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>kotlin {
</span></span><span style=display:flex><span>    macosArm64(<span style=color:#5af78e>&#34;ikloud&#34;</span>) {
</span></span><span style=display:flex><span>        binaries {
</span></span><span style=display:flex><span>            sharedLib {
</span></span><span style=display:flex><span>                baseName = <span style=color:#5af78e>&#34;ikloud&#34;</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        compilations.getByName(<span style=color:#5af78e>&#34;main&#34;</span>) {
</span></span><span style=display:flex><span>            cinterops {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>val</span> jni <span style=color:#ff6ac1>by</span> creating {
</span></span><span style=display:flex><span>                    packageName = <span style=color:#5af78e>&#34;com.prof18.jni&#34;</span>
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>                    <span style=color:#ff6ac1>val</span> javaHome = File(System.getProperty(<span style=color:#5af78e>&#34;java.home&#34;</span>))
</span></span><span style=display:flex><span>                    includeDirs(
</span></span><span style=display:flex><span>                        Callable { File(javaHome, <span style=color:#5af78e>&#34;include&#34;</span>) },
</span></span><span style=display:flex><span>                        Callable { File(javaHome, <span style=color:#5af78e>&#34;include/darwin&#34;</span>) },
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>packageName</code> property defines the package where the generated Kotlin bindings will reside, in this case <code>com.prof18.jni</code>.</p><p>To complete the setup, the JNI headers files must be located. The headers are included with the JDK, and usually they can be found under the <code>include</code> and <code>include/darwin</code> directories:</p><figure><a href=/img/macos-api-jni/jni.png><img src=/img/macos-api-jni/jni.png></a></figure><p>The <code>includeDirs</code> function sets those paths. The use of <code>Callable</code> ensures that the evaluation of the directory paths is deferred until needed, rather than during Gradle configuration phase. Although resolving <code>javaHome</code> early would likely be safe in this context, deferring the computation is a safer approach.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>val</span> javaHome = File(System.getProperty(<span style=color:#5af78e>&#34;java.home&#34;</span>))
</span></span><span style=display:flex><span>includeDirs(
</span></span><span style=display:flex><span>    Callable { File(javaHome, <span style=color:#5af78e>&#34;include&#34;</span>) },
</span></span><span style=display:flex><span>    Callable { File(javaHome, <span style=color:#5af78e>&#34;include/darwin&#34;</span>) },
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h2 id=library-creation>Library creation</h2><p>With the Kotlin/Native module and JNI interop configured, the next step is implementing the native functionality, in this case downloading a file from iCloud into the local file system.</p><p>To make a native function callable from the JVM via JNI, its name must follow the JNI naming convention: <code>Java_&lt;package>_&lt;class>_&lt;method></code><br>For example: <code>Java_com_prof18_feedflow_desktop_feedsync_ICloudNativeBridge_iCloudDownload</code></p><p>Fortunately, Kotlin/Native provides the <code>@CName</code> annotation, which allows the exported symbol name to be customized. This means the Kotlin function can have a readable name while still satisfying JNI requirements:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@CName</span>(<span style=color:#5af78e>&#34;Java_com_prof18_feedflow_desktop_feedsync_ICloudNativeBridge_iCloudDownload&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>iCloudDownload</span>(env: CPointer&lt;JNIEnvVar&gt;, clazz: jclass)
</span></span></code></pre></div><p>The function needs also match the expected JNI signature. In this case:</p><ul><li><code>env</code>: a pointer to the JNI environment (<code>JNIEnvVar</code>), used to interact with the JVM.</li><li><code>clazz</code>: a reference to the calling Java/Kotlin class (<code>jclass</code>), unused here, but required by the signature</li></ul><p>No additional parameters are passed from the JVM or returned in this example, though the signature can be extended to accept other types such as <code>jstring</code>, <code>jint</code>, or <code>jboolean</code>, depending on the use case.</p><p>Within the function, native macOS APIs can be accessed as needed. In this case, a database file stored in FeedFlow’s iCloud container is copied into the app’s private documents directory:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@CName</span>(<span style=color:#5af78e>&#34;Java_com_prof18_feedflow_desktop_feedsync_ICloudNativeBridge_iCloudDownload&#34;</span>)  
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>iCloudDownload</span>(env: CPointer&lt;JNIEnvVar&gt;, clazz: jclass) {    
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> iCloudURL = NSFileManager.defaultManager  
</span></span><span style=display:flex><span>        .URLForUbiquityContainerIdentifier(<span style=color:#5af78e>&#34;iCloud.com.prof18.feedflow&#34;</span>)  
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>?.</span>URLByAppendingPathComponent(<span style=color:#5af78e>&#34;Documents&#34;</span>)  
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>?.</span>URLByAppendingPathComponent(<span style=color:#5af78e>&#34;database.db&#34;</span>)  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> documentsDirectory: NSURL? = NSFileManager.defaultManager.URLsForDirectory(  
</span></span><span style=display:flex><span>        directory = NSDocumentDirectory,  
</span></span><span style=display:flex><span>        inDomains = NSUserDomainMask,  
</span></span><span style=display:flex><span>    ).firstOrNull() <span style=color:#ff6ac1>as</span>? NSURL?  
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> destinationURL = documentsDirectory<span style=color:#ff6ac1>?.</span>URLByAppendingPathComponent(<span style=color:#5af78e>&#34;database.db&#34;</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (destinationURL <span style=color:#ff6ac1>!=</span> <span style=color:#ff6ac1>null</span> <span style=color:#ff6ac1>&amp;&amp;</span> iCloudURL <span style=color:#ff6ac1>!=</span> <span style=color:#ff6ac1>null</span>) {  
</span></span><span style=display:flex><span>        NSFileManager.defaultManager.copyItemAtURL(  
</span></span><span style=display:flex><span>            srcURL = iCloudURL,  
</span></span><span style=display:flex><span>            toURL = destinationURL,  
</span></span><span style=display:flex><span>            <span style=color:#78787e>// Handle error if needed, omitted for simplicity  
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>            error = <span style=color:#ff6ac1>null</span>,  
</span></span><span style=display:flex><span>        )  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At this point, the native function is implemented, named appropriately for JNI, and ready to be invoked from the JVM. The next step involves compiling and integrating the shared library into the Compose Multiplatform application.</p><h2 id=library-compilation>Library compilation</h2><p>Once the native Kotlin/Native code is implemented, it must be compiled into a dynamic library (<code>.dylib</code>) and made accessible to the main Compose Multiplatform app. The Gradle task for building the library is <code>linkReleaseSharedIkloud</code>, where <code>Ikloud</code> is the name given to the library in the Gradle setup done previously.</p><figure><a href=/img/macos-api-jni/output.png><img src=/img/macos-api-jni/output.png></a></figure><p>Rather than manually moving the compiled library after each build, I automated the process with a Gradle task that copies the <code>.dylib</code> file into the appropriate directory as soon as it&rsquo;s built. This ensures it is bundled correctly with the final application package.</p><h3 id=library-bundling>Library bundling</h3><p>Compose Multiplatform supports including platform-specific resources in native distributions. As described in the <a href=https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-native-distribution.html#adding-files-to-packaged-application>official documentation</a>, this can be done by setting the <code>appResourcesRootDir</code> property in the Gradle configuration:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>compose.desktop {
</span></span><span style=display:flex><span>    application {
</span></span><span style=display:flex><span>        appResourcesRootDir.<span style=color:#ff6ac1>set</span>(project.layout.projectDirectory.dir(<span style=color:#5af78e>&#34;resources&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The packaging process will include files that are placed in the following subdirectories of the <code>resources/</code> folder:</p><ul><li><strong>Common resources</strong>: <code>resources/common</code>, included in all the targets.</li><li><strong>OS-specific resources</strong>: <code>resources/macos</code>, <code>resources/windows</code>, etc.</li><li><strong>OS + architecture-specific resources</strong>: <code>resources/macos-arm64</code>, <code>resources/windows-x64</code>, etc.</li></ul><p>For example, placing a file in <code>resources/macos-arm64</code> ensures it’s bundled only in Apple Silicon macOS builds.</p><p>By including native libraries through this mechanism, they are automatically signed as part of the release packaging process (for example, during macOS notarization and signing). Having the library signed is a necessary step to be able to execute the library at runtime.</p><h3 id=gradle-task>Gradle Task</h3><p>To automate the copy step, I created a simple custom Gradle task that copies the compiled <code>.dylib</code> file into the correct platform-specific resource directory:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>BuildAndCopyIkloudMacos</span> : DefaultTask() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@get</span>:InputFile
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>val</span> source: RegularFileProperty
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@get</span>:OutputDirectory
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>val</span> destination: DirectoryProperty
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@get</span>:Inject
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>abstract</span> <span style=color:#ff6ac1>val</span> fs: FileSystemOperations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff9f43>@TaskAction</span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>action</span>() {
</span></span><span style=display:flex><span>        fs.copy {
</span></span><span style=display:flex><span>            from(source)
</span></span><span style=display:flex><span>            into(destination)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This task is registered in the Gradle configuration and set to run after the Kotlin/Native build task completes:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>tasks.register&lt;BuildAndCopyIkloudMacos&gt;(<span style=color:#5af78e>&#34;buildAndCopyIkloudMacOS&#34;</span>) {
</span></span><span style=display:flex><span>    dependsOn(<span style=color:#5af78e>&#34;:feedSync:ikloud-macos:linkReleaseSharedIkloud&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> projectDir = rootProject.layout.projectDirectory
</span></span><span style=display:flex><span>    source = layout.buildDirectory.<span style=color:#ff6ac1>file</span>(<span style=color:#5af78e>&#34;bin/ikloud/releaseShared/libikloud.dylib&#34;</span>)
</span></span><span style=display:flex><span>    destination = projectDir.dir(<span style=color:#5af78e>&#34;desktopApp/resources/macos-arm64&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this setup, the native library is automatically compiled and copied into the expected location, so no manual steps are required.</p><h2 id=library-usage>Library usage</h2><p>After compiling and bundling the native <code>.dylib</code> file into the final application, the last step is to invoke the native function from the Compose Multiplatform desktop app.</p><p>A simple Kotlin class is used as a bridge between the JVM and the native code.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>ICloudNativeBridge</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>external</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>iCloudDownload</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>external</code> modifier instructs the Kotlin compiler that the method is implemented in native code, in this case within the macOS <code>.dylib</code> library. The method signature must match the function exposed by the native module using the <code>@CName</code> annotation. For example:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@CName</span>(<span style=color:#5af78e>&#34;Java_com_prof18_feedflow_desktop_feedsync_ICloudNativeBridge_iCloudDownload&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>iCloudDownload</span>(env: CPointer&lt;JNIEnvVar&gt;, clazz: jclass)
</span></span></code></pre></div><p>To make the native method available at runtime, the <code>.dylib</code> file must be explicitly loaded into the JVM process using <code>System.load()</code>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>if</span> (System.getProperty(<span style=color:#5af78e>&#34;os.name&#34;</span>).lowercase() <span style=color:#ff6ac1>==</span> <span style=color:#5af78e>&#34;mac&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> resourcesDir = System.getProperty(<span style=color:#5af78e>&#34;compose.application.resources.dir&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> libraryPath = resourcesDir + File.separator + System.mapLibraryName(<span style=color:#5af78e>&#34;ikloud&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>try</span> {
</span></span><span style=display:flex><span>        System.load(libraryPath)
</span></span><span style=display:flex><span>        ICloudNativeBridge().iCloudDownload()
</span></span><span style=display:flex><span>    } <span style=color:#ff6ac1>catch</span> (e: UnsatisfiedLinkError) {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Handle errors, e.g., log or alert user
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>System.mapLibraryName()</code> function resolves the correct filename format for the platform (e.g., <code>libikloud.dylib</code> on macOS).</p><p>If the library is missing, improperly packaged, or fails to load due to issues like code signing, an <code>UnsatisfiedLinkError</code> exception will be thrown, so it&rsquo;s recommended to handle the exception to avoid unexpected crashes.</p><h2 id=conclusions>Conclusions</h2><p>Using Kotlin Native and JNI introduces some additional complexity and a bit of a learning curve in order to setup all the required infrastructure. Despite that, it’s still a worthwhile approach to gain access to native APIs that otherwise would not be accessible directly through the JVM.</p><p>The complete iCloud syncing implementation on FeedFlow, built using Kotlin/Native and JNI on macOS, is available in <a href=https://github.com/prof18/feed-flow/pull/394>this pull request</a>.</p></section><div class=article-footer><div class=body>To stay up to date with my writing and my projects, follow me on <a href=https://bsky.app/profile/marcogomiero.com target=_blank>Bluesky</a>, <a href=https://androiddev.social/@marcogom target=_blank>Mastodon</a> or <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-69FZ1TLE7E"></script>
<script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-69FZ1TLE7E")}</script></div></body></html>