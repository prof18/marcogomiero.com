<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A journey from Async Task to Kotlin Coroutines | Marco Gomiero</title><meta name=keywords content><meta name=description content="Photo by felipe lopez on Unsplash
  Some weeks ago I released a new version of the RSS Parser Library and I talked about the update in a blog post.
 RSS Parser 2.0: bye bye Async Task, welcome Coroutines This update brought a huge change in the infrastructure of the library. SPOILER: Kotlin and coroutines. Today, in this post I want to talk about the transition process and all the decisions that I have made to develop this new version."><meta name=author content="Marco Gomiero"><link rel=canonical href=https://www.marcogomiero.com/posts/2019/asynctask-to-coroutines/><link crossorigin=anonymous href=/assets/css/stylesheet.min.686715e54e31dbf63447efd76235e41e047fd8826df608657b7b0ddb3a0d900d.css integrity="sha256-aGcV5U4x2/Y0R+/XYjXkHgR/2IJt9ghle3sN2zoNkA0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.marcogomiero.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.marcogomiero.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.marcogomiero.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.marcogomiero.com/apple-touch-icon.png><link rel=mask-icon href=https://www.marcogomiero.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-90975904-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="A journey from Async Task to Kotlin Coroutines"><meta property="og:description" content="Photo by felipe lopez on Unsplash
  Some weeks ago I released a new version of the RSS Parser Library and I talked about the update in a blog post.
 RSS Parser 2.0: bye bye Async Task, welcome Coroutines This update brought a huge change in the infrastructure of the library. SPOILER: Kotlin and coroutines. Today, in this post I want to talk about the transition process and all the decisions that I have made to develop this new version."><meta property="og:type" content="article"><meta property="og:url" content="https://www.marcogomiero.com/posts/2019/asynctask-to-coroutines/"><meta property="og:image" content="https://miro.medium.com/max/1400/0*BnjRJYi8CNeaKOq1"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-14T00:00:00+00:00"><meta property="article:modified_time" content="2019-01-14T00:00:00+00:00"><meta property="og:site_name" content="Marco Gomiero"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://miro.medium.com/max/1400/0*BnjRJYi8CNeaKOq1"><meta name=twitter:title content="A journey from Async Task to Kotlin Coroutines"><meta name=twitter:description content="Photo by felipe lopez on Unsplash
  Some weeks ago I released a new version of the RSS Parser Library and I talked about the update in a blog post.
 RSS Parser 2.0: bye bye Async Task, welcome Coroutines This update brought a huge change in the infrastructure of the library. SPOILER: Kotlin and coroutines. Today, in this post I want to talk about the transition process and all the decisions that I have made to develop this new version."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.marcogomiero.com/posts/"},{"@type":"ListItem","position":3,"name":"A journey from Async Task to Kotlin Coroutines","item":"https://www.marcogomiero.com/posts/2019/asynctask-to-coroutines/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A journey from Async Task to Kotlin Coroutines","name":"A journey from Async Task to Kotlin Coroutines","description":"Photo by felipe lopez on Unsplash\n  Some weeks ago I released a new version of the RSS Parser Library and I talked about the update in a blog post.\n RSS Parser 2.0: bye bye Async Task, welcome Coroutines This update brought a huge change in the infrastructure of the library. SPOILER: Kotlin and coroutines. Today, in this post I want to talk about the transition process and all the decisions that I have made to develop this new version.","keywords":[],"articleBody":"  Photo by felipe lopez on Unsplash\n  Some weeks ago I released a new version of the RSS Parser Library and I talked about the update in a blog post.\n RSS Parser 2.0: bye bye Async Task, welcome Coroutines This update brought a huge change in the infrastructure of the library. SPOILER: Kotlin and coroutines. Today, in this post I want to talk about the transition process and all the decisions that I have made to develop this new version. In this way, I hope to inspire you to leave the Async Task and get into the coroutines world.\n But, before starting with the technical details, I want to share you some resources to get into the coroutine world. If you already know the coroutines you can skip to the second part of the article.\nGet into the coroutine world, it’s funny. I promise: The first thing that you can do to get into the coroutine world is doing the codelab provided by Google.\n Using Kotlin Coroutines in your Android App\n Don’t worry if you don’t understand all the concepts, the codelab is useful to make the first exploration and to receive the inputs and the tools to study a particular argument.\nAfter the codelab, I suggest you give a look to the official documentation that is well written and full of examples.\n Kotlin/kotlinx.coroutines\n Then you could read some articles Android specific and not. Here are some articles that I’ve read:\n An introduction to Kotlin Coroutines*\n  How to make sense of Kotlin coroutines\n  Kotlin Coroutines patterns \u0026 anti-patterns\n  Playing with Kotlin in Android: coroutines and how to get rid of the callback hell\n  Android Networking with Coroutines and Retrofit\n  Handle Complex Network Call with Kotlin Coroutine + Retrofit 2\n  Async code using Kotlin Coroutines\n I suggest also the talks of Chris Banes and Christina Lee:\n So you’ve read the Coroutines guide and you’re ready to start using them in your Android app to coroutines? Great!\n  Coroutines By Example\n Of course, there are lots of resources available and lots of ways to learn the coroutines. These are some advice based on my experience and learning path.\nThe Path From Async Task to Coroutines The first release of the library is dated 18 June 2016, a period when there wasn’t all the beautiful stuff that there is today (for instance, Kotlin) and moreover I did not know all the stuff that I know today. The code was so simple (and now I can also say that was ugly) but it was working.\nOld School Java Code I used an Async Task to handle the network request; the result of the request is sent to an XML Parser that notifies its result when the parsing was done. Here’s the code of the Parser:\npublic class Parser extends AsyncTaskString, Void, String implements Observer { private XMLParser xmlParser; private static ArrayListArticle articles = new ArrayList(); private OnTaskCompleted onComplete; public Parser() { xmlParser = new XMLParser(); xmlParser.addObserver(this); } public interface OnTaskCompleted { void onTaskCompleted(ArrayListArticle list); void onError(); } public void onFinish(OnTaskCompleted onComplete) { this.onComplete = onComplete; } @Override protected String doInBackground(String... ulr) { Response response = null; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(ulr[0]) .build(); try { response = client.newCall(request).execute(); if (response.isSuccessful()) return response.body().string(); } catch (IOException e) { e.printStackTrace(); onComplete.onError(); } return null; } @Override protected void onPostExecute(String result) { if (result != null) { try { xmlParser.parseXML(result); Log.i(\"RSS Parser \", \"RSS parsed correctly!\"); } catch (Exception e) { e.printStackTrace(); onComplete.onError(); } } else onComplete.onError(); } @Override @SuppressWarnings(\"unchecked\") public void update(Observable observable, Object data) { articles = (ArrayListArticle) data; onComplete.onTaskCompleted(articles); } } Then, the result of the parsing (or an error of parsing) is notified to the “main executor” (the application that uses the library) with two simple callbacks.\nParser parser = new Parser(); parser.execute(urlString); parser.onFinish(new Parser.OnTaskCompleted() { //what to do when the parsing is done  @Override public void onTaskCompleted(ArrayListArticle list) { //list is an Array List with all article's information  //set the adapter to recycler view  mAdapter = new ArticleAdapter(list, R.layout.row, MainActivity.this); mRecyclerView.setAdapter(mAdapter); progressBar.setVisibility(View.GONE); mSwipeRefreshLayout.setRefreshing(false); } //what to do in case of error  @Override public void onError() { runOnUiThread(new Runnable() { @Override public void run() { progressBar.setVisibility(View.GONE); mSwipeRefreshLayout.setRefreshing(false); Toast.makeText(MainActivity.this, \"Unable to load data.\", Toast.LENGTH_LONG).show(); Log.i(\"Unable to load \", \"articles\"); } }); } }); Kotlin and Coroutines, a love story After 2 years, I wanted to get rid of Async Task, Java and all the ugly stuff. The perfect candidates for taking the place are Kotlin and the coroutines. However, my biggest concern was maintaining the compatibility with all the devs that still use Java (seriously guys? Love yourself, move to Kotlin). In fact, the Kotlin coroutines cannot be invoked from Java code.\nAt first, I tried to figure out if there was a method to call the coroutines from Java but finally I came up with a brilliant idea: provide the support for both the ways.\nFor the Java support, I decided to use Future and Callable to handle the asynchronous operations. In particular, I implemented two classes that perform respectively the fetching and the parsing task.\nclass XMLFetcher(private val url: String) : Callable { @Throws(Exception::class) override fun call(): String { return CoreXMLFetcher.fetchXML(url) } } class XMLParser(var xml: String) : Callable { @Throws(Exception::class) override fun call(): MutableList { return CoreXMLParser.parseXML(xml) } } The result of the parsing is then notified to the “main executor” using the same callbacks reported above.\nfun execute(url: String) { Executors.newSingleThreadExecutor().submit{ val service = Executors.newFixedThreadPool(2) val f1 = service.submit(XMLFetcher(url)) try { val rssFeed = f1.get() val f2 = service.submit(XMLParser(rssFeed)) onComplete.onTaskCompleted(f2.get()) } catch (e: Exception) { onComplete.onError(e) } finally { service.shutdown() } } } In this way, the old users of the library can still call the same code without noticing any kind of difference but the new ones (and of course also the old) can learn and use the new way.\nAs you can image, the new part is written using the Kotlin coroutines. As above, I separated the fetching and the parsing task. The fetching task is performed by the fetchXML suspending function, that takes the URL of the RSS feed as input and returns a Deferred object that will be the input of the parseXML suspend function. This function will then parse the RSS Feed and returns a list of parsed data.\nobject CoroutineEngine { @Throws(Exception::class) suspend fun fetchXML(url: String) = withContext(Dispatchers.IO) { return@withContext CoreXMLFetcher.fetchXML(url) } @Throws(Exception::class) suspend fun parseXML(xml: Deferred) = withContext(Dispatchers.IO) { return@withContext CoreXMLParser.parseXML(xml.await()) } } These functions are exposed to the “main executor” by using another suspend function, that it will get and parse asynchronously the RSS feed.\n@Throws(Exception::class) suspend fun getArticles(url: String) = withContext(Dispatchers.IO) { val xml = async { CoroutineEngine.fetchXML(url) } return@withContext CoroutineEngine.parseXML(xml) } All the suspend functions reported above are called with the IO Dispatcher that uses a shared pool of on-demand created threads. There are also other dispatchers, give a look to the documentation to find the one that better suits your needs.\nAnd finally, from the ViewModel (or in whatever place depending on the architecture of your app) you can launch the coroutine with a Scope, so, for example, you can stop it if the activity is destroyed, and then “transform” an URL to a List of Articles.\ncoroutineScope.launch(Dispatchers.Main) { try { val parser = Parser() val articleList = parser.getArticles(url) setArticleList(articleList) } catch (e: Exception) { e.printStackTrace() _snackbar.value = \"An error has occurred. Please retry\" setArticleList(mutableListOf()) } } And finally, we have reached the end of my journey from Async Task to Coroutines. Of course, you can use this example as an idea to leave forever the (ugly) Async Tasks.\nIf you want to contribute to the development of the library or simply report a bug, visit the repo on Github: https://github.com/prof18/RSS-Parser\nA special thanks to the (awesome) devs of the Android Developers Italia Community that gave to me some advice. If you are Italian, join us on Slack!\n","wordCount":"1312","inLanguage":"en","datePublished":"2019-01-14T00:00:00Z","dateModified":"2019-01-14T00:00:00Z","author":{"@type":"Person","name":"Marco Gomiero"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.marcogomiero.com/posts/2019/asynctask-to-coroutines/"},"publisher":{"@type":"Organization","name":"Marco Gomiero","logo":{"@type":"ImageObject","url":"https://www.marcogomiero.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://www.marcogomiero.com accesskey=h title="Marco Gomiero (Alt + H)">Marco Gomiero</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.marcogomiero.com/posts/ title=Write><span>Write</span></a></li><li><a href=https://www.marcogomiero.com/talks/ title=Speak><span>Speak</span></a></li><li><a href=https://www.marcogomiero.com/projects/ title=Build><span>Build</span></a></li><li><a href=https://www.marcogomiero.com/about-me/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>A journey from Async Task to Kotlin Coroutines</h1><div class=post-meta style=margin-top:16px><span title="2019-01-14 00:00:00 +0000 UTC">14 January 2019</span>&nbsp;·&nbsp;7 min</div></header><div class=post-content><figure><img loading=lazy src=/img/path.jpeg alt=image><figcaption><p><em>Photo by <a href=https://unsplash.com/@flopez_nice>felipe lopez</a> on <a href=https://unsplash.com>Unsplash</a></em></p></figcaption></figure><p>Some weeks ago I released a new version of the RSS Parser Library and I talked about the update in a blog post.</p><blockquote><p><a href=https://marco.gomiero.com/posts/bye-async-task>RSS Parser 2.0: bye bye Async Task, welcome Coroutines</a>
This update brought a huge change in the infrastructure of the library. SPOILER: Kotlin and coroutines. Today, in this post I want to talk about the transition process and all the decisions that I have made to develop this new version. In this way, I hope to inspire you to leave the Async Task and get into the coroutines world.</p></blockquote><p>But, before starting with the technical details, I want to share you some resources to get into the coroutine world. If you already know the coroutines you can skip to the second part of the article.</p><h2 id=get-into-the-coroutine-world-its-funny-i-promise>Get into the coroutine world, it’s funny. I promise:<a hidden class=anchor aria-hidden=true href=#get-into-the-coroutine-world-its-funny-i-promise>#</a></h2><p>The first thing that you can do to get into the coroutine world is doing the codelab provided by Google.</p><blockquote><p><a href=https://codelabs.developers.google.com/codelabs/kotlin-coroutines/>Using Kotlin Coroutines in your Android App</a></p></blockquote><p>Don’t worry if you don’t understand all the concepts, the codelab is useful to make the first exploration and to receive the inputs and the tools to study a particular argument.</p><p>After the codelab, I suggest you give a look to the official documentation that is well written and full of examples.</p><blockquote><p><a href=https://github.com/Kotlin/kotlinx.coroutines>Kotlin/kotlinx.coroutines</a></p></blockquote><p>Then you could read some articles Android specific and not. Here are some articles that I’ve read:</p><blockquote><p><a href=https://antonis.me/2018/12/12/an-introduction-to-kotlin-coroutines/>An introduction to Kotlin Coroutines*</a></p></blockquote><blockquote><p><a href=https://proandroiddev.com/how-to-make-sense-of-kotlin-coroutines-b666c7151b93>How to make sense of Kotlin coroutines</a></p></blockquote><blockquote><p><a href=https://proandroiddev.com/kotlin-coroutines-patterns-anti-patterns-f9d12984c68e>Kotlin Coroutines patterns & anti-patterns</a></p></blockquote><blockquote><p><a href=https://medium.com/@andrea.bresolin/playing-with-kotlin-in-android-coroutines-and-how-to-get-rid-of-the-callback-hell-a96e817c108b>Playing with Kotlin in Android: coroutines and how to get rid of the callback hell</a></p></blockquote><blockquote><p><a href=https://medium.com/exploring-android/android-networking-with-coroutines-and-retrofit-a2f20dd40a83>Android Networking with Coroutines and Retrofit</a></p></blockquote><blockquote><p><a href=https://blog.oozou.com/handle-complex-network-call-with-kotlin-coroutine-retrofit-2-30a6cd1e0189>Handle Complex Network Call with Kotlin Coroutine + Retrofit 2</a></p></blockquote><blockquote><p><a href=https://proandroiddev.com/async-code-using-kotlin-coroutines-233d201099ff>Async code using Kotlin Coroutines</a></p></blockquote><p>I suggest also the talks of Chris Banes and Christina Lee:</p><blockquote><p><a href=https://chris.banes.me/talks/2018/android-suspenders/>So you’ve read the Coroutines guide and you’re ready to start using them in your Android app to coroutines? Great!</a></p></blockquote><blockquote><p><a href=https://skillsmatter.com/skillscasts/12727-coroutines-by-example>Coroutines By Example</a></p></blockquote><p>Of course, there are lots of resources available and lots of ways to learn the coroutines. These are some advice based on my experience and learning path.</p><h2 id=the-path-from-async-task-to-coroutines>The Path From Async Task to Coroutines<a hidden class=anchor aria-hidden=true href=#the-path-from-async-task-to-coroutines>#</a></h2><p>The first release of the library is dated 18 June 2016, a period when there wasn’t all the beautiful stuff that there is today (for instance, Kotlin) and moreover I did not know all the stuff that I know today. The code was so simple (and now I can also say that was ugly) but it was working.</p><h3 id=old-school-java-code>Old School Java Code<a hidden class=anchor aria-hidden=true href=#old-school-java-code>#</a></h3><p>I used an Async Task to handle the network request; the result of the request is sent to an XML Parser that notifies its result when the parsing was done. Here’s the code of the Parser:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parser</span> <span style=color:#66d9ef>extends</span> AsyncTask<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Void<span style=color:#f92672>,</span> String<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Observer <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>private</span> XMLParser xmlParser<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> ArrayList<span style=color:#f92672>&lt;</span>Article<span style=color:#f92672>&gt;</span> articles <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
    <span style=color:#66d9ef>private</span> OnTaskCompleted onComplete<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Parser</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        xmlParser <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> XMLParser<span style=color:#f92672>();</span>
        xmlParser<span style=color:#f92672>.</span><span style=color:#a6e22e>addObserver</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>OnTaskCompleted</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onTaskCompleted</span><span style=color:#f92672>(</span>ArrayList<span style=color:#f92672>&lt;</span>Article<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onFinish</span><span style=color:#f92672>(</span>OnTaskCompleted onComplete<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onComplete</span> <span style=color:#f92672>=</span> onComplete<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> String <span style=color:#a6e22e>doInBackground</span><span style=color:#f92672>(</span>String<span style=color:#f92672>...</span> ulr<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

        Response response <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        OkHttpClient client <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> OkHttpClient<span style=color:#f92672>();</span>
        Request request <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Request<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>url</span><span style=color:#f92672>(</span>ulr<span style=color:#f92672>[</span>0<span style=color:#f92672>])</span>
                <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>

        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            response <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span><span style=color:#a6e22e>newCall</span><span style=color:#f92672>(</span>request<span style=color:#f92672>).</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>.</span><span style=color:#a6e22e>isSuccessful</span><span style=color:#f92672>())</span>
                <span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span><span style=color:#a6e22e>body</span><span style=color:#f92672>().</span><span style=color:#a6e22e>string</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
            onComplete<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onPostExecute</span><span style=color:#f92672>(</span>String result<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                xmlParser<span style=color:#f92672>.</span><span style=color:#a6e22e>parseXML</span><span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
                Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;RSS Parser &#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;RSS parsed correctly!&#34;</span><span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
                onComplete<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span>
            onComplete<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span><span style=color:#f92672>(</span>Observable observable<span style=color:#f92672>,</span> Object data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        articles <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>ArrayList<span style=color:#f92672>&lt;</span>Article<span style=color:#f92672>&gt;)</span> data<span style=color:#f92672>;</span>
        onComplete<span style=color:#f92672>.</span><span style=color:#a6e22e>onTaskCompleted</span><span style=color:#f92672>(</span>articles<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Then, the result of the parsing (or an error of parsing) is notified to the “main executor” (the application that uses the library) with two simple callbacks.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Parser parser <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Parser<span style=color:#f92672>();</span>
parser<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>urlString<span style=color:#f92672>);</span>
parser<span style=color:#f92672>.</span><span style=color:#a6e22e>onFinish</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Parser<span style=color:#f92672>.</span><span style=color:#a6e22e>OnTaskCompleted</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//what to do when the parsing is done
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onTaskCompleted</span><span style=color:#f92672>(</span>ArrayList<span style=color:#f92672>&lt;</span>Article<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//list is an Array List with all article&#39;s information
</span><span style=color:#75715e></span>        <span style=color:#75715e>//set the adapter to recycler view
</span><span style=color:#75715e></span>        mAdapter <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArticleAdapter<span style=color:#f92672>(</span>list<span style=color:#f92672>,</span> R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>row</span><span style=color:#f92672>,</span> MainActivity<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>);</span>
        mRecyclerView<span style=color:#f92672>.</span><span style=color:#a6e22e>setAdapter</span><span style=color:#f92672>(</span>mAdapter<span style=color:#f92672>);</span>
        progressBar<span style=color:#f92672>.</span><span style=color:#a6e22e>setVisibility</span><span style=color:#f92672>(</span>View<span style=color:#f92672>.</span><span style=color:#a6e22e>GONE</span><span style=color:#f92672>);</span>
        mSwipeRefreshLayout<span style=color:#f92672>.</span><span style=color:#a6e22e>setRefreshing</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>//what to do in case of error
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        runOnUiThread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#a6e22e>@Override</span>
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                progressBar<span style=color:#f92672>.</span><span style=color:#a6e22e>setVisibility</span><span style=color:#f92672>(</span>View<span style=color:#f92672>.</span><span style=color:#a6e22e>GONE</span><span style=color:#f92672>);</span>
                mSwipeRefreshLayout<span style=color:#f92672>.</span><span style=color:#a6e22e>setRefreshing</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
                Toast<span style=color:#f92672>.</span><span style=color:#a6e22e>makeText</span><span style=color:#f92672>(</span>MainActivity<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Unable to load data.&#34;</span><span style=color:#f92672>,</span>
                        Toast<span style=color:#f92672>.</span><span style=color:#a6e22e>LENGTH_LONG</span><span style=color:#f92672>).</span><span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
                Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Unable to load &#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;articles&#34;</span><span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>});</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>});</span>
</code></pre></div><h3 id=kotlin-and-coroutines-a-love-story>Kotlin and Coroutines, a love story<a hidden class=anchor aria-hidden=true href=#kotlin-and-coroutines-a-love-story>#</a></h3><p>After 2 years, I wanted to get rid of Async Task, Java and all the ugly stuff. The perfect candidates for taking the place are Kotlin and the coroutines. However, my biggest concern was maintaining the compatibility with all the devs that still use Java (seriously guys? Love yourself, move to Kotlin). In fact, the Kotlin coroutines cannot be invoked from Java code.</p><p>At first, I tried to figure out if there was a method to call the coroutines from Java but finally I came up with a brilliant idea: provide the support for both the ways.</p><p>For the Java support, I decided to use <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html>Future</a> and <a href=https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html>Callable</a> to handle the asynchronous operations. In particular, I implemented two classes that perform respectively the fetching and the parsing task.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>XMLFetcher</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> url: String) : Callable&lt;String&gt; {
  <span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>call</span>(): String {
      <span style=color:#66d9ef>return</span> CoreXMLFetcher.fetchXML(url)
  }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>XMLParser</span>(<span style=color:#66d9ef>var</span> xml: String) : Callable&lt;MutableList&lt;Article&gt;&gt; {
  <span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>call</span>(): MutableList&lt;Article&gt; {
      <span style=color:#66d9ef>return</span> CoreXMLParser.parseXML(xml)
  }
}
</code></pre></div><p>The result of the parsing is then notified to the “main executor” using the same callbacks reported above.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>execute</span>(url: String) {
  Executors.newSingleThreadExecutor().submit{
      <span style=color:#66d9ef>val</span> service = Executors.newFixedThreadPool(<span style=color:#ae81ff>2</span>)
      <span style=color:#66d9ef>val</span> f1 = service.submit&lt;String&gt;(XMLFetcher(url))
      <span style=color:#66d9ef>try</span> {
          <span style=color:#66d9ef>val</span> rssFeed = f1.<span style=color:#66d9ef>get</span>()
          <span style=color:#66d9ef>val</span> f2 = service.submit(XMLParser(rssFeed))
          onComplete.onTaskCompleted(f2.<span style=color:#66d9ef>get</span>())
      } <span style=color:#66d9ef>catch</span> (e: Exception) {
          onComplete.onError(e)
      } <span style=color:#66d9ef>finally</span> {
          service.shutdown()
      }
  }
}
</code></pre></div><p>In this way, the old users of the library can still call the same code without noticing any kind of difference but the new ones (and of course also the old) can learn and use the new way.</p><p>As you can image, the new part is written using the Kotlin coroutines. As above, I separated the fetching and the parsing task. The fetching task is performed by the <em>fetchXML</em> suspending function, that takes the URL of the RSS feed as input and returns a <a href=https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/>Deferred</a> object that will be the input of the <em>parseXML</em> suspend function. This function will then parse the RSS Feed and returns a list of parsed data.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>object</span> <span style=color:#a6e22e>CoroutineEngine</span> {
  <span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
  <span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>fetchXML</span>(url: String) =
          withContext(Dispatchers.IO) {
              <span style=color:#66d9ef>return</span><span style=color:#a6e22e>@withContext</span> CoreXMLFetcher.fetchXML(url)
          }

  <span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
  <span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>parseXML</span>(xml: Deferred&lt;String&gt;) =
          withContext(Dispatchers.IO) {
              <span style=color:#66d9ef>return</span><span style=color:#a6e22e>@withContext</span> CoreXMLParser.parseXML(xml.await())
          }
}
</code></pre></div><p>These functions are exposed to the “main executor” by using another suspend function, that it will get and parse asynchronously the RSS feed.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#a6e22e>@Throws</span>(Exception<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>)
<span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getArticles</span>(url: String) =
      withContext(Dispatchers.IO) {
          <span style=color:#66d9ef>val</span> xml = async { CoroutineEngine.fetchXML(url) }
          <span style=color:#66d9ef>return</span><span style=color:#a6e22e>@withContext</span> CoroutineEngine.parseXML(xml)
      }
</code></pre></div><p>All the suspend functions reported above are called with the IO Dispatcher that uses a shared pool of on-demand created threads. There are also other dispatchers, give a look to the <a href=https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/>documentation</a> to find the one that better suits your needs.</p><p>And finally, from the ViewModel (or in whatever place depending on the architecture of your app) you can launch the coroutine with a <a href=https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/>Scope</a>, so, for example, you can stop it if the activity is destroyed, and then “transform” an URL to a List of Articles.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>coroutineScope.launch(Dispatchers.Main) {
  <span style=color:#66d9ef>try</span> {
      <span style=color:#66d9ef>val</span> parser = Parser()
      <span style=color:#66d9ef>val</span> articleList = parser.getArticles(url)
      setArticleList(articleList)
  } <span style=color:#66d9ef>catch</span> (e: Exception) {
      e.printStackTrace()
      _snackbar.value = <span style=color:#e6db74>&#34;An error has occurred. Please retry&#34;</span>
      setArticleList(mutableListOf())
  }
}
</code></pre></div><p>And finally, we have reached the end of my journey from Async Task to Coroutines. Of course, you can use this example as an idea to leave forever the (ugly) Async Tasks.</p><p>If you want to contribute to the development of the library or simply report a bug, visit the repo on Github: <a href=https://github.com/prof18/RSS-Parser>https://github.com/prof18/RSS-Parser</a></p><p>A special thanks to the (awesome) devs of the Android Developers Italia Community that gave to me some advice. If you are Italian, join us on <a href=https://androiddevs.it/>Slack</a>!</p></div><div class=article-footer><div class=post-content>To stay up to date with my writing and my projects, follow me on <a href=https://twitter.com/marcoGomier target=_blank>Twitter</a>. If you have any questions, feel free to reach me out!</div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.marcogomiero.com/posts/2019/bottom-bar-swipe-flutter/><span class=title>« Prev</span><br><span>Bottom App Bar with Menu and Swipeable Tabs in Flutter</span></a>
<a class=next href=https://www.marcogomiero.com/posts/2018/bye-async-task/><span class=title>Next »</span><br><span>RSS Parser 2.0: bye bye Async Task, welcome Coroutines</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.marcogomiero.com>Marco Gomiero</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>